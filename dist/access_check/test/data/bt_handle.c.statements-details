Statement(tokens=[0:205] 〈/*-
 * Copyright (c) 2014-present MongoDB, Inc.
 * Copyright (c) 2008-2014 WiredTiger, Inc.
 *	All rights reserved.
 *
 * See the file LICENSE for redistribution information.
 */⌇
⌇
⌇#include "wt_internal.h"
〉,
          kind=StatementKind(is_comment=True,
                             is_preproc=True,
                             is_typedef=None,
                             is_record=None,
                             is_function=None,
                             is_function_def=None,
                             is_function_decl=None,
                             is_statement=None,
                             is_decl=None,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=Token(idx=0,
                                              range=(0, 178),
                                              value='/*-\n'
                                                    ' * Copyright (c) 2014-present MongoDB, Inc.\n'
                                                    ' * Copyright (c) 2008-2014 WiredTiger, Inc.\n'
                                                    ' *\tAll rights reserved.\n'
                                                    ' *\n'
                                                    ' * See the file LICENSE for redistribution information.\n'
                                                    ' */'),
                             postComment=None))
Statement(tokens=[205:271] 〈
⌇static⌇ ⌇int⌇ ⌇__btree_conf⌇(WT_SESSION_IMPL *, WT_CKPT *ckpt, bool)⌇;⌇
〉,
          kind=StatementKind(is_comment=None,
                             is_preproc=None,
                             is_typedef=None,
                             is_record=None,
                             is_function=True,
                             is_function_def=None,
                             is_function_decl=True,
                             is_statement=None,
                             is_decl=True,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=None,
                             postComment=None))
Statement(tokens=[271:325] 〈static⌇ ⌇int⌇ ⌇__btree_get_last_recno⌇(WT_SESSION_IMPL *)⌇;⌇
〉,
          kind=StatementKind(is_comment=None,
                             is_preproc=None,
                             is_typedef=None,
                             is_record=None,
                             is_function=True,
                             is_function_def=None,
                             is_function_decl=True,
                             is_statement=None,
                             is_decl=True,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=None,
                             postComment=None))
Statement(tokens=[325:375] 〈static⌇ ⌇int⌇ ⌇__btree_page_sizes⌇(WT_SESSION_IMPL *)⌇;⌇
〉,
          kind=StatementKind(is_comment=None,
                             is_preproc=None,
                             is_typedef=None,
                             is_record=None,
                             is_function=True,
                             is_function_def=None,
                             is_function_decl=True,
                             is_statement=None,
                             is_decl=True,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=None,
                             postComment=None))
Statement(tokens=[375:422] 〈static⌇ ⌇int⌇ ⌇__btree_preload⌇(WT_SESSION_IMPL *)⌇;⌇
〉,
          kind=StatementKind(is_comment=None,
                             is_preproc=None,
                             is_typedef=None,
                             is_record=None,
                             is_function=True,
                             is_function_def=None,
                             is_function_decl=True,
                             is_statement=None,
                             is_decl=True,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=None,
                             postComment=None))
Statement(tokens=[422:483] 〈static⌇ ⌇int⌇ ⌇__btree_tree_open_empty⌇(WT_SESSION_IMPL *, bool)⌇;⌇
〉,
          kind=StatementKind(is_comment=None,
                             is_preproc=None,
                             is_typedef=None,
                             is_record=None,
                             is_function=True,
                             is_function_def=None,
                             is_function_decl=True,
                             is_statement=None,
                             is_decl=True,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=None,
                             postComment=None))
Statement(tokens=[483:1326] 〈
⌇/*
 * __btree_clear --
 *     Clear a Btree, either on handle discard or re-open.
 */⌇
⌇static⌇ ⌇int⌇
⌇__btree_clear⌇(WT_SESSION_IMPL *session)⌇
⌇{
    WT_BTREE *btree;
    WT_DECL_RET;

    btree = S2BT(session);

    /*
     * If the tree hasn't gone through an open/close cycle, there's no cleanup to be done.
     */
    if (!F_ISSET(btree, WT_BTREE_CLOSED))
        return (0);

    /* Terminate any associated collator. */
    if (btree->collator_owned && btree->collator->terminate != NULL)
        WT_TRET(btree->collator->terminate(btree->collator, &session->iface));

    /* Destroy locks. */
    __wt_rwlock_destroy(session, &btree->ovfl_lock);
    __wt_spin_destroy(session, &btree->flush_lock);

    /* Free allocated memory. */
    __wt_free(session, btree->key_format);
    __wt_free(session, btree->value_format);

    return (ret);
}⌇
〉,
          kind=StatementKind(is_comment=True,
                             is_preproc=None,
                             is_typedef=None,
                             is_record=None,
                             is_function=True,
                             is_function_def=True,
                             is_function_decl=True,
                             is_statement=None,
                             is_decl=True,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=Token(idx=46,
                                              range=(484, 569),
                                              value='/*\n'
                                                    ' * __btree_clear --\n'
                                                    ' *     Clear a Btree, either on handle discard or re-open.\n'
                                                    ' */'),
                             postComment=None))
Function:
FunctionParts(typename=[577:580] 〈int〉,
              name=Token(idx=52, range=(581, 594), value='__btree_clear'),
              args=Token(idx=53, range=(595, 619), value='WT_SESSION_IMPL *session'),
              body=Token(idx=55,
                         range=(622, 1324),
                         value='\n'
                               '    WT_BTREE *btree;\n'
                               '    WT_DECL_RET;\n'
                               '\n'
                               '    btree = S2BT(session);\n'
                               '\n'
                               '    /*\n'
                               "     * If the tree hasn't gone through an open/close cycle, there's no cleanup to be "
                               'done.\n'
                               '     */\n'
                               '    if (!F_ISSET(btree, WT_BTREE_CLOSED))\n'
                               '        return (0);\n'
                               '\n'
                               '    /* Terminate any associated collator. */\n'
                               '    if (btree->collator_owned && btree->collator->terminate != NULL)\n'
                               '        WT_TRET(btree->collator->terminate(btree->collator, &session->iface));\n'
                               '\n'
                               '    /* Destroy locks. */\n'
                               '    __wt_rwlock_destroy(session, &btree->ovfl_lock);\n'
                               '    __wt_spin_destroy(session, &btree->flush_lock);\n'
                               '\n'
                               '    /* Free allocated memory. */\n'
                               '    __wt_free(session, btree->key_format);\n'
                               '    __wt_free(session, btree->value_format);\n'
                               '\n'
                               '    return (ret);\n'),
              preComment=Token(idx=46,
                               range=(484, 569),
                               value='/*\n'
                                     ' * __btree_clear --\n'
                                     ' *     Clear a Btree, either on handle discard or re-open.\n'
                                     ' */'),
              postComment=None,
              is_type_const=False,
              is_type_static=True)
Args:
[Variable(name=Token(idx=3, range=(612, 619), value='session'),
          typename=[595:610] 〈WT_SESSION_IMPL〉,
          preComment=None,
          postComment=None,
          end=None)]
Vars:
[Variable(name=Token(idx=5, range=(637, 642), value='btree'),
          typename=[627:635] 〈WT_BTREE〉,
          preComment=None,
          postComment=None,
          end=';')]
Statement(tokens=[1326:6513] 〈
⌇/*
 * __wt_btree_open --
 *     Open a Btree.
 */⌇
⌇int⌇
⌇__wt_btree_open⌇(WT_SESSION_IMPL *session, const char *op_cfg[])⌇
⌇{
    WT_BM *bm;
    WT_BTREE *btree;
    WT_CKPT ckpt;
    WT_CONFIG_ITEM cval;
    WT_DATA_HANDLE *dhandle;
    WT_DECL_ITEM(tmp);
    WT_DECL_RET;
    size_t root_addr_size;
    uint8_t root_addr[WT_BTREE_MAX_ADDR_COOKIE];
    bool creation, forced_salvage;

    btree = S2BT(session);
    dhandle = session->dhandle;

    /*
     * This may be a re-open, clean up the btree structure. Clear the fields that don't persist
     * across a re-open. Clear all flags other than the operation flags (which are set by the
     * connection handle software that called us).
     */
    WT_RET(__btree_clear(session));
    memset(btree, 0, WT_BTREE_CLEAR_SIZE);
    F_CLR(btree, ~WT_BTREE_SPECIAL_FLAGS);

    /* Set the data handle first, our called functions reasonably use it. */
    btree->dhandle = dhandle;

    /* Checkpoint and verify files are readonly. */
    if (WT_DHANDLE_IS_CHECKPOINT(dhandle) || F_ISSET(btree, WT_BTREE_VERIFY) ||
      F_ISSET(S2C(session), WT_CONN_READONLY))
        F_SET(btree, WT_BTREE_READONLY);

    /* Get the checkpoint information for this name/checkpoint pair. */
    WT_RET(__wt_meta_checkpoint(session, dhandle->name, dhandle->checkpoint, &ckpt));

    /* Set the order number. */
    dhandle->checkpoint_order = ckpt.order;

    /*
     * Bulk-load is only permitted on newly created files, not any empty file -- see the checkpoint
     * code for a discussion.
     */
    creation = ckpt.raw.size == 0;
    if (!creation && F_ISSET(btree, WT_BTREE_BULK))
        WT_ERR_MSG(session, EINVAL, "bulk-load is only supported on newly created objects");

    /* Handle salvage configuration. */
    forced_salvage = false;
    if (F_ISSET(btree, WT_BTREE_SALVAGE)) {
        WT_ERR(__wt_config_gets(session, op_cfg, "force", &cval));
        forced_salvage = cval.val != 0;
    }

    /* Initialize and configure the WT_BTREE structure. */
    WT_ERR(__btree_conf(session, &ckpt, WT_DHANDLE_IS_CHECKPOINT(dhandle)));

    /* Connect to the underlying block manager. */
    WT_ERR(__wt_blkcache_open(
      session, dhandle->name, dhandle->cfg, forced_salvage, false, btree->btree_private.allocsize, &btree->bm));

    bm = btree->bm;

    /*
     * !!!
     * As part of block-manager configuration, we need to return the maximum
     * sized address cookie that a block manager will ever return.  There's
     * a limit of WT_BTREE_MAX_ADDR_COOKIE, but at 255B, it's too large for
     * a Btree with 512B internal pages.  The default block manager packs
     * a wt_off_t and 2 uint32_t's into its cookie, so there's no problem
     * now, but when we create a block manager extension API, we need some
     * way to consider the block manager's maximum cookie size versus the
     * minimum Btree internal node size.
     */
    btree->block_header = bm->block_header(bm);

    /*
     * Open the specified checkpoint unless it's a special command (special commands are responsible
     * for loading their own checkpoints, if any).
     */
    if (!F_ISSET(btree, WT_BTREE_SALVAGE | WT_BTREE_VERIFY)) {
        /*
         * There are two reasons to load an empty tree rather than a checkpoint: either there is no
         * checkpoint (the file is being created), or the load call returns no root page (the
         * checkpoint is for an empty file).
         */
        WT_ERR(bm->checkpoint_load(bm, session, ckpt.raw.data, ckpt.raw.size, root_addr,
          &root_addr_size, F_ISSET(btree, WT_BTREE_READONLY)));
        if (creation || root_addr_size == 0)
            WT_ERR(__btree_tree_open_empty(session, creation));
        else {
            WT_ERR(__wti_btree_tree_open(session, root_addr, root_addr_size));

            /* Warm the cache, if possible. */
            WT_WITH_PAGE_INDEX(session, ret = __btree_preload(session));
            WT_ERR(ret);

            /* Get the last record number in a column-store file. */
            if (btree->type != BTREE_ROW)
                WT_ERR(__btree_get_last_recno(session));
        }
    }

    /*
     * Eviction ignores trees until the handle's open flag is set, configure eviction before that
     * happens.
     *
     * Files that can still be bulk-loaded cannot be evicted. Permanently cache-resident files can
     * never be evicted. Special operations don't enable eviction. The underlying commands may turn
     * on eviction (for example, verify turns on eviction while working a file to keep from
     * consuming the cache), but it's their decision. If an underlying command reconfigures
     * eviction, it must either clear the evict-disabled-open flag or restore the eviction
     * configuration when finished so that handle close behaves correctly.
     */
    if (btree->original ||
      F_ISSET(btree, WT_BTREE_IN_MEMORY | WT_BTREE_SALVAGE | WT_BTREE_VERIFY)) {
        WT_ERR(__wt_evict_file_exclusive_on(session));
        btree->evict.evict_disabled_open = true;
    }

    if (0) {
err:
        WT_TRET(__wt_btree_close(session));
    }
    __wt_meta_checkpoint_free(session, &ckpt);

    __wt_scr_free(session, &tmp);
    return (ret);
}⌇
〉,
          kind=StatementKind(is_comment=True,
                             is_preproc=None,
                             is_typedef=None,
                             is_record=None,
                             is_function=True,
                             is_function_def=True,
                             is_function_decl=True,
                             is_statement=None,
                             is_decl=True,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=Token(idx=58,
                                              range=(1327, 1376),
                                              value='/*\n * __wt_btree_open --\n *     Open a Btree.\n */'),
                             postComment=None))
Function:
FunctionParts(typename=[1377:1380] 〈int〉,
              name=Token(idx=62, range=(1381, 1396), value='__wt_btree_open'),
              args=Token(idx=63, range=(1397, 1443), value='WT_SESSION_IMPL *session, const char *op_cfg[]'),
              body=Token(idx=65,
                         range=(1446, 6511),
                         value='\n'
                               '    WT_BM *bm;\n'
                               '    WT_BTREE *btree;\n'
                               '    WT_CKPT ckpt;\n'
                               '    WT_CONFIG_ITEM cval;\n'
                               '    WT_DATA_HANDLE *dhandle;\n'
                               '    WT_DECL_ITEM(tmp);\n'
                               '    WT_DECL_RET;\n'
                               '    size_t root_addr_size;\n'
                               '    uint8_t root_addr[WT_BTREE_MAX_ADDR_COOKIE];\n'
                               '    bool creation, forced_salvage;\n'
                               '\n'
                               '    btree = S2BT(session);\n'
                               '    dhandle = session->dhandle;\n'
                               '\n'
                               '    /*\n'
                               '     * This may be a re-open, clean up the btree structure. Clear the fields that '
                               "don't persist\n"
                               '     * across a re-open. Clear all flags other than the operation flags (which are set '
                               'by the\n'
                               '     * connection handle software that called us).\n'
                               '     */\n'
                               '    WT_RET(__btree_clear(session));\n'
                               '    memset(btree, 0, WT_BTREE_CLEAR_SIZE);\n'
                               '    F_CLR(btree, ~WT_BTREE_SPECIAL_FLAGS);\n'
                               '\n'
                               '    /* Set the data handle first, our called functions reasonably use it. */\n'
                               '    btree->dhandle = dhandle;\n'
                               '\n'
                               '    /* Checkpoint and verify files are readonly. */\n'
                               '    if (WT_DHANDLE_IS_CHECKPOINT(dhandle) || F_ISSET(btree, WT_BTREE_VERIFY) ||\n'
                               '      F_ISSET(S2C(session), WT_CONN_READONLY))\n'
                               '        F_SET(btree, WT_BTREE_READONLY);\n'
                               '\n'
                               '    /* Get the checkpoint information for this name/checkpoint pair. */\n'
                               '    WT_RET(__wt_meta_checkpoint(session, dhandle->name, dhandle->checkpoint, &ckpt));\n'
                               '\n'
                               '    /* Set the order number. */\n'
                               '    dhandle->checkpoint_order = ckpt.order;\n'
                               '\n'
                               '    /*\n'
                               '     * Bulk-load is only permitted on newly created files, not any empty file -- see '
                               'the checkpoint\n'
                               '     * code for a discussion.\n'
                               '     */\n'
                               '    creation = ckpt.raw.size == 0;\n'
                               '    if (!creation && F_ISSET(btree, WT_BTREE_BULK))\n'
                               '        WT_ERR_MSG(session, EINVAL, "bulk-load is only supported on newly created '
                               'objects");\n'
                               '\n'
                               '    /* Handle salvage configuration. */\n'
                               '    forced_salvage = false;\n'
                               '    if (F_ISSET(btree, WT_BTREE_SALVAGE)) {\n'
                               '        WT_ERR(__wt_config_gets(session, op_cfg, "force", &cval));\n'
                               '        forced_salvage = cval.val != 0;\n'
                               '    }\n'
                               '\n'
                               '    /* Initialize and configure the WT_BTREE structure. */\n'
                               '    WT_ERR(__btree_conf(session, &ckpt, WT_DHANDLE_IS_CHECKPOINT(dhandle)));\n'
                               '\n'
                               '    /* Connect to the underlying block manager. */\n'
                               '    WT_ERR(__wt_blkcache_open(\n'
                               '      session, dhandle->name, dhandle->cfg, forced_salvage, false, '
                               'btree->btree_private.allocsize, &btree->bm));\n'
                               '\n'
                               '    bm = btree->bm;\n'
                               '\n'
                               '    /*\n'
                               '     * !!!\n'
                               '     * As part of block-manager configuration, we need to return the maximum\n'
                               "     * sized address cookie that a block manager will ever return.  There's\n"
                               "     * a limit of WT_BTREE_MAX_ADDR_COOKIE, but at 255B, it's too large for\n"
                               '     * a Btree with 512B internal pages.  The default block manager packs\n'
                               "     * a wt_off_t and 2 uint32_t's into its cookie, so there's no problem\n"
                               '     * now, but when we create a block manager extension API, we need some\n'
                               "     * way to consider the block manager's maximum cookie size versus the\n"
                               '     * minimum Btree internal node size.\n'
                               '     */\n'
                               '    btree->block_header = bm->block_header(bm);\n'
                               '\n'
                               '    /*\n'
                               "     * Open the specified checkpoint unless it's a special command (special commands "
                               'are responsible\n'
                               '     * for loading their own checkpoints, if any).\n'
                               '     */\n'
                               '    if (!F_ISSET(btree, WT_BTREE_SALVAGE | WT_BTREE_VERIFY)) {\n'
                               '        /*\n'
                               '         * There are two reasons to load an empty tree rather than a checkpoint: '
                               'either there is no\n'
                               '         * checkpoint (the file is being created), or the load call returns no root '
                               'page (the\n'
                               '         * checkpoint is for an empty file).\n'
                               '         */\n'
                               '        WT_ERR(bm->checkpoint_load(bm, session, ckpt.raw.data, ckpt.raw.size, '
                               'root_addr,\n'
                               '          &root_addr_size, F_ISSET(btree, WT_BTREE_READONLY)));\n'
                               '        if (creation || root_addr_size == 0)\n'
                               '            WT_ERR(__btree_tree_open_empty(session, creation));\n'
                               '        else {\n'
                               '            WT_ERR(__wti_btree_tree_open(session, root_addr, root_addr_size));\n'
                               '\n'
                               '            /* Warm the cache, if possible. */\n'
                               '            WT_WITH_PAGE_INDEX(session, ret = __btree_preload(session));\n'
                               '            WT_ERR(ret);\n'
                               '\n'
                               '            /* Get the last record number in a column-store file. */\n'
                               '            if (btree->type != BTREE_ROW)\n'
                               '                WT_ERR(__btree_get_last_recno(session));\n'
                               '        }\n'
                               '    }\n'
                               '\n'
                               '    /*\n'
                               "     * Eviction ignores trees until the handle's open flag is set, configure eviction "
                               'before that\n'
                               '     * happens.\n'
                               '     *\n'
                               '     * Files that can still be bulk-loaded cannot be evicted. Permanently '
                               'cache-resident files can\n'
                               "     * never be evicted. Special operations don't enable eviction. The underlying "
                               'commands may turn\n'
                               '     * on eviction (for example, verify turns on eviction while working a file to keep '
                               'from\n'
                               "     * consuming the cache), but it's their decision. If an underlying command "
                               'reconfigures\n'
                               '     * eviction, it must either clear the evict-disabled-open flag or restore the '
                               'eviction\n'
                               '     * configuration when finished so that handle close behaves correctly.\n'
                               '     */\n'
                               '    if (btree->original ||\n'
                               '      F_ISSET(btree, WT_BTREE_IN_MEMORY | WT_BTREE_SALVAGE | WT_BTREE_VERIFY)) {\n'
                               '        WT_ERR(__wt_evict_file_exclusive_on(session));\n'
                               '        btree->evict.evict_disabled_open = true;\n'
                               '    }\n'
                               '\n'
                               '    if (0) {\n'
                               'err:\n'
                               '        WT_TRET(__wt_btree_close(session));\n'
                               '    }\n'
                               '    __wt_meta_checkpoint_free(session, &ckpt);\n'
                               '\n'
                               '    __wt_scr_free(session, &tmp);\n'
                               '    return (ret);\n'),
              preComment=Token(idx=58,
                               range=(1327, 1376),
                               value='/*\n * __wt_btree_open --\n *     Open a Btree.\n */'),
              postComment=None,
              is_type_const=False,
              is_type_static=False)
Args:
[Variable(name=Token(idx=3, range=(1414, 1421), value='session'),
          typename=[1397:1412] 〈WT_SESSION_IMPL〉,
          preComment=None,
          postComment=None,
          end=','),
 Variable(name=Token(idx=11, range=(1435, 1441), value='op_cfg'),
          typename=[1429:1433] 〈char〉,
          preComment=None,
          postComment=None,
          end=None)]
Vars:
[Variable(name=Token(idx=5, range=(1458, 1460), value='bm'),
          typename=[1451:1456] 〈WT_BM〉,
          preComment=None,
          postComment=None,
          end=';'),
 Variable(name=Token(idx=12, range=(1476, 1481), value='btree'),
          typename=[1466:1474] 〈WT_BTREE〉,
          preComment=None,
          postComment=None,
          end=';'),
 Variable(name=Token(idx=18, range=(1495, 1499), value='ckpt'),
          typename=[1487:1494] 〈WT_CKPT〉,
          preComment=None,
          postComment=None,
          end=';'),
 Variable(name=Token(idx=24, range=(1520, 1524), value='cval'),
          typename=[1505:1519] 〈WT_CONFIG_ITEM〉,
          preComment=None,
          postComment=None,
          end=';'),
 Variable(name=Token(idx=31, range=(1546, 1553), value='dhandle'),
          typename=[1530:1544] 〈WT_DATA_HANDLE〉,
          preComment=None,
          postComment=None,
          end=';')]
Statement(tokens=[6513:8457] 〈
⌇/*
 * __wt_btree_close --
 *     Close a Btree.
 */⌇
⌇int⌇
⌇__wt_btree_close⌇(WT_SESSION_IMPL *session)⌇
⌇{
    WT_BM *bm;
    WT_BTREE *btree;
    WT_DECL_RET;

    btree = S2BT(session);

    /*
     * The close process isn't the same as discarding the handle: we might re-open the handle, which
     * isn't a big deal, but the backing blocks for the handle may not yet have been discarded from
     * the cache, and eviction uses WT_BTREE structure elements. Free backing resources but leave
     * the rest alone, and we'll discard the structure when we discard the data handle.
     *
     * Handles can be closed multiple times, ignore all but the first.
     */
    if (F_ISSET(btree, WT_BTREE_CLOSED))
        return (0);
    F_SET(btree, WT_BTREE_CLOSED);

    /*
     * Verify the history store state. If the history store is open and this btree has history store
     * entries, it can't be a metadata file, nor can it be the history store file.
     */
    WT_ASSERT(session,
      !F_ISSET(S2C(session), WT_CONN_HS_OPEN) || !btree->hs_entries ||
        (!WT_IS_METADATA(btree->dhandle) && !WT_IS_HS(btree->dhandle)));

    /* Clear the saved checkpoint information. */
    __wt_meta_saved_ckptlist_free(session);

    /*
     * If we turned eviction off and never turned it back on, do that now, otherwise the counter
     * will be off.
     */
    if (btree->evict.evict_disabled_open) {
        btree->evict.evict_disabled_open = false;
        __wt_evict_file_exclusive_off(session);
    }

    /* Discard any underlying block manager resources. */
    if ((bm = btree->bm) != NULL) {
        btree->bm = NULL;

        /* Unload the checkpoint, unless it's a special command. */
        if (!F_ISSET(btree, WT_BTREE_SALVAGE | WT_BTREE_VERIFY))
            WT_TRET(bm->checkpoint_unload(bm, session));

        /* Close the underlying block manager reference. */
        WT_TRET(bm->close(bm, session));
    }

    return (ret);
}⌇
〉,
          kind=StatementKind(is_comment=True,
                             is_preproc=None,
                             is_typedef=None,
                             is_record=None,
                             is_function=True,
                             is_function_def=True,
                             is_function_decl=True,
                             is_statement=None,
                             is_decl=True,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=Token(idx=68,
                                              range=(6514, 6565),
                                              value='/*\n * __wt_btree_close --\n *     Close a Btree.\n */'),
                             postComment=None))
Function:
FunctionParts(typename=[6566:6569] 〈int〉,
              name=Token(idx=72, range=(6570, 6586), value='__wt_btree_close'),
              args=Token(idx=73, range=(6587, 6611), value='WT_SESSION_IMPL *session'),
              body=Token(idx=75,
                         range=(6614, 8455),
                         value='\n'
                               '    WT_BM *bm;\n'
                               '    WT_BTREE *btree;\n'
                               '    WT_DECL_RET;\n'
                               '\n'
                               '    btree = S2BT(session);\n'
                               '\n'
                               '    /*\n'
                               "     * The close process isn't the same as discarding the handle: we might re-open the "
                               'handle, which\n'
                               "     * isn't a big deal, but the backing blocks for the handle may not yet have been "
                               'discarded from\n'
                               '     * the cache, and eviction uses WT_BTREE structure elements. Free backing '
                               'resources but leave\n'
                               "     * the rest alone, and we'll discard the structure when we discard the data "
                               'handle.\n'
                               '     *\n'
                               '     * Handles can be closed multiple times, ignore all but the first.\n'
                               '     */\n'
                               '    if (F_ISSET(btree, WT_BTREE_CLOSED))\n'
                               '        return (0);\n'
                               '    F_SET(btree, WT_BTREE_CLOSED);\n'
                               '\n'
                               '    /*\n'
                               '     * Verify the history store state. If the history store is open and this btree has '
                               'history store\n'
                               "     * entries, it can't be a metadata file, nor can it be the history store file.\n"
                               '     */\n'
                               '    WT_ASSERT(session,\n'
                               '      !F_ISSET(S2C(session), WT_CONN_HS_OPEN) || !btree->hs_entries ||\n'
                               '        (!WT_IS_METADATA(btree->dhandle) && !WT_IS_HS(btree->dhandle)));\n'
                               '\n'
                               '    /* Clear the saved checkpoint information. */\n'
                               '    __wt_meta_saved_ckptlist_free(session);\n'
                               '\n'
                               '    /*\n'
                               '     * If we turned eviction off and never turned it back on, do that now, otherwise '
                               'the counter\n'
                               '     * will be off.\n'
                               '     */\n'
                               '    if (btree->evict.evict_disabled_open) {\n'
                               '        btree->evict.evict_disabled_open = false;\n'
                               '        __wt_evict_file_exclusive_off(session);\n'
                               '    }\n'
                               '\n'
                               '    /* Discard any underlying block manager resources. */\n'
                               '    if ((bm = btree->bm) != NULL) {\n'
                               '        btree->bm = NULL;\n'
                               '\n'
                               "        /* Unload the checkpoint, unless it's a special command. */\n"
                               '        if (!F_ISSET(btree, WT_BTREE_SALVAGE | WT_BTREE_VERIFY))\n'
                               '            WT_TRET(bm->checkpoint_unload(bm, session));\n'
                               '\n'
                               '        /* Close the underlying block manager reference. */\n'
                               '        WT_TRET(bm->close(bm, session));\n'
                               '    }\n'
                               '\n'
                               '    return (ret);\n'),
              preComment=Token(idx=68,
                               range=(6514, 6565),
                               value='/*\n * __wt_btree_close --\n *     Close a Btree.\n */'),
              postComment=None,
              is_type_const=False,
              is_type_static=False)
Args:
[Variable(name=Token(idx=3, range=(6604, 6611), value='session'),
          typename=[6587:6602] 〈WT_SESSION_IMPL〉,
          preComment=None,
          postComment=None,
          end=None)]
Vars:
[Variable(name=Token(idx=5, range=(6626, 6628), value='bm'),
          typename=[6619:6624] 〈WT_BM〉,
          preComment=None,
          postComment=None,
          end=';'),
 Variable(name=Token(idx=12, range=(6644, 6649), value='btree'),
          typename=[6634:6642] 〈WT_BTREE〉,
          preComment=None,
          postComment=None,
          end=';')]
Statement(tokens=[8457:8769] 〈
⌇/*
 * __wt_btree_discard --
 *     Discard a Btree.
 */⌇
⌇int⌇
⌇__wt_btree_discard⌇(WT_SESSION_IMPL *session)⌇
⌇{
    WT_BTREE *btree;
    WT_DECL_RET;

    ret = __btree_clear(session);

    btree = S2BT(session);
    __wt_overwrite_and_free(session, btree);
    session->dhandle->handle = NULL;

    return (ret);
}⌇
〉,
          kind=StatementKind(is_comment=True,
                             is_preproc=None,
                             is_typedef=None,
                             is_record=None,
                             is_function=True,
                             is_function_def=True,
                             is_function_decl=True,
                             is_statement=None,
                             is_decl=True,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=Token(idx=78,
                                              range=(8458, 8513),
                                              value='/*\n * __wt_btree_discard --\n *     Discard a Btree.\n */'),
                             postComment=None))
Function:
FunctionParts(typename=[8514:8517] 〈int〉,
              name=Token(idx=82, range=(8518, 8536), value='__wt_btree_discard'),
              args=Token(idx=83, range=(8537, 8561), value='WT_SESSION_IMPL *session'),
              body=Token(idx=85,
                         range=(8564, 8767),
                         value='\n'
                               '    WT_BTREE *btree;\n'
                               '    WT_DECL_RET;\n'
                               '\n'
                               '    ret = __btree_clear(session);\n'
                               '\n'
                               '    btree = S2BT(session);\n'
                               '    __wt_overwrite_and_free(session, btree);\n'
                               '    session->dhandle->handle = NULL;\n'
                               '\n'
                               '    return (ret);\n'),
              preComment=Token(idx=78,
                               range=(8458, 8513),
                               value='/*\n * __wt_btree_discard --\n *     Discard a Btree.\n */'),
              postComment=None,
              is_type_const=False,
              is_type_static=False)
Args:
[Variable(name=Token(idx=3, range=(8554, 8561), value='session'),
          typename=[8537:8552] 〈WT_SESSION_IMPL〉,
          preComment=None,
          postComment=None,
          end=None)]
Vars:
[Variable(name=Token(idx=5, range=(8579, 8584), value='btree'),
          typename=[8569:8577] 〈WT_BTREE〉,
          preComment=None,
          postComment=None,
          end=';')]
Statement(tokens=[8769:10027] 〈
⌇/*
 * __wt_btree_config_encryptor --
 *     Return an encryptor handle based on the configuration.
 */⌇
⌇int⌇
⌇__wt_btree_config_encryptor⌇(
  WT_SESSION_IMPL *session, const char **cfg, WT_KEYED_ENCRYPTOR **kencryptorp)⌇
⌇{
    WT_CONFIG_ITEM cval, enc, keyid;
    WT_DECL_RET;
    const char *enc_cfg[] = {NULL, NULL};

    /*
     * We do not use __wt_config_gets_none here because "none" and the empty string have different
     * meanings. The empty string means inherit the system encryption setting and "none" means this
     * table is in the clear even if the database is encrypted.
     */
    WT_RET(__wt_config_gets(session, cfg, "encryption.name", &cval));
    if (cval.len == 0)
        *kencryptorp = S2C(session)->kencryptor;
    else if (WT_CONFIG_LIT_MATCH("none", cval))
        *kencryptorp = NULL;
    else {
        WT_RET(__wt_config_gets_none(session, cfg, "encryption.keyid", &keyid));
        WT_RET(__wt_config_gets(session, cfg, "encryption", &enc));
        if (enc.len != 0)
            WT_RET(__wt_strndup(session, enc.str, enc.len, &enc_cfg[0]));
        ret = __wt_encryptor_config(session, &cval, &keyid, (WT_CONFIG_ARG *)enc_cfg, kencryptorp);
        __wt_free(session, enc_cfg[0]);
        WT_RET(ret);
    }
    return (0);
}⌇
〉,
          kind=StatementKind(is_comment=True,
                             is_preproc=None,
                             is_typedef=None,
                             is_record=None,
                             is_function=True,
                             is_function_def=True,
                             is_function_decl=True,
                             is_statement=None,
                             is_decl=True,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=Token(idx=88,
                                              range=(8770, 8872),
                                              value='/*\n'
                                                    ' * __wt_btree_config_encryptor --\n'
                                                    ' *     Return an encryptor handle based on the configuration.\n'
                                                    ' */'),
                             postComment=None))
Function:
FunctionParts(typename=[8873:8876] 〈int〉,
              name=Token(idx=92, range=(8877, 8904), value='__wt_btree_config_encryptor'),
              args=Token(idx=93,
                         range=(8905, 8984),
                         value='\n  WT_SESSION_IMPL *session, const char **cfg, WT_KEYED_ENCRYPTOR **kencryptorp'),
              body=Token(idx=95,
                         range=(8987, 10025),
                         value='\n'
                               '    WT_CONFIG_ITEM cval, enc, keyid;\n'
                               '    WT_DECL_RET;\n'
                               '    const char *enc_cfg[] = {NULL, NULL};\n'
                               '\n'
                               '    /*\n'
                               '     * We do not use __wt_config_gets_none here because "none" and the empty string '
                               'have different\n'
                               '     * meanings. The empty string means inherit the system encryption setting and '
                               '"none" means this\n'
                               '     * table is in the clear even if the database is encrypted.\n'
                               '     */\n'
                               '    WT_RET(__wt_config_gets(session, cfg, "encryption.name", &cval));\n'
                               '    if (cval.len == 0)\n'
                               '        *kencryptorp = S2C(session)->kencryptor;\n'
                               '    else if (WT_CONFIG_LIT_MATCH("none", cval))\n'
                               '        *kencryptorp = NULL;\n'
                               '    else {\n'
                               '        WT_RET(__wt_config_gets_none(session, cfg, "encryption.keyid", &keyid));\n'
                               '        WT_RET(__wt_config_gets(session, cfg, "encryption", &enc));\n'
                               '        if (enc.len != 0)\n'
                               '            WT_RET(__wt_strndup(session, enc.str, enc.len, &enc_cfg[0]));\n'
                               '        ret = __wt_encryptor_config(session, &cval, &keyid, (WT_CONFIG_ARG *)enc_cfg, '
                               'kencryptorp);\n'
                               '        __wt_free(session, enc_cfg[0]);\n'
                               '        WT_RET(ret);\n'
                               '    }\n'
                               '    return (0);\n'),
              preComment=Token(idx=88,
                               range=(8770, 8872),
                               value='/*\n'
                                     ' * __wt_btree_config_encryptor --\n'
                                     ' *     Return an encryptor handle based on the configuration.\n'
                                     ' */'),
              postComment=None,
              is_type_const=False,
              is_type_static=False)
Args:
[Variable(name=Token(idx=5, range=(8925, 8932), value='session'),
          typename=[8908:8923] 〈WT_SESSION_IMPL〉,
          preComment=None,
          postComment=None,
          end=','),
 Variable(name=Token(idx=14, range=(8947, 8950), value='cfg'),
          typename=[8940:8944] 〈char〉,
          preComment=None,
          postComment=None,
          end=','),
 Variable(name=Token(idx=21, range=(8973, 8984), value='kencryptorp'),
          typename=[8952:8970] 〈WT_KEYED_ENCRYPTOR〉,
          preComment=None,
          postComment=None,
          end=None)]
Vars:
[Variable(name=Token(idx=4, range=(9007, 9011), value='cval'),
          typename=[8992:9006] 〈WT_CONFIG_ITEM〉,
          preComment=None,
          postComment=None,
          end=','),
 Variable(name=Token(idx=7, range=(9013, 9016), value='enc'),
          typename=[8992:9006] 〈WT_CONFIG_ITEM〉,
          preComment=None,
          postComment=None,
          end=','),
 Variable(name=Token(idx=10, range=(9018, 9023), value='keyid'),
          typename=[8992:9006] 〈WT_CONFIG_ITEM〉,
          preComment=None,
          postComment=None,
          end=';')]
Statement(tokens=[10027:22934] 〈
⌇/*
 * __btree_conf --
 *     Configure a WT_BTREE structure.
 */⌇
⌇static⌇ ⌇int⌇
⌇__btree_conf⌇(WT_SESSION_IMPL *session, WT_CKPT *ckpt, bool is_ckpt)⌇
⌇{
    WT_BTREE *btree;
    WT_CONFIG_ITEM cval, metadata;
    WT_CONNECTION_IMPL *conn;
    WT_DECL_RET;
    int64_t maj_version, min_version;
    uint32_t bitcnt;
    const char **cfg;
    bool fixed;

    btree = S2BT(session);
    cfg = btree->dhandle->cfg;
    conn = S2C(session);

    /* Dump out format information. */
    if (WT_VERBOSE_ISSET(session, WT_VERB_VERSION)) {
        WT_RET(__wt_config_gets(session, cfg, "version.major", &cval));
        maj_version = cval.val;
        WT_RET(__wt_config_gets(session, cfg, "version.minor", &cval));
        min_version = cval.val;
        __wt_verbose(session, WT_VERB_VERSION, "btree version: %" PRId64 ".%" PRId64, maj_version,
          min_version);
    }

    /* Get the file ID. */
    WT_RET(__wt_config_gets(session, cfg, "id", &cval));
    btree->id = (uint32_t)cval.val;

    /* Validate file types and check the data format plan. */
    WT_RET(__wt_config_gets(session, cfg, "key_format", &cval));
    WT_RET(__wt_struct_confchk(session, &cval));
    if (WT_CONFIG_LIT_MATCH("r", cval))
        btree->type = BTREE_COL_VAR;
    else
        btree->type = BTREE_ROW;
    WT_RET(__wt_strndup(session, cval.str, cval.len, &btree->key_format));

    WT_RET(__wt_config_gets(session, cfg, "value_format", &cval));
    WT_RET(__wt_struct_confchk(session, &cval));
    WT_RET(__wt_strndup(session, cval.str, cval.len, &btree->value_format));

    /* Row-store key comparison. */
    if (btree->type == BTREE_ROW) {
        WT_RET(__wt_config_gets_none(session, cfg, "collator", &cval));
        if (cval.len != 0) {
            WT_RET(__wt_config_gets(session, cfg, "app_metadata", &metadata));
            WT_RET(__wt_collator_config(session, btree->dhandle->name, &cval, &metadata,
              &btree->collator, &btree->collator_owned));
        }
    }

    /* Column-store: check for fixed-size data. */
    if (btree->type == BTREE_COL_VAR) {
        WT_RET(__wt_struct_check(session, cval.str, cval.len, &fixed, &bitcnt));
        if (fixed) {
            if (bitcnt == 0 || bitcnt > 8)
                WT_RET_MSG(session, EINVAL,
                  "fixed-width field sizes must be greater than 0 and less than or equal to 8");
            btree->bitcnt = (uint8_t)bitcnt;
            btree->type = BTREE_COL_FIX;
        }
    }

    /* Page sizes */
    WT_RET(__btree_page_sizes(session));

    WT_RET(__wt_config_gets(session, cfg, "cache_resident", &cval));
    if (cval.val)
        F_SET(btree, WT_BTREE_IN_MEMORY);
    else
        F_CLR(btree, WT_BTREE_IN_MEMORY);

    WT_RET(__wt_config_gets(session, cfg, "ignore_in_memory_cache_size", &cval));
    if (cval.val) {
        if (!F_ISSET(conn, WT_CONN_IN_MEMORY))
            WT_RET_MSG(session, EINVAL,
              "ignore_in_memory_cache_size setting is only valid with databases configured to run "
              "in-memory");
        F_SET(btree, WT_BTREE_IGNORE_CACHE);
    } else
        F_CLR(btree, WT_BTREE_IGNORE_CACHE);

    /*
     * Turn on logging when it's enabled in the database and not disabled for the tree. Timestamp
     * behavior is described by the logging configurations for historical reasons; logged objects
     * imply commit-level durability and ignored timestamps, not-logged objects imply checkpoint-
     * level durability and supported timestamps. In-memory configurations default to ignoring all
     * timestamps, and the application uses the logging configuration flag to turn on timestamps.
     */
    if (FLD_ISSET(conn->log_flags, WT_CONN_LOG_ENABLED)) {
        WT_RET(__wt_config_gets(session, cfg, "log.enabled", &cval));
        if (cval.val)
            F_SET(btree, WT_BTREE_LOGGED);
    }
    if (F_ISSET(conn, WT_CONN_IN_MEMORY)) {
        F_SET(btree, WT_BTREE_LOGGED);
        WT_RET(__wt_config_gets(session, cfg, "log.enabled", &cval));
        if (!cval.val)
            F_CLR(btree, WT_BTREE_LOGGED);
    }

    /*
     * The metadata isn't blocked by in-memory cache limits because metadata "unroll" is performed
     * by updates that are potentially blocked by the cache-full checks.
     *
     * The metadata file ignores timestamps and is logged if at all possible.
     */
    if (WT_IS_METADATA(btree->dhandle)) {
        F_SET(btree, WT_BTREE_IGNORE_CACHE);
        F_SET(btree, WT_BTREE_LOGGED);
    }

    /* The history store file is never logged and supports timestamps. */
    if (strcmp(session->dhandle->name, WT_HS_URI) == 0) {
        F_SET(btree->dhandle, WT_DHANDLE_HS);
        F_CLR(btree, WT_BTREE_LOGGED);
    }

    WT_RET(__wt_config_gets(session, cfg, "tiered_object", &cval));
    if (cval.val)
        F_SET(btree, WT_BTREE_NO_CHECKPOINT);
    else
        F_CLR(btree, WT_BTREE_NO_CHECKPOINT);

    /* Get the last flush times for tiered storage, if applicable. */
    btree->flush_most_recent_secs = 0;
    ret = __wt_config_gets(session, cfg, "flush_time", &cval);
    WT_RET_NOTFOUND_OK(ret);
    if (ret == 0)
        btree->flush_most_recent_secs = (uint64_t)cval.val;

    btree->flush_most_recent_ts = 0;
    ret = __wt_config_gets(session, cfg, "flush_timestamp", &cval);
    WT_RET_NOTFOUND_OK(ret);
    if (ret == 0 && cval.len != 0)
        WT_RET(__wt_txn_parse_timestamp_raw(
          session, "flush_timestamp", &btree->flush_most_recent_ts, &cval));

    /* Checksums */
    WT_RET(__wt_config_gets(session, cfg, "checksum", &cval));
    if (WT_CONFIG_LIT_MATCH("on", cval))
        btree->checksum = CKSUM_ON;
    else if (WT_CONFIG_LIT_MATCH("off", cval))
        btree->checksum = CKSUM_OFF;
    else if (WT_CONFIG_LIT_MATCH("uncompressed", cval))
        btree->checksum = CKSUM_UNCOMPRESSED;
    else
        btree->checksum = CKSUM_UNENCRYPTED;

    ret = __wt_config_gets(session, cfg, "huffman_value", &cval);
    if (ret == 0 && cval.len != 0)
        WT_RET_MSG(session, ENOTSUP, "Huffman encoding for values is no longer supported.");

    /*
     * Reconciliation configuration:
     *	Block compression (all)
     *	Dictionary compression (variable-length column-store, row-store)
     *	Page-split percentage
     *	Prefix compression (row-store)
     *	Suffix compression (row-store)
     */
    switch (btree->type) {
    case BTREE_COL_FIX:
        break;
    case BTREE_ROW:
        WT_RET(__wt_config_gets(session, cfg, "internal_key_truncate", &cval));
        btree->internal_key_truncate = cval.val != 0;

        WT_RET(__wt_config_gets(session, cfg, "prefix_compression", &cval));
        btree->prefix_compression = cval.val != 0;
        WT_RET(__wt_config_gets(session, cfg, "prefix_compression_min", &cval));
        btree->prefix_compression_min = (u_int)cval.val;
    /* FALLTHROUGH */
    case BTREE_COL_VAR:
        WT_RET(__wt_config_gets(session, cfg, "dictionary", &cval));
        btree->dictionary = (u_int)cval.val;
        break;
    }

    WT_RET(__wt_config_gets_none(session, cfg, "block_compressor", &cval));
    WT_RET(__wt_compressor_config(session, &cval, &btree->compressor));

    /*
     * Configure compression adjustment.
     * When doing compression, assume compression rates that will result in
     * pages larger than the maximum in-memory images allowed. If we're
     * wrong, we adjust downward (but we're almost certainly correct, the
     * maximum in-memory images allowed are only 4x the maximum page size,
     * and compression always gives us more than 4x).
     *	Don't do compression adjustment for fixed-size column store, the
     * leaf page sizes don't change. (We could adjust internal pages but not
     * leaf pages, but that seems an unlikely use case.)
     */
    btree->intlpage_compadjust = false;
    btree->maxintlpage_precomp = btree->btree_private.maxintlpage;
    btree->leafpage_compadjust = false;
    btree->maxleafpage_precomp = btree->btree_private.maxleafpage;
    if (btree->compressor != NULL && btree->compressor->compress != NULL &&
      btree->type != BTREE_COL_FIX) {
        /*
         * Don't do compression adjustment when on-disk page sizes are less than 16KB. There's not
         * enough compression going on to fine-tune the size, all we end up doing is hammering
         * shared memory.
         *
         * Don't do compression adjustment when on-disk page sizes are equal to the maximum
         * in-memory page image, the bytes taken for compression can't grow past the base value.
         */
        if (btree->btree_private.maxintlpage >= 16 * 1024 && btree->btree_private.maxmempage_image > btree->btree_private.maxintlpage) {
            btree->intlpage_compadjust = true;
            btree->maxintlpage_precomp = btree->btree_private.maxmempage_image;
        }
        if (btree->btree_private.maxleafpage >= 16 * 1024 && btree->btree_private.maxmempage_image > btree->btree_private.maxleafpage) {
            btree->leafpage_compadjust = true;
            btree->maxleafpage_precomp = btree->btree_private.maxmempage_image;
        }
    }

    /* Configure encryption. */
    WT_RET(__wt_btree_config_encryptor(session, cfg, &btree->kencryptor));

    /* Configure read-only. */
    WT_RET(__wt_config_gets(session, cfg, "readonly", &cval));
    if (cval.val)
        F_SET(btree, WT_BTREE_READONLY);

    /* Initialize locks. */
    WT_RET(__wt_rwlock_init(session, &btree->ovfl_lock));
    WT_RET(__wt_spin_init(session, &btree->flush_lock, "btree flush"));

    btree->modified = false; /* Clean */

    __wt_atomic_store_enum(&btree->syncing, WT_BTREE_SYNC_OFF);   /* Not syncing */
    btree->checkpoint_gen = __wt_gen(session, WT_GEN_CHECKPOINT); /* Checkpoint generation */

    /*
     * The first time we open a btree, we'll be initializing the write gen to the connection-wide
     * base write generation since this is the largest of all btree write generations from the
     * previous run. This has the nice property of ensuring that the range of write generations used
     * by consecutive runs do not overlap which aids with debugging.
     *
     * If we're reopening a btree or importing a new one to a running system, the btree write
     * generation from the last run may actually be ahead of the connection-wide base write
     * generation. In that case, we should initialize our write gen just ahead of our btree specific
     * write generation.
     *
     * The runtime write generation is important since it's going to determine what we're going to
     * use as the base write generation (and thus what pages to wipe transaction ids from). The idea
     * is that we want to initialize it once the first time we open the btree during a run and then
     * for every subsequent open, we want to reuse it. This so that we're still able to read
     * transaction ids from the previous time a btree was open in the same run.
     */
    btree->write_gen = WT_MAX(ckpt->write_gen + 1, conn->base_write_gen);
    WT_ASSERT(session, ckpt->write_gen >= ckpt->run_write_gen);

    /* If this is the first time opening the tree this run. */
    if (F_ISSET(session, WT_SESSION_IMPORT) || ckpt->run_write_gen < conn->base_write_gen)
        btree->run_write_gen = btree->write_gen;
    else
        btree->run_write_gen = ckpt->run_write_gen;

    /*
     * In recovery use the last checkpointed run write generation number as base write generation
     * number to reset the transaction ids of the pages that were modified before the restart. The
     * transaction ids are retained only on the pages that are written after the restart.
     *
     * Rollback to stable does not operate on logged tables and metadata, so it is skipped.
     *
     * The only scenarios where the checkpoint run write generation number is less than the
     * connection last checkpoint base write generation number are when rollback to stable doesn't
     * happen during the recovery due to the unavailability of history store file, or when reading a
     * checkpoint.
     */
    if ((!F_ISSET(conn, WT_CONN_RECOVERING) || F_ISSET(btree, WT_BTREE_LOGGED) ||
          ckpt->run_write_gen < conn->last_ckpt_base_write_gen) &&
      !is_ckpt)
        btree->base_write_gen = btree->run_write_gen;
    else
        btree->base_write_gen = ckpt->run_write_gen;

    /*
     * We've just overwritten the runtime write generation based off the fact that know that we're
     * importing and therefore, the checkpoint data's runtime write generation is meaningless. We
     * need to ensure that the underlying dhandle doesn't get discarded without being included in a
     * subsequent checkpoint including the new overwritten runtime write generation. Otherwise,
     * we'll reopen, won't know that we're in the import case and will incorrectly use the old
     * system's runtime write generation.
     */
    if (F_ISSET(session, WT_SESSION_IMPORT))
        btree->modified = true;

    return (0);
}⌇
〉,
          kind=StatementKind(is_comment=True,
                             is_preproc=None,
                             is_typedef=None,
                             is_record=None,
                             is_function=True,
                             is_function_def=True,
                             is_function_decl=True,
                             is_statement=None,
                             is_decl=True,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=Token(idx=98,
                                              range=(10028, 10092),
                                              value='/*\n'
                                                    ' * __btree_conf --\n'
                                                    ' *     Configure a WT_BTREE structure.\n'
                                                    ' */'),
                             postComment=None))
Function:
FunctionParts(typename=[10100:10103] 〈int〉,
              name=Token(idx=104, range=(10104, 10116), value='__btree_conf'),
              args=Token(idx=105, range=(10117, 10170), value='WT_SESSION_IMPL *session, WT_CKPT *ckpt, bool is_ckpt'),
              body=Token(idx=107,
                         range=(10173, 22932),
                         value='\n'
                               '    WT_BTREE *btree;\n'
                               '    WT_CONFIG_ITEM cval, metadata;\n'
                               '    WT_CONNECTION_IMPL *conn;\n'
                               '    WT_DECL_RET;\n'
                               '    int64_t maj_version, min_version;\n'
                               '    uint32_t bitcnt;\n'
                               '    const char **cfg;\n'
                               '    bool fixed;\n'
                               '\n'
                               '    btree = S2BT(session);\n'
                               '    cfg = btree->dhandle->cfg;\n'
                               '    conn = S2C(session);\n'
                               '\n'
                               '    /* Dump out format information. */\n'
                               '    if (WT_VERBOSE_ISSET(session, WT_VERB_VERSION)) {\n'
                               '        WT_RET(__wt_config_gets(session, cfg, "version.major", &cval));\n'
                               '        maj_version = cval.val;\n'
                               '        WT_RET(__wt_config_gets(session, cfg, "version.minor", &cval));\n'
                               '        min_version = cval.val;\n'
                               '        __wt_verbose(session, WT_VERB_VERSION, "btree version: %" PRId64 ".%" PRId64, '
                               'maj_version,\n'
                               '          min_version);\n'
                               '    }\n'
                               '\n'
                               '    /* Get the file ID. */\n'
                               '    WT_RET(__wt_config_gets(session, cfg, "id", &cval));\n'
                               '    btree->id = (uint32_t)cval.val;\n'
                               '\n'
                               '    /* Validate file types and check the data format plan. */\n'
                               '    WT_RET(__wt_config_gets(session, cfg, "key_format", &cval));\n'
                               '    WT_RET(__wt_struct_confchk(session, &cval));\n'
                               '    if (WT_CONFIG_LIT_MATCH("r", cval))\n'
                               '        btree->type = BTREE_COL_VAR;\n'
                               '    else\n'
                               '        btree->type = BTREE_ROW;\n'
                               '    WT_RET(__wt_strndup(session, cval.str, cval.len, &btree->key_format));\n'
                               '\n'
                               '    WT_RET(__wt_config_gets(session, cfg, "value_format", &cval));\n'
                               '    WT_RET(__wt_struct_confchk(session, &cval));\n'
                               '    WT_RET(__wt_strndup(session, cval.str, cval.len, &btree->value_format));\n'
                               '\n'
                               '    /* Row-store key comparison. */\n'
                               '    if (btree->type == BTREE_ROW) {\n'
                               '        WT_RET(__wt_config_gets_none(session, cfg, "collator", &cval));\n'
                               '        if (cval.len != 0) {\n'
                               '            WT_RET(__wt_config_gets(session, cfg, "app_metadata", &metadata));\n'
                               '            WT_RET(__wt_collator_config(session, btree->dhandle->name, &cval, '
                               '&metadata,\n'
                               '              &btree->collator, &btree->collator_owned));\n'
                               '        }\n'
                               '    }\n'
                               '\n'
                               '    /* Column-store: check for fixed-size data. */\n'
                               '    if (btree->type == BTREE_COL_VAR) {\n'
                               '        WT_RET(__wt_struct_check(session, cval.str, cval.len, &fixed, &bitcnt));\n'
                               '        if (fixed) {\n'
                               '            if (bitcnt == 0 || bitcnt > 8)\n'
                               '                WT_RET_MSG(session, EINVAL,\n'
                               '                  "fixed-width field sizes must be greater than 0 and less than or '
                               'equal to 8");\n'
                               '            btree->bitcnt = (uint8_t)bitcnt;\n'
                               '            btree->type = BTREE_COL_FIX;\n'
                               '        }\n'
                               '    }\n'
                               '\n'
                               '    /* Page sizes */\n'
                               '    WT_RET(__btree_page_sizes(session));\n'
                               '\n'
                               '    WT_RET(__wt_config_gets(session, cfg, "cache_resident", &cval));\n'
                               '    if (cval.val)\n'
                               '        F_SET(btree, WT_BTREE_IN_MEMORY);\n'
                               '    else\n'
                               '        F_CLR(btree, WT_BTREE_IN_MEMORY);\n'
                               '\n'
                               '    WT_RET(__wt_config_gets(session, cfg, "ignore_in_memory_cache_size", &cval));\n'
                               '    if (cval.val) {\n'
                               '        if (!F_ISSET(conn, WT_CONN_IN_MEMORY))\n'
                               '            WT_RET_MSG(session, EINVAL,\n'
                               '              "ignore_in_memory_cache_size setting is only valid with databases '
                               'configured to run "\n'
                               '              "in-memory");\n'
                               '        F_SET(btree, WT_BTREE_IGNORE_CACHE);\n'
                               '    } else\n'
                               '        F_CLR(btree, WT_BTREE_IGNORE_CACHE);\n'
                               '\n'
                               '    /*\n'
                               "     * Turn on logging when it's enabled in the database and not disabled for the "
                               'tree. Timestamp\n'
                               '     * behavior is described by the logging configurations for historical reasons; '
                               'logged objects\n'
                               '     * imply commit-level durability and ignored timestamps, not-logged objects imply '
                               'checkpoint-\n'
                               '     * level durability and supported timestamps. In-memory configurations default to '
                               'ignoring all\n'
                               '     * timestamps, and the application uses the logging configuration flag to turn on '
                               'timestamps.\n'
                               '     */\n'
                               '    if (FLD_ISSET(conn->log_flags, WT_CONN_LOG_ENABLED)) {\n'
                               '        WT_RET(__wt_config_gets(session, cfg, "log.enabled", &cval));\n'
                               '        if (cval.val)\n'
                               '            F_SET(btree, WT_BTREE_LOGGED);\n'
                               '    }\n'
                               '    if (F_ISSET(conn, WT_CONN_IN_MEMORY)) {\n'
                               '        F_SET(btree, WT_BTREE_LOGGED);\n'
                               '        WT_RET(__wt_config_gets(session, cfg, "log.enabled", &cval));\n'
                               '        if (!cval.val)\n'
                               '            F_CLR(btree, WT_BTREE_LOGGED);\n'
                               '    }\n'
                               '\n'
                               '    /*\n'
                               '     * The metadata isn\'t blocked by in-memory cache limits because metadata "unroll" '
                               'is performed\n'
                               '     * by updates that are potentially blocked by the cache-full checks.\n'
                               '     *\n'
                               '     * The metadata file ignores timestamps and is logged if at all possible.\n'
                               '     */\n'
                               '    if (WT_IS_METADATA(btree->dhandle)) {\n'
                               '        F_SET(btree, WT_BTREE_IGNORE_CACHE);\n'
                               '        F_SET(btree, WT_BTREE_LOGGED);\n'
                               '    }\n'
                               '\n'
                               '    /* The history store file is never logged and supports timestamps. */\n'
                               '    if (strcmp(session->dhandle->name, WT_HS_URI) == 0) {\n'
                               '        F_SET(btree->dhandle, WT_DHANDLE_HS);\n'
                               '        F_CLR(btree, WT_BTREE_LOGGED);\n'
                               '    }\n'
                               '\n'
                               '    WT_RET(__wt_config_gets(session, cfg, "tiered_object", &cval));\n'
                               '    if (cval.val)\n'
                               '        F_SET(btree, WT_BTREE_NO_CHECKPOINT);\n'
                               '    else\n'
                               '        F_CLR(btree, WT_BTREE_NO_CHECKPOINT);\n'
                               '\n'
                               '    /* Get the last flush times for tiered storage, if applicable. */\n'
                               '    btree->flush_most_recent_secs = 0;\n'
                               '    ret = __wt_config_gets(session, cfg, "flush_time", &cval);\n'
                               '    WT_RET_NOTFOUND_OK(ret);\n'
                               '    if (ret == 0)\n'
                               '        btree->flush_most_recent_secs = (uint64_t)cval.val;\n'
                               '\n'
                               '    btree->flush_most_recent_ts = 0;\n'
                               '    ret = __wt_config_gets(session, cfg, "flush_timestamp", &cval);\n'
                               '    WT_RET_NOTFOUND_OK(ret);\n'
                               '    if (ret == 0 && cval.len != 0)\n'
                               '        WT_RET(__wt_txn_parse_timestamp_raw(\n'
                               '          session, "flush_timestamp", &btree->flush_most_recent_ts, &cval));\n'
                               '\n'
                               '    /* Checksums */\n'
                               '    WT_RET(__wt_config_gets(session, cfg, "checksum", &cval));\n'
                               '    if (WT_CONFIG_LIT_MATCH("on", cval))\n'
                               '        btree->checksum = CKSUM_ON;\n'
                               '    else if (WT_CONFIG_LIT_MATCH("off", cval))\n'
                               '        btree->checksum = CKSUM_OFF;\n'
                               '    else if (WT_CONFIG_LIT_MATCH("uncompressed", cval))\n'
                               '        btree->checksum = CKSUM_UNCOMPRESSED;\n'
                               '    else\n'
                               '        btree->checksum = CKSUM_UNENCRYPTED;\n'
                               '\n'
                               '    ret = __wt_config_gets(session, cfg, "huffman_value", &cval);\n'
                               '    if (ret == 0 && cval.len != 0)\n'
                               '        WT_RET_MSG(session, ENOTSUP, "Huffman encoding for values is no longer '
                               'supported.");\n'
                               '\n'
                               '    /*\n'
                               '     * Reconciliation configuration:\n'
                               '     *\tBlock compression (all)\n'
                               '     *\tDictionary compression (variable-length column-store, row-store)\n'
                               '     *\tPage-split percentage\n'
                               '     *\tPrefix compression (row-store)\n'
                               '     *\tSuffix compression (row-store)\n'
                               '     */\n'
                               '    switch (btree->type) {\n'
                               '    case BTREE_COL_FIX:\n'
                               '        break;\n'
                               '    case BTREE_ROW:\n'
                               '        WT_RET(__wt_config_gets(session, cfg, "internal_key_truncate", &cval));\n'
                               '        btree->internal_key_truncate = cval.val != 0;\n'
                               '\n'
                               '        WT_RET(__wt_config_gets(session, cfg, "prefix_compression", &cval));\n'
                               '        btree->prefix_compression = cval.val != 0;\n'
                               '        WT_RET(__wt_config_gets(session, cfg, "prefix_compression_min", &cval));\n'
                               '        btree->prefix_compression_min = (u_int)cval.val;\n'
                               '    /* FALLTHROUGH */\n'
                               '    case BTREE_COL_VAR:\n'
                               '        WT_RET(__wt_config_gets(session, cfg, "dictionary", &cval));\n'
                               '        btree->dictionary = (u_int)cval.val;\n'
                               '        break;\n'
                               '    }\n'
                               '\n'
                               '    WT_RET(__wt_config_gets_none(session, cfg, "block_compressor", &cval));\n'
                               '    WT_RET(__wt_compressor_config(session, &cval, &btree->compressor));\n'
                               '\n'
                               '    /*\n'
                               '     * Configure compression adjustment.\n'
                               '     * When doing compression, assume compression rates that will result in\n'
                               "     * pages larger than the maximum in-memory images allowed. If we're\n"
                               "     * wrong, we adjust downward (but we're almost certainly correct, the\n"
                               '     * maximum in-memory images allowed are only 4x the maximum page size,\n'
                               '     * and compression always gives us more than 4x).\n'
                               "     *\tDon't do compression adjustment for fixed-size column store, the\n"
                               "     * leaf page sizes don't change. (We could adjust internal pages but not\n"
                               '     * leaf pages, but that seems an unlikely use case.)\n'
                               '     */\n'
                               '    btree->intlpage_compadjust = false;\n'
                               '    btree->maxintlpage_precomp = btree->btree_private.maxintlpage;\n'
                               '    btree->leafpage_compadjust = false;\n'
                               '    btree->maxleafpage_precomp = btree->btree_private.maxleafpage;\n'
                               '    if (btree->compressor != NULL && btree->compressor->compress != NULL &&\n'
                               '      btree->type != BTREE_COL_FIX) {\n'
                               '        /*\n'
                               "         * Don't do compression adjustment when on-disk page sizes are less than 16KB. "
                               "There's not\n"
                               '         * enough compression going on to fine-tune the size, all we end up doing is '
                               'hammering\n'
                               '         * shared memory.\n'
                               '         *\n'
                               "         * Don't do compression adjustment when on-disk page sizes are equal to the "
                               'maximum\n'
                               "         * in-memory page image, the bytes taken for compression can't grow past the "
                               'base value.\n'
                               '         */\n'
                               '        if (btree->btree_private.maxintlpage >= 16 * 1024 && '
                               'btree->btree_private.maxmempage_image > btree->btree_private.maxintlpage) {\n'
                               '            btree->intlpage_compadjust = true;\n'
                               '            btree->maxintlpage_precomp = btree->btree_private.maxmempage_image;\n'
                               '        }\n'
                               '        if (btree->btree_private.maxleafpage >= 16 * 1024 && '
                               'btree->btree_private.maxmempage_image > btree->btree_private.maxleafpage) {\n'
                               '            btree->leafpage_compadjust = true;\n'
                               '            btree->maxleafpage_precomp = btree->btree_private.maxmempage_image;\n'
                               '        }\n'
                               '    }\n'
                               '\n'
                               '    /* Configure encryption. */\n'
                               '    WT_RET(__wt_btree_config_encryptor(session, cfg, &btree->kencryptor));\n'
                               '\n'
                               '    /* Configure read-only. */\n'
                               '    WT_RET(__wt_config_gets(session, cfg, "readonly", &cval));\n'
                               '    if (cval.val)\n'
                               '        F_SET(btree, WT_BTREE_READONLY);\n'
                               '\n'
                               '    /* Initialize locks. */\n'
                               '    WT_RET(__wt_rwlock_init(session, &btree->ovfl_lock));\n'
                               '    WT_RET(__wt_spin_init(session, &btree->flush_lock, "btree flush"));\n'
                               '\n'
                               '    btree->modified = false; /* Clean */\n'
                               '\n'
                               '    __wt_atomic_store_enum(&btree->syncing, WT_BTREE_SYNC_OFF);   /* Not syncing */\n'
                               '    btree->checkpoint_gen = __wt_gen(session, WT_GEN_CHECKPOINT); /* Checkpoint '
                               'generation */\n'
                               '\n'
                               '    /*\n'
                               "     * The first time we open a btree, we'll be initializing the write gen to the "
                               'connection-wide\n'
                               '     * base write generation since this is the largest of all btree write generations '
                               'from the\n'
                               '     * previous run. This has the nice property of ensuring that the range of write '
                               'generations used\n'
                               '     * by consecutive runs do not overlap which aids with debugging.\n'
                               '     *\n'
                               "     * If we're reopening a btree or importing a new one to a running system, the "
                               'btree write\n'
                               '     * generation from the last run may actually be ahead of the connection-wide base '
                               'write\n'
                               '     * generation. In that case, we should initialize our write gen just ahead of our '
                               'btree specific\n'
                               '     * write generation.\n'
                               '     *\n'
                               "     * The runtime write generation is important since it's going to determine what "
                               "we're going to\n"
                               '     * use as the base write generation (and thus what pages to wipe transaction ids '
                               'from). The idea\n'
                               '     * is that we want to initialize it once the first time we open the btree during a '
                               'run and then\n'
                               "     * for every subsequent open, we want to reuse it. This so that we're still able "
                               'to read\n'
                               '     * transaction ids from the previous time a btree was open in the same run.\n'
                               '     */\n'
                               '    btree->write_gen = WT_MAX(ckpt->write_gen + 1, conn->base_write_gen);\n'
                               '    WT_ASSERT(session, ckpt->write_gen >= ckpt->run_write_gen);\n'
                               '\n'
                               '    /* If this is the first time opening the tree this run. */\n'
                               '    if (F_ISSET(session, WT_SESSION_IMPORT) || ckpt->run_write_gen < '
                               'conn->base_write_gen)\n'
                               '        btree->run_write_gen = btree->write_gen;\n'
                               '    else\n'
                               '        btree->run_write_gen = ckpt->run_write_gen;\n'
                               '\n'
                               '    /*\n'
                               '     * In recovery use the last checkpointed run write generation number as base write '
                               'generation\n'
                               '     * number to reset the transaction ids of the pages that were modified before the '
                               'restart. The\n'
                               '     * transaction ids are retained only on the pages that are written after the '
                               'restart.\n'
                               '     *\n'
                               '     * Rollback to stable does not operate on logged tables and metadata, so it is '
                               'skipped.\n'
                               '     *\n'
                               '     * The only scenarios where the checkpoint run write generation number is less '
                               'than the\n'
                               '     * connection last checkpoint base write generation number are when rollback to '
                               "stable doesn't\n"
                               '     * happen during the recovery due to the unavailability of history store file, or '
                               'when reading a\n'
                               '     * checkpoint.\n'
                               '     */\n'
                               '    if ((!F_ISSET(conn, WT_CONN_RECOVERING) || F_ISSET(btree, WT_BTREE_LOGGED) ||\n'
                               '          ckpt->run_write_gen < conn->last_ckpt_base_write_gen) &&\n'
                               '      !is_ckpt)\n'
                               '        btree->base_write_gen = btree->run_write_gen;\n'
                               '    else\n'
                               '        btree->base_write_gen = ckpt->run_write_gen;\n'
                               '\n'
                               '    /*\n'
                               "     * We've just overwritten the runtime write generation based off the fact that "
                               "know that we're\n"
                               "     * importing and therefore, the checkpoint data's runtime write generation is "
                               'meaningless. We\n'
                               "     * need to ensure that the underlying dhandle doesn't get discarded without being "
                               'included in a\n'
                               '     * subsequent checkpoint including the new overwritten runtime write generation. '
                               'Otherwise,\n'
                               "     * we'll reopen, won't know that we're in the import case and will incorrectly use "
                               'the old\n'
                               "     * system's runtime write generation.\n"
                               '     */\n'
                               '    if (F_ISSET(session, WT_SESSION_IMPORT))\n'
                               '        btree->modified = true;\n'
                               '\n'
                               '    return (0);\n'),
              preComment=Token(idx=98,
                               range=(10028, 10092),
                               value='/*\n * __btree_conf --\n *     Configure a WT_BTREE structure.\n */'),
              postComment=None,
              is_type_const=False,
              is_type_static=True)
Args:
[Variable(name=Token(idx=3, range=(10134, 10141), value='session'),
          typename=[10117:10132] 〈WT_SESSION_IMPL〉,
          preComment=None,
          postComment=None,
          end=','),
 Variable(name=Token(idx=9, range=(10152, 10156), value='ckpt'),
          typename=[10143:10150] 〈WT_CKPT〉,
          preComment=None,
          postComment=None,
          end=','),
 Variable(name=Token(idx=14, range=(10163, 10170), value='is_ckpt'),
          typename=[10158:10162] 〈bool〉,
          preComment=None,
          postComment=None,
          end=None)]
Vars:
[Variable(name=Token(idx=5, range=(10188, 10193), value='btree'),
          typename=[10178:10186] 〈WT_BTREE〉,
          preComment=None,
          postComment=None,
          end=';'),
 Variable(name=Token(idx=11, range=(10214, 10218), value='cval'),
          typename=[10199:10213] 〈WT_CONFIG_ITEM〉,
          preComment=None,
          postComment=None,
          end=','),
 Variable(name=Token(idx=14, range=(10220, 10228), value='metadata'),
          typename=[10199:10213] 〈WT_CONFIG_ITEM〉,
          preComment=None,
          postComment=None,
          end=';'),
 Variable(name=Token(idx=21, range=(10254, 10258), value='conn'),
          typename=[10234:10252] 〈WT_CONNECTION_IMPL〉,
          preComment=None,
          postComment=None,
          end=';')]
Statement(tokens=[22934:23462] 〈
⌇/*
 * __wt_root_ref_init --
 *     Initialize a tree root reference, and link in the root page.
 */⌇
⌇void⌇
⌇__wt_root_ref_init⌇(WT_SESSION_IMPL *session, WT_REF *root_ref, WT_PAGE *root, bool is_recno)⌇
⌇{
    WT_UNUSED(session); /* Used in a macro for diagnostic builds */
    memset(root_ref, 0, sizeof(*root_ref));

    root_ref->page = root;
    F_SET(root_ref, WT_REF_FLAG_INTERNAL);
    WT_REF_SET_STATE(root_ref, WT_REF_MEM);

    root_ref->ref_recno = is_recno ? 1 : WT_RECNO_OOB;

    root->pg_intl_parent_ref = root_ref;
}⌇
〉,
          kind=StatementKind(is_comment=True,
                             is_preproc=None,
                             is_typedef=None,
                             is_record=None,
                             is_function=True,
                             is_function_def=True,
                             is_function_decl=True,
                             is_statement=None,
                             is_decl=True,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=Token(idx=110,
                                              range=(22935, 23034),
                                              value='/*\n'
                                                    ' * __wt_root_ref_init --\n'
                                                    ' *     Initialize a tree root reference, and link in the root '
                                                    'page.\n'
                                                    ' */'),
                             postComment=None))
Function:
FunctionParts(typename=[23035:23039] 〈void〉,
              name=Token(idx=114, range=(23040, 23058), value='__wt_root_ref_init'),
              args=Token(idx=115,
                         range=(23059, 23131),
                         value='WT_SESSION_IMPL *session, WT_REF *root_ref, WT_PAGE *root, bool is_recno'),
              body=Token(idx=117,
                         range=(23134, 23460),
                         value='\n'
                               '    WT_UNUSED(session); /* Used in a macro for diagnostic builds */\n'
                               '    memset(root_ref, 0, sizeof(*root_ref));\n'
                               '\n'
                               '    root_ref->page = root;\n'
                               '    F_SET(root_ref, WT_REF_FLAG_INTERNAL);\n'
                               '    WT_REF_SET_STATE(root_ref, WT_REF_MEM);\n'
                               '\n'
                               '    root_ref->ref_recno = is_recno ? 1 : WT_RECNO_OOB;\n'
                               '\n'
                               '    root->pg_intl_parent_ref = root_ref;\n'),
              preComment=Token(idx=110,
                               range=(22935, 23034),
                               value='/*\n'
                                     ' * __wt_root_ref_init --\n'
                                     ' *     Initialize a tree root reference, and link in the root page.\n'
                                     ' */'),
              postComment=None,
              is_type_const=False,
              is_type_static=False)
Args:
[Variable(name=Token(idx=3, range=(23076, 23083), value='session'),
          typename=[23059:23074] 〈WT_SESSION_IMPL〉,
          preComment=None,
          postComment=None,
          end=','),
 Variable(name=Token(idx=9, range=(23093, 23101), value='root_ref'),
          typename=[23085:23091] 〈WT_REF〉,
          preComment=None,
          postComment=None,
          end=','),
 Variable(name=Token(idx=15, range=(23112, 23116), value='root'),
          typename=[23103:23110] 〈WT_PAGE〉,
          preComment=None,
          postComment=None,
          end=','),
 Variable(name=Token(idx=20, range=(23123, 23131), value='is_recno'),
          typename=[23118:23122] 〈bool〉,
          preComment=None,
          postComment=None,
          end=None)]
Vars:
[]
Statement(tokens=[23462:26098] 〈
⌇/*
 * __wti_btree_tree_open --
 *     Read in a tree from disk.
 */⌇
⌇int⌇
⌇__wti_btree_tree_open⌇(WT_SESSION_IMPL *session, const uint8_t *addr, size_t addr_size)⌇
⌇{
    WT_BM *bm;
    WT_BTREE *btree;
    WT_DECL_ITEM(tmp);
    WT_DECL_RET;
    WT_ITEM dsk;
    WT_PAGE *page;

    btree = S2BT(session);
    bm = btree->bm;

    /*
     * A buffer into which we read a root page; don't use a scratch buffer, the buffer's allocated
     * memory becomes the persistent in-memory page.
     */
    WT_CLEAR(dsk);

    /*
     * Read and verify the page (verify to catch encrypted objects we can't decrypt, where we read
     * the object successfully but we can't decrypt it, and we want to fail gracefully).
     *
     * Create a printable version of the address to pass to verify.
     */
    WT_ERR(__wt_scr_alloc(session, 0, &tmp));
    WT_ERR(bm->addr_string(bm, session, tmp, addr, addr_size));

    F_SET(session, WT_SESSION_QUIET_CORRUPT_FILE);
    if ((ret = __wt_blkcache_read(session, &dsk, addr, addr_size)) == 0)
        ret = __wt_verify_dsk(session, tmp->data, &dsk);
    /*
     * Flag any failed read or verification: if we're in startup, it may be fatal.
     */
    if (ret != 0)
        F_SET(S2C(session), WT_CONN_DATA_CORRUPTION);
    F_CLR(session, WT_SESSION_QUIET_CORRUPT_FILE);
    if (ret != 0)
        __wt_err(session, ret, "unable to read root page from %s", session->dhandle->name);
    /*
     * Failure to open metadata means that the database is unavailable. Try to provide a helpful
     * failure message.
     */
    if (ret != 0 && WT_IS_METADATA(session->dhandle)) {
        __wt_err(session, ret, "WiredTiger has failed to open its metadata");
        __wt_err(session, ret,
          "This may be due to the database files being encrypted, being from an older version or "
          "due to corruption on disk");
        __wt_err(session, ret,
          "You should confirm that you have opened the database with the correct options including "
          "all encryption and compression options");
    }
    WT_ERR(ret);

    /*
     * Build the in-memory version of the page. Clear our local reference to the allocated copy of
     * the disk image on return, the in-memory object steals it.
     */
    WT_ERR(__wti_page_inmem(session, NULL, dsk.data,
      WT_DATA_IN_ITEM(&dsk) ? WT_PAGE_DISK_ALLOC : WT_PAGE_DISK_MAPPED, &page, NULL));
    dsk.mem = NULL;

    /* Finish initializing the root, root reference links. */
    __wt_root_ref_init(session, &btree->root, page, btree->type != BTREE_ROW);

err:
    __wt_buf_free(session, &dsk);
    __wt_scr_free(session, &tmp);

    return (ret);
}⌇
〉,
          kind=StatementKind(is_comment=True,
                             is_preproc=None,
                             is_typedef=None,
                             is_record=None,
                             is_function=True,
                             is_function_def=True,
                             is_function_decl=True,
                             is_statement=None,
                             is_decl=True,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=Token(idx=120,
                                              range=(23463, 23530),
                                              value='/*\n'
                                                    ' * __wti_btree_tree_open --\n'
                                                    ' *     Read in a tree from disk.\n'
                                                    ' */'),
                             postComment=None))
Function:
FunctionParts(typename=[23531:23534] 〈int〉,
              name=Token(idx=124, range=(23535, 23556), value='__wti_btree_tree_open'),
              args=Token(idx=125,
                         range=(23557, 23620),
                         value='WT_SESSION_IMPL *session, const uint8_t *addr, size_t addr_size'),
              body=Token(idx=127,
                         range=(23623, 26096),
                         value='\n'
                               '    WT_BM *bm;\n'
                               '    WT_BTREE *btree;\n'
                               '    WT_DECL_ITEM(tmp);\n'
                               '    WT_DECL_RET;\n'
                               '    WT_ITEM dsk;\n'
                               '    WT_PAGE *page;\n'
                               '\n'
                               '    btree = S2BT(session);\n'
                               '    bm = btree->bm;\n'
                               '\n'
                               '    /*\n'
                               "     * A buffer into which we read a root page; don't use a scratch buffer, the "
                               "buffer's allocated\n"
                               '     * memory becomes the persistent in-memory page.\n'
                               '     */\n'
                               '    WT_CLEAR(dsk);\n'
                               '\n'
                               '    /*\n'
                               "     * Read and verify the page (verify to catch encrypted objects we can't decrypt, "
                               'where we read\n'
                               "     * the object successfully but we can't decrypt it, and we want to fail "
                               'gracefully).\n'
                               '     *\n'
                               '     * Create a printable version of the address to pass to verify.\n'
                               '     */\n'
                               '    WT_ERR(__wt_scr_alloc(session, 0, &tmp));\n'
                               '    WT_ERR(bm->addr_string(bm, session, tmp, addr, addr_size));\n'
                               '\n'
                               '    F_SET(session, WT_SESSION_QUIET_CORRUPT_FILE);\n'
                               '    if ((ret = __wt_blkcache_read(session, &dsk, addr, addr_size)) == 0)\n'
                               '        ret = __wt_verify_dsk(session, tmp->data, &dsk);\n'
                               '    /*\n'
                               "     * Flag any failed read or verification: if we're in startup, it may be fatal.\n"
                               '     */\n'
                               '    if (ret != 0)\n'
                               '        F_SET(S2C(session), WT_CONN_DATA_CORRUPTION);\n'
                               '    F_CLR(session, WT_SESSION_QUIET_CORRUPT_FILE);\n'
                               '    if (ret != 0)\n'
                               '        __wt_err(session, ret, "unable to read root page from %s", '
                               'session->dhandle->name);\n'
                               '    /*\n'
                               '     * Failure to open metadata means that the database is unavailable. Try to provide '
                               'a helpful\n'
                               '     * failure message.\n'
                               '     */\n'
                               '    if (ret != 0 && WT_IS_METADATA(session->dhandle)) {\n'
                               '        __wt_err(session, ret, "WiredTiger has failed to open its metadata");\n'
                               '        __wt_err(session, ret,\n'
                               '          "This may be due to the database files being encrypted, being from an older '
                               'version or "\n'
                               '          "due to corruption on disk");\n'
                               '        __wt_err(session, ret,\n'
                               '          "You should confirm that you have opened the database with the correct '
                               'options including "\n'
                               '          "all encryption and compression options");\n'
                               '    }\n'
                               '    WT_ERR(ret);\n'
                               '\n'
                               '    /*\n'
                               '     * Build the in-memory version of the page. Clear our local reference to the '
                               'allocated copy of\n'
                               '     * the disk image on return, the in-memory object steals it.\n'
                               '     */\n'
                               '    WT_ERR(__wti_page_inmem(session, NULL, dsk.data,\n'
                               '      WT_DATA_IN_ITEM(&dsk) ? WT_PAGE_DISK_ALLOC : WT_PAGE_DISK_MAPPED, &page, '
                               'NULL));\n'
                               '    dsk.mem = NULL;\n'
                               '\n'
                               '    /* Finish initializing the root, root reference links. */\n'
                               '    __wt_root_ref_init(session, &btree->root, page, btree->type != BTREE_ROW);\n'
                               '\n'
                               'err:\n'
                               '    __wt_buf_free(session, &dsk);\n'
                               '    __wt_scr_free(session, &tmp);\n'
                               '\n'
                               '    return (ret);\n'),
              preComment=Token(idx=120,
                               range=(23463, 23530),
                               value='/*\n * __wti_btree_tree_open --\n *     Read in a tree from disk.\n */'),
              postComment=None,
              is_type_const=False,
              is_type_static=False)
Args:
[Variable(name=Token(idx=3, range=(23574, 23581), value='session'),
          typename=[23557:23572] 〈WT_SESSION_IMPL〉,
          preComment=None,
          postComment=None,
          end=','),
 Variable(name=Token(idx=11, range=(23598, 23602), value='addr'),
          typename=[23589:23596] 〈uint8_t〉,
          preComment=None,
          postComment=None,
          end=','),
 Variable(name=Token(idx=16, range=(23611, 23620), value='addr_size'),
          typename=[23604:23610] 〈size_t〉,
          preComment=None,
          postComment=None,
          end=None)]
Vars:
[Variable(name=Token(idx=5, range=(23635, 23637), value='bm'),
          typename=[23628:23633] 〈WT_BM〉,
          preComment=None,
          postComment=None,
          end=';'),
 Variable(name=Token(idx=12, range=(23653, 23658), value='btree'),
          typename=[23643:23651] 〈WT_BTREE〉,
          preComment=None,
          postComment=None,
          end=';')]
Statement(tokens=[26098:28782] 〈
⌇/*
 * __btree_tree_open_empty --
 *     Create an empty in-memory tree.
 */⌇
⌇static⌇ ⌇int⌇
⌇__btree_tree_open_empty⌇(WT_SESSION_IMPL *session, bool creation)⌇
⌇{
    WT_BTREE *btree;
    WT_DECL_RET;
    WT_PAGE *root;
    WT_PAGE_INDEX *pindex;
    WT_REF *ref;

    btree = S2BT(session);
    root = NULL;
    ref = NULL;

    /*
     * Newly created objects can be used for cursor inserts or for bulk loads; set a flag that's
     * cleared when a row is inserted into the tree.
     */
    if (creation)
        btree->original = 1;

    /*
     * A note about empty trees: the initial tree is a single root page. It has a single reference
     * to a leaf page, marked deleted. The leaf page will be created by the first update. If the
     * root is evicted without being modified, that's OK, nothing is ever written.
     *
     * !!!
     * Be cautious about changing the order of updates in this code: to call __wt_page_out on error,
     * we require a correct page setup at each point where we might fail.
     */
    switch (btree->type) {
    case BTREE_COL_FIX:
    case BTREE_COL_VAR:
        WT_ERR(__wt_page_alloc(session, WT_PAGE_COL_INT, 1, true, &root));
        root->pg_intl_parent_ref = &btree->root;

        WT_INTL_INDEX_GET_SAFE(root, pindex);
        ref = pindex->index[0];
        ref->home = root;
        ref->page = NULL;
        ref->addr = NULL;
        F_SET(ref, WT_REF_FLAG_LEAF);
        WT_REF_SET_STATE(ref, WT_REF_DELETED);
        ref->ref_recno = 1;
        break;
    case BTREE_ROW:
        WT_ERR(__wt_page_alloc(session, WT_PAGE_ROW_INT, 1, true, &root));
        root->pg_intl_parent_ref = &btree->root;

        WT_INTL_INDEX_GET_SAFE(root, pindex);
        ref = pindex->index[0];
        ref->home = root;
        ref->page = NULL;
        ref->addr = NULL;
        F_SET(ref, WT_REF_FLAG_LEAF);
        WT_REF_SET_STATE(ref, WT_REF_DELETED);
        WT_ERR(__wti_row_ikey_incr(session, root, 0, "", 1, ref));
        break;
    }

    /* Bulk loads require a leaf page for reconciliation: create it now. */
    if (F_ISSET(btree, WT_BTREE_BULK)) {
        WT_ERR(__wti_btree_new_leaf_page(session, ref));
        F_SET(ref, WT_REF_FLAG_LEAF);
        WT_REF_SET_STATE(ref, WT_REF_MEM);
        WT_ERR(__wt_page_modify_init(session, ref->page));
        __wt_page_only_modify_set(session, ref->page);
    }

    /* Finish initializing the root, root reference links. */
    __wt_root_ref_init(session, &btree->root, root, btree->type != BTREE_ROW);

    return (0);

err:
    if (ref != NULL && ref->page != NULL)
        __wt_page_out(session, &ref->page);
    if (root != NULL)
        __wt_page_out(session, &root);
    return (ret);
}⌇
〉,
          kind=StatementKind(is_comment=True,
                             is_preproc=None,
                             is_typedef=None,
                             is_record=None,
                             is_function=True,
                             is_function_def=True,
                             is_function_decl=True,
                             is_statement=None,
                             is_decl=True,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=Token(idx=130,
                                              range=(26099, 26174),
                                              value='/*\n'
                                                    ' * __btree_tree_open_empty --\n'
                                                    ' *     Create an empty in-memory tree.\n'
                                                    ' */'),
                             postComment=None))
Function:
FunctionParts(typename=[26182:26185] 〈int〉,
              name=Token(idx=136, range=(26186, 26209), value='__btree_tree_open_empty'),
              args=Token(idx=137, range=(26210, 26249), value='WT_SESSION_IMPL *session, bool creation'),
              body=Token(idx=139,
                         range=(26252, 28780),
                         value='\n'
                               '    WT_BTREE *btree;\n'
                               '    WT_DECL_RET;\n'
                               '    WT_PAGE *root;\n'
                               '    WT_PAGE_INDEX *pindex;\n'
                               '    WT_REF *ref;\n'
                               '\n'
                               '    btree = S2BT(session);\n'
                               '    root = NULL;\n'
                               '    ref = NULL;\n'
                               '\n'
                               '    /*\n'
                               '     * Newly created objects can be used for cursor inserts or for bulk loads; set a '
                               "flag that's\n"
                               '     * cleared when a row is inserted into the tree.\n'
                               '     */\n'
                               '    if (creation)\n'
                               '        btree->original = 1;\n'
                               '\n'
                               '    /*\n'
                               '     * A note about empty trees: the initial tree is a single root page. It has a '
                               'single reference\n'
                               '     * to a leaf page, marked deleted. The leaf page will be created by the first '
                               'update. If the\n'
                               "     * root is evicted without being modified, that's OK, nothing is ever written.\n"
                               '     *\n'
                               '     * !!!\n'
                               '     * Be cautious about changing the order of updates in this code: to call '
                               '__wt_page_out on error,\n'
                               '     * we require a correct page setup at each point where we might fail.\n'
                               '     */\n'
                               '    switch (btree->type) {\n'
                               '    case BTREE_COL_FIX:\n'
                               '    case BTREE_COL_VAR:\n'
                               '        WT_ERR(__wt_page_alloc(session, WT_PAGE_COL_INT, 1, true, &root));\n'
                               '        root->pg_intl_parent_ref = &btree->root;\n'
                               '\n'
                               '        WT_INTL_INDEX_GET_SAFE(root, pindex);\n'
                               '        ref = pindex->index[0];\n'
                               '        ref->home = root;\n'
                               '        ref->page = NULL;\n'
                               '        ref->addr = NULL;\n'
                               '        F_SET(ref, WT_REF_FLAG_LEAF);\n'
                               '        WT_REF_SET_STATE(ref, WT_REF_DELETED);\n'
                               '        ref->ref_recno = 1;\n'
                               '        break;\n'
                               '    case BTREE_ROW:\n'
                               '        WT_ERR(__wt_page_alloc(session, WT_PAGE_ROW_INT, 1, true, &root));\n'
                               '        root->pg_intl_parent_ref = &btree->root;\n'
                               '\n'
                               '        WT_INTL_INDEX_GET_SAFE(root, pindex);\n'
                               '        ref = pindex->index[0];\n'
                               '        ref->home = root;\n'
                               '        ref->page = NULL;\n'
                               '        ref->addr = NULL;\n'
                               '        F_SET(ref, WT_REF_FLAG_LEAF);\n'
                               '        WT_REF_SET_STATE(ref, WT_REF_DELETED);\n'
                               '        WT_ERR(__wti_row_ikey_incr(session, root, 0, "", 1, ref));\n'
                               '        break;\n'
                               '    }\n'
                               '\n'
                               '    /* Bulk loads require a leaf page for reconciliation: create it now. */\n'
                               '    if (F_ISSET(btree, WT_BTREE_BULK)) {\n'
                               '        WT_ERR(__wti_btree_new_leaf_page(session, ref));\n'
                               '        F_SET(ref, WT_REF_FLAG_LEAF);\n'
                               '        WT_REF_SET_STATE(ref, WT_REF_MEM);\n'
                               '        WT_ERR(__wt_page_modify_init(session, ref->page));\n'
                               '        __wt_page_only_modify_set(session, ref->page);\n'
                               '    }\n'
                               '\n'
                               '    /* Finish initializing the root, root reference links. */\n'
                               '    __wt_root_ref_init(session, &btree->root, root, btree->type != BTREE_ROW);\n'
                               '\n'
                               '    return (0);\n'
                               '\n'
                               'err:\n'
                               '    if (ref != NULL && ref->page != NULL)\n'
                               '        __wt_page_out(session, &ref->page);\n'
                               '    if (root != NULL)\n'
                               '        __wt_page_out(session, &root);\n'
                               '    return (ret);\n'),
              preComment=Token(idx=130,
                               range=(26099, 26174),
                               value='/*\n * __btree_tree_open_empty --\n *     Create an empty in-memory tree.\n */'),
              postComment=None,
              is_type_const=False,
              is_type_static=True)
Args:
[Variable(name=Token(idx=3, range=(26227, 26234), value='session'),
          typename=[26210:26225] 〈WT_SESSION_IMPL〉,
          preComment=None,
          postComment=None,
          end=','),
 Variable(name=Token(idx=8, range=(26241, 26249), value='creation'),
          typename=[26236:26240] 〈bool〉,
          preComment=None,
          postComment=None,
          end=None)]
Vars:
[Variable(name=Token(idx=5, range=(26267, 26272), value='btree'),
          typename=[26257:26265] 〈WT_BTREE〉,
          preComment=None,
          postComment=None,
          end=';')]
Statement(tokens=[28782:29734] 〈
⌇/*
 * __wti_btree_new_leaf_page --
 *     Create an empty leaf page.
 */⌇
⌇int⌇
⌇__wti_btree_new_leaf_page⌇(WT_SESSION_IMPL *session, WT_REF *ref)⌇
⌇{
    WT_BTREE *btree;

    btree = S2BT(session);

    switch (btree->type) {
    case BTREE_COL_FIX:
        WT_RET(__wt_page_alloc(session, WT_PAGE_COL_FIX, 0, false, &ref->page));
        break;
    case BTREE_COL_VAR:
        WT_RET(__wt_page_alloc(session, WT_PAGE_COL_VAR, 0, false, &ref->page));
        break;
    case BTREE_ROW:
        WT_RET(__wt_page_alloc(session, WT_PAGE_ROW_LEAF, 0, false, &ref->page));
        break;
    }

    /*
     * When deleting a chunk of the name-space, we can delete internal pages. However, if we are
     * ever forced to re-instantiate that piece of the namespace, it comes back as a leaf page.
     * Reset the WT_REF type as it's possible that it has changed.
     */
    F_CLR(ref, WT_REF_FLAG_INTERNAL);
    F_SET(ref, WT_REF_FLAG_LEAF);

    return (0);
}⌇
〉,
          kind=StatementKind(is_comment=True,
                             is_preproc=None,
                             is_typedef=None,
                             is_record=None,
                             is_function=True,
                             is_function_def=True,
                             is_function_decl=True,
                             is_statement=None,
                             is_decl=True,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=Token(idx=142,
                                              range=(28783, 28855),
                                              value='/*\n'
                                                    ' * __wti_btree_new_leaf_page --\n'
                                                    ' *     Create an empty leaf page.\n'
                                                    ' */'),
                             postComment=None))
Function:
FunctionParts(typename=[28856:28859] 〈int〉,
              name=Token(idx=146, range=(28860, 28885), value='__wti_btree_new_leaf_page'),
              args=Token(idx=147, range=(28886, 28923), value='WT_SESSION_IMPL *session, WT_REF *ref'),
              body=Token(idx=149,
                         range=(28926, 29732),
                         value='\n'
                               '    WT_BTREE *btree;\n'
                               '\n'
                               '    btree = S2BT(session);\n'
                               '\n'
                               '    switch (btree->type) {\n'
                               '    case BTREE_COL_FIX:\n'
                               '        WT_RET(__wt_page_alloc(session, WT_PAGE_COL_FIX, 0, false, &ref->page));\n'
                               '        break;\n'
                               '    case BTREE_COL_VAR:\n'
                               '        WT_RET(__wt_page_alloc(session, WT_PAGE_COL_VAR, 0, false, &ref->page));\n'
                               '        break;\n'
                               '    case BTREE_ROW:\n'
                               '        WT_RET(__wt_page_alloc(session, WT_PAGE_ROW_LEAF, 0, false, &ref->page));\n'
                               '        break;\n'
                               '    }\n'
                               '\n'
                               '    /*\n'
                               '     * When deleting a chunk of the name-space, we can delete internal pages. However, '
                               'if we are\n'
                               '     * ever forced to re-instantiate that piece of the namespace, it comes back as a '
                               'leaf page.\n'
                               "     * Reset the WT_REF type as it's possible that it has changed.\n"
                               '     */\n'
                               '    F_CLR(ref, WT_REF_FLAG_INTERNAL);\n'
                               '    F_SET(ref, WT_REF_FLAG_LEAF);\n'
                               '\n'
                               '    return (0);\n'),
              preComment=Token(idx=142,
                               range=(28783, 28855),
                               value='/*\n * __wti_btree_new_leaf_page --\n *     Create an empty leaf page.\n */'),
              postComment=None,
              is_type_const=False,
              is_type_static=False)
Args:
[Variable(name=Token(idx=3, range=(28903, 28910), value='session'),
          typename=[28886:28901] 〈WT_SESSION_IMPL〉,
          preComment=None,
          postComment=None,
          end=','),
 Variable(name=Token(idx=9, range=(28920, 28923), value='ref'),
          typename=[28912:28918] 〈WT_REF〉,
          preComment=None,
          postComment=None,
          end=None)]
Vars:
[Variable(name=Token(idx=5, range=(28941, 28946), value='btree'),
          typename=[28931:28939] 〈WT_BTREE〉,
          preComment=None,
          postComment=None,
          end=';')]
Statement(tokens=[29734:30509] 〈
⌇/*
 * __btree_preload --
 *     Pre-load internal pages.
 */⌇
⌇static⌇ ⌇int⌇
⌇__btree_preload⌇(WT_SESSION_IMPL *session)⌇
⌇{
    WT_ADDR_COPY addr;
    WT_BTREE *btree;
    WT_DECL_ITEM(tmp);
    WT_DECL_RET;
    WT_REF *ref;
    uint64_t block_preload;

    btree = S2BT(session);
    block_preload = 0;

    WT_RET(__wt_scr_alloc(session, 0, &tmp));

    /* Pre-load the second-level internal pages. */
    WT_INTL_FOREACH_BEGIN (session, btree->root.page, ref)
        if (__wt_ref_addr_copy(session, ref, &addr)) {
            WT_ERR(__wt_blkcache_read(session, tmp, addr.addr, addr.size));
            ++block_preload;
        }
    WT_INTL_FOREACH_END;

err:
    __wt_scr_free(session, &tmp);

    WT_STAT_CONN_INCRV(session, block_preload, block_preload);
    return (ret);
}⌇
〉,
          kind=StatementKind(is_comment=True,
                             is_preproc=None,
                             is_typedef=None,
                             is_record=None,
                             is_function=True,
                             is_function_def=True,
                             is_function_decl=True,
                             is_statement=None,
                             is_decl=True,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=Token(idx=152,
                                              range=(29735, 29795),
                                              value='/*\n * __btree_preload --\n *     Pre-load internal pages.\n */'),
                             postComment=None))
Function:
FunctionParts(typename=[29803:29806] 〈int〉,
              name=Token(idx=158, range=(29807, 29822), value='__btree_preload'),
              args=Token(idx=159, range=(29823, 29847), value='WT_SESSION_IMPL *session'),
              body=Token(idx=161,
                         range=(29850, 30507),
                         value='\n'
                               '    WT_ADDR_COPY addr;\n'
                               '    WT_BTREE *btree;\n'
                               '    WT_DECL_ITEM(tmp);\n'
                               '    WT_DECL_RET;\n'
                               '    WT_REF *ref;\n'
                               '    uint64_t block_preload;\n'
                               '\n'
                               '    btree = S2BT(session);\n'
                               '    block_preload = 0;\n'
                               '\n'
                               '    WT_RET(__wt_scr_alloc(session, 0, &tmp));\n'
                               '\n'
                               '    /* Pre-load the second-level internal pages. */\n'
                               '    WT_INTL_FOREACH_BEGIN (session, btree->root.page, ref)\n'
                               '        if (__wt_ref_addr_copy(session, ref, &addr)) {\n'
                               '            WT_ERR(__wt_blkcache_read(session, tmp, addr.addr, addr.size));\n'
                               '            ++block_preload;\n'
                               '        }\n'
                               '    WT_INTL_FOREACH_END;\n'
                               '\n'
                               'err:\n'
                               '    __wt_scr_free(session, &tmp);\n'
                               '\n'
                               '    WT_STAT_CONN_INCRV(session, block_preload, block_preload);\n'
                               '    return (ret);\n'),
              preComment=Token(idx=152,
                               range=(29735, 29795),
                               value='/*\n * __btree_preload --\n *     Pre-load internal pages.\n */'),
              postComment=None,
              is_type_const=False,
              is_type_static=True)
Args:
[Variable(name=Token(idx=3, range=(29840, 29847), value='session'),
          typename=[29823:29838] 〈WT_SESSION_IMPL〉,
          preComment=None,
          postComment=None,
          end=None)]
Vars:
[Variable(name=Token(idx=4, range=(29868, 29872), value='addr'),
          typename=[29855:29867] 〈WT_ADDR_COPY〉,
          preComment=None,
          postComment=None,
          end=';'),
 Variable(name=Token(idx=11, range=(29888, 29893), value='btree'),
          typename=[29878:29886] 〈WT_BTREE〉,
          preComment=None,
          postComment=None,
          end=';')]
Statement(tokens=[30509:32742] 〈
⌇/*
 * __btree_get_last_recno --
 *     Set the last record number for a column-store. Note that this is used to handle appending to
 *     a column store after a truncate operation. It is not related to the WT_CURSOR::largest_key
 *     API.
 */⌇
⌇static⌇ ⌇int⌇
⌇__btree_get_last_recno⌇(WT_SESSION_IMPL *session)⌇
⌇{
    WT_BTREE *btree;
    WT_PAGE *page;
    WT_REF *next_walk;
    uint64_t last_recno;
    uint32_t flags;

    btree = S2BT(session);

    /*
     * The last record number is used to support appending to a column store tree that has had a
     * final page truncated. Since checkpoint trees are read-only they don't need the value.
     */
    if (WT_READING_CHECKPOINT(session)) {
        btree->last_recno = WT_RECNO_OOB;
        return (0);
    }

    /*
     * The endpoint for append is global; read the last page with global visibility (even if it's
     * deleted) to make sure that if the end of the tree is truncated, the tree walk finds the
     * correct page. (Note that this path does not examine the visibility of individual data items;
     * it only checks whether whole pages are deleted.)
     */
    flags = WT_READ_PREV | WT_READ_VISIBLE_ALL | WT_READ_SEE_DELETED;

    next_walk = NULL;
    WT_RET(__wt_tree_walk(session, &next_walk, flags));
    if (next_walk == NULL)
        return (WT_NOTFOUND);

    page = next_walk->page;
    last_recno = page->type == WT_PAGE_COL_VAR ? __col_var_last_recno(next_walk) :
                                                 __col_fix_last_recno(next_walk);

    /*
     * If the right-most page is deleted and globally visible, we skip reading the page from disk
     * and instead instantiate an empty page in memory. It's possible that next_walk points to this
     * empty page. When this happens, it has no entries and the last record number will be out of
     * bounds, i.e. zero.
     *
     * In this context, the page also can't have an insert (or append) list, so it's safe to simply
     * take the last ref's starting record number as the last record number of the tree.
     */
    if (last_recno == WT_RECNO_OOB)
        last_recno = next_walk->key.recno;
    btree->last_recno = last_recno;

    return (__wt_page_release(session, next_walk, 0));
}⌇
〉,
          kind=StatementKind(is_comment=True,
                             is_preproc=None,
                             is_typedef=None,
                             is_record=None,
                             is_function=True,
                             is_function_def=True,
                             is_function_decl=True,
                             is_statement=None,
                             is_decl=True,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=Token(idx=164,
                                              range=(30510, 30755),
                                              value='/*\n'
                                                    ' * __btree_get_last_recno --\n'
                                                    ' *     Set the last record number for a column-store. Note that '
                                                    'this is used to handle appending to\n'
                                                    ' *     a column store after a truncate operation. It is not '
                                                    'related to the WT_CURSOR::largest_key\n'
                                                    ' *     API.\n'
                                                    ' */'),
                             postComment=None))
Function:
FunctionParts(typename=[30763:30766] 〈int〉,
              name=Token(idx=170, range=(30767, 30789), value='__btree_get_last_recno'),
              args=Token(idx=171, range=(30790, 30814), value='WT_SESSION_IMPL *session'),
              body=Token(idx=173,
                         range=(30817, 32740),
                         value='\n'
                               '    WT_BTREE *btree;\n'
                               '    WT_PAGE *page;\n'
                               '    WT_REF *next_walk;\n'
                               '    uint64_t last_recno;\n'
                               '    uint32_t flags;\n'
                               '\n'
                               '    btree = S2BT(session);\n'
                               '\n'
                               '    /*\n'
                               '     * The last record number is used to support appending to a column store tree that '
                               'has had a\n'
                               "     * final page truncated. Since checkpoint trees are read-only they don't need the "
                               'value.\n'
                               '     */\n'
                               '    if (WT_READING_CHECKPOINT(session)) {\n'
                               '        btree->last_recno = WT_RECNO_OOB;\n'
                               '        return (0);\n'
                               '    }\n'
                               '\n'
                               '    /*\n'
                               '     * The endpoint for append is global; read the last page with global visibility '
                               "(even if it's\n"
                               '     * deleted) to make sure that if the end of the tree is truncated, the tree walk '
                               'finds the\n'
                               '     * correct page. (Note that this path does not examine the visibility of '
                               'individual data items;\n'
                               '     * it only checks whether whole pages are deleted.)\n'
                               '     */\n'
                               '    flags = WT_READ_PREV | WT_READ_VISIBLE_ALL | WT_READ_SEE_DELETED;\n'
                               '\n'
                               '    next_walk = NULL;\n'
                               '    WT_RET(__wt_tree_walk(session, &next_walk, flags));\n'
                               '    if (next_walk == NULL)\n'
                               '        return (WT_NOTFOUND);\n'
                               '\n'
                               '    page = next_walk->page;\n'
                               '    last_recno = page->type == WT_PAGE_COL_VAR ? __col_var_last_recno(next_walk) :\n'
                               '                                                 __col_fix_last_recno(next_walk);\n'
                               '\n'
                               '    /*\n'
                               '     * If the right-most page is deleted and globally visible, we skip reading the '
                               'page from disk\n'
                               "     * and instead instantiate an empty page in memory. It's possible that next_walk "
                               'points to this\n'
                               '     * empty page. When this happens, it has no entries and the last record number '
                               'will be out of\n'
                               '     * bounds, i.e. zero.\n'
                               '     *\n'
                               "     * In this context, the page also can't have an insert (or append) list, so it's "
                               'safe to simply\n'
                               "     * take the last ref's starting record number as the last record number of the "
                               'tree.\n'
                               '     */\n'
                               '    if (last_recno == WT_RECNO_OOB)\n'
                               '        last_recno = next_walk->key.recno;\n'
                               '    btree->last_recno = last_recno;\n'
                               '\n'
                               '    return (__wt_page_release(session, next_walk, 0));\n'),
              preComment=Token(idx=164,
                               range=(30510, 30755),
                               value='/*\n'
                                     ' * __btree_get_last_recno --\n'
                                     ' *     Set the last record number for a column-store. Note that this is used to '
                                     'handle appending to\n'
                                     ' *     a column store after a truncate operation. It is not related to the '
                                     'WT_CURSOR::largest_key\n'
                                     ' *     API.\n'
                                     ' */'),
              postComment=None,
              is_type_const=False,
              is_type_static=True)
Args:
[Variable(name=Token(idx=3, range=(30807, 30814), value='session'),
          typename=[30790:30805] 〈WT_SESSION_IMPL〉,
          preComment=None,
          postComment=None,
          end=None)]
Vars:
[Variable(name=Token(idx=5, range=(30832, 30837), value='btree'),
          typename=[30822:30830] 〈WT_BTREE〉,
          preComment=None,
          postComment=None,
          end=';'),
 Variable(name=Token(idx=12, range=(30852, 30856), value='page'),
          typename=[30843:30850] 〈WT_PAGE〉,
          preComment=None,
          postComment=None,
          end=';'),
 Variable(name=Token(idx=19, range=(30870, 30879), value='next_walk'),
          typename=[30862:30868] 〈WT_REF〉,
          preComment=None,
          postComment=None,
          end=';'),
 Variable(name=Token(idx=25, range=(30894, 30904), value='last_recno'),
          typename=[30885:30893] 〈uint64_t〉,
          preComment=None,
          postComment=None,
          end=';'),
 Variable(name=Token(idx=31, range=(30919, 30924), value='flags'),
          typename=[30910:30918] 〈uint32_t〉,
          preComment=None,
          postComment=None,
          end=';')]
Statement(tokens=[32742:40171] 〈
⌇/*
 * __btree_page_sizes --
 *     Verify the page sizes. Some of these sizes are automatically checked using limits defined in
 *     the API, don't duplicate the logic here.
 */⌇
⌇static⌇ ⌇int⌇
⌇__btree_page_sizes⌇(WT_SESSION_IMPL *session)⌇
⌇{
    WT_BTREE *btree;
    WT_CONFIG_ITEM cval;
    WT_CONNECTION_IMPL *conn;
    uint64_t cache_size;
    uint32_t leaf_split_size, max;
    const char **cfg;

    btree = S2BT(session);
    conn = S2C(session);
    cfg = btree->dhandle->cfg;

    /*
     * Get the allocation size. Allocation sizes must be a power-of-two, nothing else makes sense.
     */
    WT_RET(__wt_direct_io_size_check(session, cfg, "allocation_size", &btree->btree_private.allocsize));
    if (!__wt_ispo2(btree->btree_private.allocsize))
        WT_RET_MSG(session, EINVAL, "the allocation size must be a power of two");

    /*
     * Get the internal/leaf page sizes. All page sizes must be in units of the allocation size.
     */
    WT_RET(__wt_direct_io_size_check(session, cfg, "internal_page_max", &btree->btree_private.maxintlpage));
    WT_RET(__wt_direct_io_size_check(session, cfg, "leaf_page_max", &btree->btree_private.maxleafpage));
    if (btree->btree_private.maxintlpage < btree->btree_private.allocsize || btree->btree_private.maxintlpage % btree->btree_private.allocsize != 0 ||
      btree->btree_private.maxleafpage < btree->btree_private.allocsize || btree->btree_private.maxleafpage % btree->btree_private.allocsize != 0)
        WT_RET_MSG(session, EINVAL,
          "page sizes must be a multiple of the page allocation size (%" PRIu32 "B)",
          btree->btree_private.allocsize);

    /*
     * FLCS leaf pages have a lower size limit than the default, because the size configures the
     * bitmap data size and the timestamp data adds on to that. Each time window can be up to 63
     * bytes and the total page size must not exceed 4G. Thus for an 8t table there can be 64M
     * entries (so 64M of bitmap data and up to 63*64M == 4032M of time windows), less a bit for
     * headers. For a 1t table there can be (64 7/8)M entries because the bitmap takes less space,
     * but that corresponds to a configured page size of a bit over 8M. Consequently the absolute
     * limit on the page size is 8M, but since pages this large make no sense and perform poorly
     * even if they don't get bloated out with timestamp data, we'll cut down by a factor of 16 and
     * set the limit to 128KB.
     */
    if (btree->type == BTREE_COL_FIX && btree->btree_private.maxleafpage > 128 * WT_KILOBYTE)
        WT_RET_MSG(session, EINVAL, "page size for fixed-length column store is limited to 128KB");

    /*
     * Default in-memory page image size for compression is 4x the maximum internal or leaf page
     * size, and enforce the on-disk page sizes as a lower-limit for the in-memory image size.
     */
    WT_RET(__wt_config_gets(session, cfg, "memory_page_image_max", &cval));
    btree->btree_private.maxmempage_image = (uint32_t)cval.val;
    max = WT_MAX(btree->btree_private.maxintlpage, btree->btree_private.maxleafpage);
    if (btree->btree_private.maxmempage_image == 0)
        btree->btree_private.maxmempage_image = 4 * max;
    else if (btree->btree_private.maxmempage_image < max)
        WT_RET_MSG(session, EINVAL,
          "in-memory page image size must be larger than the maximum page size (%" PRIu32
          "B < %" PRIu32 "B)",
          btree->btree_private.maxmempage_image, max);

    /*
     * Don't let pages grow large compared to the cache size or we can end
     * up in a situation where nothing can be evicted.  Make sure at least
     * 10 pages fit in cache when it is at the dirty trigger where threads
     * stall.
     *
     * Take care getting the cache size: with a shared cache, it may not
     * have been set.  Don't forget to update the API documentation if you
     * alter the bounds for any of the parameters here.
     */
    WT_RET(__wt_config_gets(session, cfg, "memory_page_max", &cval));
    btree->btree_private.maxmempage = (uint64_t)cval.val;

#define WT_MIN_PAGES 10
    if (!F_ISSET(conn, WT_CONN_CACHE_POOL) && (cache_size = conn->cache_size) > 0)
        btree->btree_private.maxmempage = (uint64_t)WT_MIN(btree->btree_private.maxmempage,
          ((conn->evict->eviction_dirty_trigger * cache_size) / 100) / WT_MIN_PAGES);

    /* Enforce a lower bound of a single disk leaf page */
    btree->btree_private.maxmempage = WT_MAX(btree->btree_private.maxmempage, btree->btree_private.maxleafpage);

    /*
     * Try in-memory splits once we hit 80% of the maximum in-memory page size. This gives
     * multi-threaded append workloads a better chance of not stalling.
     */
    btree->btree_private.splitmempage = (8 * btree->btree_private.maxmempage) / 10;

    /*
     * Get the split percentage (reconciliation splits pages into smaller than the maximum page size
     * chunks so we don't split every time a new entry is added). Determine how large newly split
     * pages will be. Set to the minimum, if the read value is less than that.
     */
    WT_RET(__wt_config_gets(session, cfg, "split_pct", &cval));
    if (cval.val < WT_BTREE_MIN_SPLIT_PCT) {
        btree->split_pct = WT_BTREE_MIN_SPLIT_PCT;
        __wt_verbose_notice(session, WT_VERB_SPLIT,
          "Re-setting split_pct for %s to the minimum allowed of %d%%", session->dhandle->name,
          WT_BTREE_MIN_SPLIT_PCT);
    } else
        btree->split_pct = (int)cval.val;
    leaf_split_size = __wt_split_page_size(btree->split_pct, btree->btree_private.maxleafpage, btree->btree_private.allocsize);

    /*
     * In-memory split configuration.
     */
    if (__wt_config_gets(session, cfg, "split_deepen_min_child", &cval) == WT_NOTFOUND ||
      cval.val == 0)
        btree->split_deepen_min_child = WT_SPLIT_DEEPEN_MIN_CHILD_DEF;
    else
        btree->split_deepen_min_child = (u_int)cval.val;
    if (__wt_config_gets(session, cfg, "split_deepen_per_child", &cval) == WT_NOTFOUND ||
      cval.val == 0)
        btree->split_deepen_per_child = WT_SPLIT_DEEPEN_PER_CHILD_DEF;
    else
        btree->split_deepen_per_child = (u_int)cval.val;

    /*
     * Get the maximum internal/leaf page key/value sizes.
     *
     * In-memory configuration overrides any key/value sizes, there's no such thing as an overflow
     * item in an in-memory configuration.
     */
    if (F_ISSET(conn, WT_CONN_IN_MEMORY)) {
        btree->btree_private.maxleafkey = WT_BTREE_MAX_OBJECT_SIZE;
        btree->btree_private.maxleafvalue = WT_BTREE_MAX_OBJECT_SIZE;
        return (0);
    }

    WT_RET(__wt_config_gets(session, cfg, "leaf_key_max", &cval));
    btree->btree_private.maxleafkey = (uint32_t)cval.val;
    WT_RET(__wt_config_gets(session, cfg, "leaf_value_max", &cval));
    btree->btree_private.maxleafvalue = (uint32_t)cval.val;

    /*
     * Default max for leaf keys: split-page / 10. Default max for leaf values: split-page / 2.
     *
     * It's difficult for applications to configure this in any exact way as they have to duplicate
     * our calculation of how many keys must fit on a page, and given a split-percentage and page
     * header, that isn't easy to do.
     */
    if (btree->btree_private.maxleafkey == 0)
        btree->btree_private.maxleafkey = leaf_split_size / 10;
    if (btree->btree_private.maxleafvalue == 0)
        btree->btree_private.maxleafvalue = leaf_split_size / 2;

    return (0);
}⌇
〉,
          kind=StatementKind(is_comment=True,
                             is_preproc=None,
                             is_typedef=None,
                             is_record=None,
                             is_function=True,
                             is_function_def=True,
                             is_function_decl=True,
                             is_statement=None,
                             is_decl=True,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=Token(idx=176,
                                              range=(32743, 32922),
                                              value='/*\n'
                                                    ' * __btree_page_sizes --\n'
                                                    ' *     Verify the page sizes. Some of these sizes are '
                                                    'automatically checked using limits defined in\n'
                                                    " *     the API, don't duplicate the logic here.\n"
                                                    ' */'),
                             postComment=None))
Function:
FunctionParts(typename=[32930:32933] 〈int〉,
              name=Token(idx=182, range=(32934, 32952), value='__btree_page_sizes'),
              args=Token(idx=183, range=(32953, 32977), value='WT_SESSION_IMPL *session'),
              body=Token(idx=185,
                         range=(32980, 40169),
                         value='\n'
                               '    WT_BTREE *btree;\n'
                               '    WT_CONFIG_ITEM cval;\n'
                               '    WT_CONNECTION_IMPL *conn;\n'
                               '    uint64_t cache_size;\n'
                               '    uint32_t leaf_split_size, max;\n'
                               '    const char **cfg;\n'
                               '\n'
                               '    btree = S2BT(session);\n'
                               '    conn = S2C(session);\n'
                               '    cfg = btree->dhandle->cfg;\n'
                               '\n'
                               '    /*\n'
                               '     * Get the allocation size. Allocation sizes must be a power-of-two, nothing else '
                               'makes sense.\n'
                               '     */\n'
                               '    WT_RET(__wt_direct_io_size_check(session, cfg, "allocation_size", '
                               '&btree->btree_private.allocsize));\n'
                               '    if (!__wt_ispo2(btree->btree_private.allocsize))\n'
                               '        WT_RET_MSG(session, EINVAL, "the allocation size must be a power of two");\n'
                               '\n'
                               '    /*\n'
                               '     * Get the internal/leaf page sizes. All page sizes must be in units of the '
                               'allocation size.\n'
                               '     */\n'
                               '    WT_RET(__wt_direct_io_size_check(session, cfg, "internal_page_max", '
                               '&btree->btree_private.maxintlpage));\n'
                               '    WT_RET(__wt_direct_io_size_check(session, cfg, "leaf_page_max", '
                               '&btree->btree_private.maxleafpage));\n'
                               '    if (btree->btree_private.maxintlpage < btree->btree_private.allocsize || '
                               'btree->btree_private.maxintlpage % btree->btree_private.allocsize != 0 ||\n'
                               '      btree->btree_private.maxleafpage < btree->btree_private.allocsize || '
                               'btree->btree_private.maxleafpage % btree->btree_private.allocsize != 0)\n'
                               '        WT_RET_MSG(session, EINVAL,\n'
                               '          "page sizes must be a multiple of the page allocation size (%" PRIu32 "B)",\n'
                               '          btree->btree_private.allocsize);\n'
                               '\n'
                               '    /*\n'
                               '     * FLCS leaf pages have a lower size limit than the default, because the size '
                               'configures the\n'
                               '     * bitmap data size and the timestamp data adds on to that. Each time window can '
                               'be up to 63\n'
                               '     * bytes and the total page size must not exceed 4G. Thus for an 8t table there '
                               'can be 64M\n'
                               '     * entries (so 64M of bitmap data and up to 63*64M == 4032M of time windows), less '
                               'a bit for\n'
                               '     * headers. For a 1t table there can be (64 7/8)M entries because the bitmap takes '
                               'less space,\n'
                               '     * but that corresponds to a configured page size of a bit over 8M. Consequently '
                               'the absolute\n'
                               '     * limit on the page size is 8M, but since pages this large make no sense and '
                               'perform poorly\n'
                               "     * even if they don't get bloated out with timestamp data, we'll cut down by a "
                               'factor of 16 and\n'
                               '     * set the limit to 128KB.\n'
                               '     */\n'
                               '    if (btree->type == BTREE_COL_FIX && btree->btree_private.maxleafpage > 128 * '
                               'WT_KILOBYTE)\n'
                               '        WT_RET_MSG(session, EINVAL, "page size for fixed-length column store is '
                               'limited to 128KB");\n'
                               '\n'
                               '    /*\n'
                               '     * Default in-memory page image size for compression is 4x the maximum internal or '
                               'leaf page\n'
                               '     * size, and enforce the on-disk page sizes as a lower-limit for the in-memory '
                               'image size.\n'
                               '     */\n'
                               '    WT_RET(__wt_config_gets(session, cfg, "memory_page_image_max", &cval));\n'
                               '    btree->btree_private.maxmempage_image = (uint32_t)cval.val;\n'
                               '    max = WT_MAX(btree->btree_private.maxintlpage, btree->btree_private.maxleafpage);\n'
                               '    if (btree->btree_private.maxmempage_image == 0)\n'
                               '        btree->btree_private.maxmempage_image = 4 * max;\n'
                               '    else if (btree->btree_private.maxmempage_image < max)\n'
                               '        WT_RET_MSG(session, EINVAL,\n'
                               '          "in-memory page image size must be larger than the maximum page size (%" '
                               'PRIu32\n'
                               '          "B < %" PRIu32 "B)",\n'
                               '          btree->btree_private.maxmempage_image, max);\n'
                               '\n'
                               '    /*\n'
                               "     * Don't let pages grow large compared to the cache size or we can end\n"
                               '     * up in a situation where nothing can be evicted.  Make sure at least\n'
                               '     * 10 pages fit in cache when it is at the dirty trigger where threads\n'
                               '     * stall.\n'
                               '     *\n'
                               '     * Take care getting the cache size: with a shared cache, it may not\n'
                               "     * have been set.  Don't forget to update the API documentation if you\n"
                               '     * alter the bounds for any of the parameters here.\n'
                               '     */\n'
                               '    WT_RET(__wt_config_gets(session, cfg, "memory_page_max", &cval));\n'
                               '    btree->btree_private.maxmempage = (uint64_t)cval.val;\n'
                               '\n'
                               '#define WT_MIN_PAGES 10\n'
                               '    if (!F_ISSET(conn, WT_CONN_CACHE_POOL) && (cache_size = conn->cache_size) > 0)\n'
                               '        btree->btree_private.maxmempage = '
                               '(uint64_t)WT_MIN(btree->btree_private.maxmempage,\n'
                               '          ((conn->evict->eviction_dirty_trigger * cache_size) / 100) / WT_MIN_PAGES);\n'
                               '\n'
                               '    /* Enforce a lower bound of a single disk leaf page */\n'
                               '    btree->btree_private.maxmempage = WT_MAX(btree->btree_private.maxmempage, '
                               'btree->btree_private.maxleafpage);\n'
                               '\n'
                               '    /*\n'
                               '     * Try in-memory splits once we hit 80% of the maximum in-memory page size. This '
                               'gives\n'
                               '     * multi-threaded append workloads a better chance of not stalling.\n'
                               '     */\n'
                               '    btree->btree_private.splitmempage = (8 * btree->btree_private.maxmempage) / 10;\n'
                               '\n'
                               '    /*\n'
                               '     * Get the split percentage (reconciliation splits pages into smaller than the '
                               'maximum page size\n'
                               "     * chunks so we don't split every time a new entry is added). Determine how large "
                               'newly split\n'
                               '     * pages will be. Set to the minimum, if the read value is less than that.\n'
                               '     */\n'
                               '    WT_RET(__wt_config_gets(session, cfg, "split_pct", &cval));\n'
                               '    if (cval.val < WT_BTREE_MIN_SPLIT_PCT) {\n'
                               '        btree->split_pct = WT_BTREE_MIN_SPLIT_PCT;\n'
                               '        __wt_verbose_notice(session, WT_VERB_SPLIT,\n'
                               '          "Re-setting split_pct for %s to the minimum allowed of %d%%", '
                               'session->dhandle->name,\n'
                               '          WT_BTREE_MIN_SPLIT_PCT);\n'
                               '    } else\n'
                               '        btree->split_pct = (int)cval.val;\n'
                               '    leaf_split_size = __wt_split_page_size(btree->split_pct, '
                               'btree->btree_private.maxleafpage, btree->btree_private.allocsize);\n'
                               '\n'
                               '    /*\n'
                               '     * In-memory split configuration.\n'
                               '     */\n'
                               '    if (__wt_config_gets(session, cfg, "split_deepen_min_child", &cval) == WT_NOTFOUND '
                               '||\n'
                               '      cval.val == 0)\n'
                               '        btree->split_deepen_min_child = WT_SPLIT_DEEPEN_MIN_CHILD_DEF;\n'
                               '    else\n'
                               '        btree->split_deepen_min_child = (u_int)cval.val;\n'
                               '    if (__wt_config_gets(session, cfg, "split_deepen_per_child", &cval) == WT_NOTFOUND '
                               '||\n'
                               '      cval.val == 0)\n'
                               '        btree->split_deepen_per_child = WT_SPLIT_DEEPEN_PER_CHILD_DEF;\n'
                               '    else\n'
                               '        btree->split_deepen_per_child = (u_int)cval.val;\n'
                               '\n'
                               '    /*\n'
                               '     * Get the maximum internal/leaf page key/value sizes.\n'
                               '     *\n'
                               "     * In-memory configuration overrides any key/value sizes, there's no such thing as "
                               'an overflow\n'
                               '     * item in an in-memory configuration.\n'
                               '     */\n'
                               '    if (F_ISSET(conn, WT_CONN_IN_MEMORY)) {\n'
                               '        btree->btree_private.maxleafkey = WT_BTREE_MAX_OBJECT_SIZE;\n'
                               '        btree->btree_private.maxleafvalue = WT_BTREE_MAX_OBJECT_SIZE;\n'
                               '        return (0);\n'
                               '    }\n'
                               '\n'
                               '    WT_RET(__wt_config_gets(session, cfg, "leaf_key_max", &cval));\n'
                               '    btree->btree_private.maxleafkey = (uint32_t)cval.val;\n'
                               '    WT_RET(__wt_config_gets(session, cfg, "leaf_value_max", &cval));\n'
                               '    btree->btree_private.maxleafvalue = (uint32_t)cval.val;\n'
                               '\n'
                               '    /*\n'
                               '     * Default max for leaf keys: split-page / 10. Default max for leaf values: '
                               'split-page / 2.\n'
                               '     *\n'
                               "     * It's difficult for applications to configure this in any exact way as they have "
                               'to duplicate\n'
                               '     * our calculation of how many keys must fit on a page, and given a '
                               'split-percentage and page\n'
                               "     * header, that isn't easy to do.\n"
                               '     */\n'
                               '    if (btree->btree_private.maxleafkey == 0)\n'
                               '        btree->btree_private.maxleafkey = leaf_split_size / 10;\n'
                               '    if (btree->btree_private.maxleafvalue == 0)\n'
                               '        btree->btree_private.maxleafvalue = leaf_split_size / 2;\n'
                               '\n'
                               '    return (0);\n'),
              preComment=Token(idx=176,
                               range=(32743, 32922),
                               value='/*\n'
                                     ' * __btree_page_sizes --\n'
                                     ' *     Verify the page sizes. Some of these sizes are automatically checked '
                                     'using limits defined in\n'
                                     " *     the API, don't duplicate the logic here.\n"
                                     ' */'),
              postComment=None,
              is_type_const=False,
              is_type_static=True)
Args:
[Variable(name=Token(idx=3, range=(32970, 32977), value='session'),
          typename=[32953:32968] 〈WT_SESSION_IMPL〉,
          preComment=None,
          postComment=None,
          end=None)]
Vars:
[Variable(name=Token(idx=5, range=(32995, 33000), value='btree'),
          typename=[32985:32993] 〈WT_BTREE〉,
          preComment=None,
          postComment=None,
          end=';'),
 Variable(name=Token(idx=11, range=(33021, 33025), value='cval'),
          typename=[33006:33020] 〈WT_CONFIG_ITEM〉,
          preComment=None,
          postComment=None,
          end=';'),
 Variable(name=Token(idx=18, range=(33051, 33055), value='conn'),
          typename=[33031:33049] 〈WT_CONNECTION_IMPL〉,
          preComment=None,
          postComment=None,
          end=';'),
 Variable(name=Token(idx=24, range=(33070, 33080), value='cache_size'),
          typename=[33061:33069] 〈uint64_t〉,
          preComment=None,
          postComment=None,
          end=';'),
 Variable(name=Token(idx=30, range=(33095, 33110), value='leaf_split_size'),
          typename=[33086:33094] 〈uint32_t〉,
          preComment=None,
          postComment=None,
          end=','),
 Variable(name=Token(idx=33, range=(33112, 33115), value='max'),
          typename=[33086:33094] 〈uint32_t〉,
          preComment=None,
          postComment=None,
          end=';'),
 Variable(name=Token(idx=43, range=(33134, 33137), value='cfg'),
          typename=[33127:33131] 〈char〉,
          preComment=None,
          postComment=None,
          end=';')]
Statement(tokens=[40171:40845] 〈
⌇/*
 * __wt_btree_switch_object --
 *     Switch to a writeable object for a tiered btree.
 */⌇
⌇int⌇
⌇__wt_btree_switch_object⌇(WT_SESSION_IMPL *session, uint32_t objectid)⌇
⌇{
    WT_BM *bm;
    WT_BTREE *btree;

    btree = S2BT(session);
    /* If the btree is readonly, there is nothing to do. */
    if (F_ISSET(btree, WT_BTREE_READONLY))
        return (0);

    /*
     * When initially opening a tiered Btree, a tier switch is done internally without the btree
     * being fully opened. That's okay, the btree will be told later about the current object
     * number.
     */
    bm = btree->bm;
    return (bm == NULL ? 0 : bm->switch_object(bm, session, objectid));
}⌇
〉,
          kind=StatementKind(is_comment=True,
                             is_preproc=None,
                             is_typedef=None,
                             is_record=None,
                             is_function=True,
                             is_function_def=True,
                             is_function_decl=True,
                             is_statement=None,
                             is_decl=True,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=Token(idx=188,
                                              range=(40172, 40265),
                                              value='/*\n'
                                                    ' * __wt_btree_switch_object --\n'
                                                    ' *     Switch to a writeable object for a tiered btree.\n'
                                                    ' */'),
                             postComment=None))
Function:
FunctionParts(typename=[40266:40269] 〈int〉,
              name=Token(idx=192, range=(40270, 40294), value='__wt_btree_switch_object'),
              args=Token(idx=193, range=(40295, 40338), value='WT_SESSION_IMPL *session, uint32_t objectid'),
              body=Token(idx=195,
                         range=(40341, 40843),
                         value='\n'
                               '    WT_BM *bm;\n'
                               '    WT_BTREE *btree;\n'
                               '\n'
                               '    btree = S2BT(session);\n'
                               '    /* If the btree is readonly, there is nothing to do. */\n'
                               '    if (F_ISSET(btree, WT_BTREE_READONLY))\n'
                               '        return (0);\n'
                               '\n'
                               '    /*\n'
                               '     * When initially opening a tiered Btree, a tier switch is done internally without '
                               'the btree\n'
                               "     * being fully opened. That's okay, the btree will be told later about the current "
                               'object\n'
                               '     * number.\n'
                               '     */\n'
                               '    bm = btree->bm;\n'
                               '    return (bm == NULL ? 0 : bm->switch_object(bm, session, objectid));\n'),
              preComment=Token(idx=188,
                               range=(40172, 40265),
                               value='/*\n'
                                     ' * __wt_btree_switch_object --\n'
                                     ' *     Switch to a writeable object for a tiered btree.\n'
                                     ' */'),
              postComment=None,
              is_type_const=False,
              is_type_static=False)
Args:
[Variable(name=Token(idx=3, range=(40312, 40319), value='session'),
          typename=[40295:40310] 〈WT_SESSION_IMPL〉,
          preComment=None,
          postComment=None,
          end=','),
 Variable(name=Token(idx=8, range=(40330, 40338), value='objectid'),
          typename=[40321:40329] 〈uint32_t〉,
          preComment=None,
          postComment=None,
          end=None)]
Vars:
[Variable(name=Token(idx=5, range=(40353, 40355), value='bm'),
          typename=[40346:40351] 〈WT_BM〉,
          preComment=None,
          postComment=None,
          end=';'),
 Variable(name=Token(idx=12, range=(40371, 40376), value='btree'),
          typename=[40361:40369] 〈WT_BTREE〉,
          preComment=None,
          postComment=None,
          end=';')]