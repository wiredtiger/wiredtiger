Statement(tokens=[0:193] 〈/*-
 * Copyright (c) 2014-present MongoDB, Inc.
 * Copyright (c) 2008-2014 WiredTiger, Inc.
 *	All rights reserved.
 *
 * See the file LICENSE for redistribution information.
 */⌇
⌇
⌇#pragma once
〉,
          kind=StatementKind(is_comment=True,
                             is_preproc=True,
                             is_typedef=None,
                             is_record=None,
                             is_function=None,
                             is_function_def=None,
                             is_function_decl=None,
                             is_statement=None,
                             is_decl=None,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=Token(idx=0,
                                              range=(0, 178),
                                              value='/*-\n'
                                                    ' * Copyright (c) 2014-present MongoDB, Inc.\n'
                                                    ' * Copyright (c) 2008-2014 WiredTiger, Inc.\n'
                                                    ' *\tAll rights reserved.\n'
                                                    ' *\n'
                                                    ' * See the file LICENSE for redistribution information.\n'
                                                    ' */'),
                             postComment=None))
Statement(tokens=[193:243] 〈
⌇/*
 * WiredTiger's block manager interface.
 */⌇
⌇
〉,
          kind=StatementKind(is_comment=True,
                             is_preproc=None,
                             is_typedef=None,
                             is_record=None,
                             is_function=None,
                             is_function_def=None,
                             is_function_decl=None,
                             is_statement=None,
                             is_decl=None,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=Token(idx=5,
                                              range=(194, 241),
                                              value="/*\n * WiredTiger's block manager interface.\n */"),
                             postComment=None))
Statement(tokens=[243:418] 〈/*
 * The file's description is written into the first block of the file, which means we can use an
 * offset of 0 as an invalid offset.
 */⌇
⌇#define WT_BLOCK_INVALID_OFFSET 0
〉,
          kind=StatementKind(is_comment=True,
                             is_preproc=True,
                             is_typedef=None,
                             is_record=None,
                             is_function=None,
                             is_function_def=None,
                             is_function_decl=None,
                             is_statement=None,
                             is_decl=None,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=Token(idx=8,
                                              range=(243, 383),
                                              value='/*\n'
                                                    " * The file's description is written into the first block of the "
                                                    'file, which means we can use an\n'
                                                    ' * offset of 0 as an invalid offset.\n'
                                                    ' */'),
                             postComment=None))
Macro:
MacroParts(name=Token(idx=0, range=(392, 415), value='WT_BLOCK_INVALID_OFFSET'),
           args=None,
           body=Token(idx=0, range=(416, 418), value='0'),
           preComment=Token(idx=8,
                            range=(243, 383),
                            value='/*\n'
                                  " * The file's description is written into the first block of the file, which means "
                                  'we can use an\n'
                                  ' * offset of 0 as an invalid offset.\n'
                                  ' */'),
           is_va_args=False,
           is_wellformed=True,
           is_const=True)
Statement(tokens=[418:1686] 〈
⌇/*
 * The block manager maintains three per-checkpoint extent lists:
 *	alloc:	 the extents allocated in this checkpoint
 *	avail:	 the extents available for allocation
 *	discard: the extents freed in this checkpoint
 *
 * An extent list is based on two skiplists: first, a by-offset list linking
 * WT_EXT elements and sorted by file offset (low-to-high), second, a by-size
 * list linking WT_SIZE elements and sorted by chunk size (low-to-high).
 *
 * Additionally, each WT_SIZE element on the by-size has a skiplist of its own,
 * linking WT_EXT elements and sorted by file offset (low-to-high).  This list
 * has an entry for extents of a particular size.
 *
 * The trickiness is each individual WT_EXT element appears on two skiplists.
 * In order to minimize allocation calls, we allocate a single array of WT_EXT
 * pointers at the end of the WT_EXT structure, for both skiplists, and store
 * the depth of the skiplist in the WT_EXT structure.  The skiplist entries for
 * the offset skiplist start at WT_EXT.next[0] and the entries for the size
 * skiplist start at WT_EXT.next[WT_EXT.depth].
 *
 * One final complication: we only maintain the per-size skiplist for the avail
 * list, the alloc and discard extent lists are not searched based on size.
 */⌇
⌇
〉,
          kind=StatementKind(is_comment=True,
                             is_preproc=None,
                             is_typedef=None,
                             is_record=None,
                             is_function=None,
                             is_function_def=None,
                             is_function_decl=None,
                             is_statement=None,
                             is_decl=None,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=Token(idx=12,
                                              range=(419, 1684),
                                              value='/*\n'
                                                    ' * The block manager maintains three per-checkpoint extent '
                                                    'lists:\n'
                                                    ' *\talloc:\t the extents allocated in this checkpoint\n'
                                                    ' *\tavail:\t the extents available for allocation\n'
                                                    ' *\tdiscard: the extents freed in this checkpoint\n'
                                                    ' *\n'
                                                    ' * An extent list is based on two skiplists: first, a by-offset '
                                                    'list linking\n'
                                                    ' * WT_EXT elements and sorted by file offset (low-to-high), '
                                                    'second, a by-size\n'
                                                    ' * list linking WT_SIZE elements and sorted by chunk size '
                                                    '(low-to-high).\n'
                                                    ' *\n'
                                                    ' * Additionally, each WT_SIZE element on the by-size has a '
                                                    'skiplist of its own,\n'
                                                    ' * linking WT_EXT elements and sorted by file offset '
                                                    '(low-to-high).  This list\n'
                                                    ' * has an entry for extents of a particular size.\n'
                                                    ' *\n'
                                                    ' * The trickiness is each individual WT_EXT element appears on '
                                                    'two skiplists.\n'
                                                    ' * In order to minimize allocation calls, we allocate a single '
                                                    'array of WT_EXT\n'
                                                    ' * pointers at the end of the WT_EXT structure, for both '
                                                    'skiplists, and store\n'
                                                    ' * the depth of the skiplist in the WT_EXT structure.  The '
                                                    'skiplist entries for\n'
                                                    ' * the offset skiplist start at WT_EXT.next[0] and the entries '
                                                    'for the size\n'
                                                    ' * skiplist start at WT_EXT.next[WT_EXT.depth].\n'
                                                    ' *\n'
                                                    ' * One final complication: we only maintain the per-size skiplist '
                                                    'for the avail\n'
                                                    ' * list, the alloc and discard extent lists are not searched '
                                                    'based on size.\n'
                                                    ' */'),
                             postComment=None))
Statement(tokens=[1686:2261] 〈/*
 * WT_EXTLIST --
 *	An extent list.
 */⌇
⌇struct⌇ ⌇__wt_extlist⌇ ⌇{
    char *name; /* Name */

    uint64_t bytes;   /* Byte count */
    uint32_t entries; /* Entry count */

    uint32_t objectid; /* Written object ID */
    wt_off_t offset;   /* Written extent offset */
    uint32_t checksum; /* Written extent checksum */
    uint32_t size;     /* Written extent size */

    bool track_size; /* Maintain per-size skiplist */

    WT_EXT *last; /* Cached last element */

    WT_EXT *off[WT_SKIP_MAXDEPTH]; /* Size/offset skiplists */
    WT_SIZE *sz[WT_SKIP_MAXDEPTH];
}⌇;⌇
〉,
          kind=StatementKind(is_comment=True,
                             is_preproc=None,
                             is_typedef=None,
                             is_record=True,
                             is_function=None,
                             is_function_def=None,
                             is_function_decl=None,
                             is_statement=None,
                             is_decl=None,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=Token(idx=15,
                                              range=(1686, 1728),
                                              value='/*\n * WT_EXTLIST --\n *\tAn extent list.\n */'),
                             postComment=None))
Record:
RecordParts(recordKind=<RecordKind.STRUCT: 1>,
            name=Token(idx=19, range=(1736, 1748), value='__wt_extlist'),
            typename=[1736:1748] 〈__wt_extlist〉,
            body=Token(idx=21,
                       range=(1750, 2258),
                       value='\n'
                             '    char *name; /* Name */\n'
                             '\n'
                             '    uint64_t bytes;   /* Byte count */\n'
                             '    uint32_t entries; /* Entry count */\n'
                             '\n'
                             '    uint32_t objectid; /* Written object ID */\n'
                             '    wt_off_t offset;   /* Written extent offset */\n'
                             '    uint32_t checksum; /* Written extent checksum */\n'
                             '    uint32_t size;     /* Written extent size */\n'
                             '\n'
                             '    bool track_size; /* Maintain per-size skiplist */\n'
                             '\n'
                             '    WT_EXT *last; /* Cached last element */\n'
                             '\n'
                             '    WT_EXT *off[WT_SKIP_MAXDEPTH]; /* Size/offset skiplists */\n'
                             '    WT_SIZE *sz[WT_SKIP_MAXDEPTH];\n'),
            members=[Variable(name=Token(idx=5, range=(1761, 1765), value='name'),
                              typename=[1755:1759] 〈char〉,
                              preComment=None,
                              postComment=Token(idx=8, range=(1767, 1777), value='/* Name */'),
                              end=';'),
                     Variable(name=Token(idx=14, range=(1792, 1797), value='bytes'),
                              typename=[1783:1791] 〈uint64_t〉,
                              preComment=None,
                              postComment=Token(idx=17, range=(1801, 1817), value='/* Byte count */'),
                              end=';'),
                     Variable(name=Token(idx=22, range=(1831, 1838), value='entries'),
                              typename=[1822:1830] 〈uint32_t〉,
                              preComment=None,
                              postComment=Token(idx=25, range=(1840, 1857), value='/* Entry count */'),
                              end=';'),
                     Variable(name=Token(idx=31, range=(1872, 1880), value='objectid'),
                              typename=[1863:1871] 〈uint32_t〉,
                              preComment=None,
                              postComment=Token(idx=34, range=(1882, 1905), value='/* Written object ID */'),
                              end=';'),
                     Variable(name=Token(idx=39, range=(1919, 1925), value='offset'),
                              typename=[1910:1918] 〈wt_off_t〉,
                              preComment=None,
                              postComment=Token(idx=42, range=(1929, 1956), value='/* Written extent offset */'),
                              end=';'),
                     Variable(name=Token(idx=47, range=(1970, 1978), value='checksum'),
                              typename=[1961:1969] 〈uint32_t〉,
                              preComment=None,
                              postComment=Token(idx=50, range=(1980, 2009), value='/* Written extent checksum */'),
                              end=';'),
                     Variable(name=Token(idx=55, range=(2023, 2027), value='size'),
                              typename=[2014:2022] 〈uint32_t〉,
                              preComment=None,
                              postComment=Token(idx=58, range=(2033, 2058), value='/* Written extent size */'),
                              end=';'),
                     Variable(name=Token(idx=64, range=(2069, 2079), value='track_size'),
                              typename=[2064:2068] 〈bool〉,
                              preComment=None,
                              postComment=Token(idx=67, range=(2081, 2113), value='/* Maintain per-size skiplist */'),
                              end=';'),
                     Variable(name=Token(idx=74, range=(2127, 2131), value='last'),
                              typename=[2119:2125] 〈WT_EXT〉,
                              preComment=None,
                              postComment=Token(idx=77, range=(2133, 2158), value='/* Cached last element */'),
                              end=';'),
                     Variable(name=Token(idx=84, range=(2172, 2175), value='off'),
                              typename=[2164:2170] 〈WT_EXT〉,
                              preComment=None,
                              postComment=Token(idx=88, range=(2195, 2222), value='/* Size/offset skiplists */'),
                              end=';'),
                     Variable(name=Token(idx=94, range=(2236, 2238), value='sz'),
                              typename=[2227:2234] 〈WT_SIZE〉,
                              preComment=None,
                              postComment=None,
                              end=';')],
            typedefs=None,
            vardefs=[],
            preComment=Token(idx=15, range=(1686, 1728), value='/*\n * WT_EXTLIST --\n *\tAn extent list.\n */'),
            postComment=None,
            nested=None,
            parent=None,
            is_unnamed=False)
Statement(tokens=[2261:2784] 〈
⌇/*
 * WT_EXT --
 *	Encapsulation of an extent, either allocated or freed within the
 * checkpoint.
 */⌇
⌇struct⌇ ⌇__wt_ext⌇ ⌇{
    wt_off_t off;  /* Extent's file offset */
    wt_off_t size; /* Extent's Size */

    uint8_t depth; /* Skip list depth */

    /*
     * Variable-length array, sized by the number of skiplist elements. The first depth array
     * entries are the address skiplist elements, the second depth array entries are the size
     * skiplist.
     */
    WT_EXT *next[0]; /* Offset, size skiplists */
}⌇;⌇
〉,
          kind=StatementKind(is_comment=True,
                             is_preproc=None,
                             is_typedef=None,
                             is_record=True,
                             is_function=None,
                             is_function_def=None,
                             is_function_decl=None,
                             is_statement=None,
                             is_decl=None,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=Token(idx=25,
                                              range=(2262, 2364),
                                              value='/*\n'
                                                    ' * WT_EXT --\n'
                                                    ' *\tEncapsulation of an extent, either allocated or freed within '
                                                    'the\n'
                                                    ' * checkpoint.\n'
                                                    ' */'),
                             postComment=None))
Record:
RecordParts(recordKind=<RecordKind.STRUCT: 1>,
            name=Token(idx=29, range=(2372, 2380), value='__wt_ext'),
            typename=[2372:2380] 〈__wt_ext〉,
            body=Token(idx=31,
                       range=(2382, 2781),
                       value='\n'
                             "    wt_off_t off;  /* Extent's file offset */\n"
                             "    wt_off_t size; /* Extent's Size */\n"
                             '\n'
                             '    uint8_t depth; /* Skip list depth */\n'
                             '\n'
                             '    /*\n'
                             '     * Variable-length array, sized by the number of skiplist elements. The first depth '
                             'array\n'
                             '     * entries are the address skiplist elements, the second depth array entries are the '
                             'size\n'
                             '     * skiplist.\n'
                             '     */\n'
                             '    WT_EXT *next[0]; /* Offset, size skiplists */\n'),
            members=[Variable(name=Token(idx=4, range=(2396, 2399), value='off'),
                              typename=[2387:2395] 〈wt_off_t〉,
                              preComment=None,
                              postComment=Token(idx=7, range=(2402, 2428), value="/* Extent's file offset */"),
                              end=';'),
                     Variable(name=Token(idx=12, range=(2442, 2446), value='size'),
                              typename=[2433:2441] 〈wt_off_t〉,
                              preComment=None,
                              postComment=Token(idx=15, range=(2448, 2467), value="/* Extent's Size */"),
                              end=';'),
                     Variable(name=Token(idx=21, range=(2481, 2486), value='depth'),
                              typename=[2473:2480] 〈uint8_t〉,
                              preComment=None,
                              postComment=Token(idx=24, range=(2488, 2509), value='/* Skip list depth */'),
                              end=';'),
                     Variable(name=Token(idx=34, range=(2743, 2747), value='next'),
                              typename=[2735:2741] 〈WT_EXT〉,
                              preComment=Token(idx=28,
                                               range=(2515, 2730),
                                               value='/*\n'
                                                     '     * Variable-length array, sized by the number of skiplist '
                                                     'elements. The first depth array\n'
                                                     '     * entries are the address skiplist elements, the second '
                                                     'depth array entries are the size\n'
                                                     '     * skiplist.\n'
                                                     '     */'),
                              postComment=Token(idx=38, range=(2752, 2780), value='/* Offset, size skiplists */'),
                              end=';')],
            typedefs=None,
            vardefs=[],
            preComment=Token(idx=25,
                             range=(2262, 2364),
                             value='/*\n'
                                   ' * WT_EXT --\n'
                                   ' *\tEncapsulation of an extent, either allocated or freed within the\n'
                                   ' * checkpoint.\n'
                                   ' */'),
            postComment=None,
            nested=None,
            parent=None,
            is_unnamed=False)
Statement(tokens=[2784:3304] 〈
⌇/*
 * WT_SIZE --
 *	Encapsulation of a block size skiplist entry.
 */⌇
⌇struct⌇ ⌇__wt_size⌇ ⌇{
    wt_off_t size; /* Size */

    uint8_t depth; /* Skip list depth */

    WT_EXT *off[WT_SKIP_MAXDEPTH]; /* Per-size offset skiplist */

    /*
     * We don't use a variable-length array for the size skiplist, we want to be able to use any
     * cached WT_SIZE structure as the head of a list, and we don't know the related WT_EXT
     * structure's depth.
     */
    WT_SIZE *next[WT_SKIP_MAXDEPTH]; /* Size skiplist */
}⌇;⌇
〉,
          kind=StatementKind(is_comment=True,
                             is_preproc=None,
                             is_typedef=None,
                             is_record=True,
                             is_function=None,
                             is_function_def=None,
                             is_function_decl=None,
                             is_statement=None,
                             is_decl=None,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=Token(idx=35,
                                              range=(2785, 2854),
                                              value='/*\n'
                                                    ' * WT_SIZE --\n'
                                                    ' *\tEncapsulation of a block size skiplist entry.\n'
                                                    ' */'),
                             postComment=None))
Record:
RecordParts(recordKind=<RecordKind.STRUCT: 1>,
            name=Token(idx=39, range=(2862, 2871), value='__wt_size'),
            typename=[2862:2871] 〈__wt_size〉,
            body=Token(idx=41,
                       range=(2873, 3301),
                       value='\n'
                             '    wt_off_t size; /* Size */\n'
                             '\n'
                             '    uint8_t depth; /* Skip list depth */\n'
                             '\n'
                             '    WT_EXT *off[WT_SKIP_MAXDEPTH]; /* Per-size offset skiplist */\n'
                             '\n'
                             '    /*\n'
                             "     * We don't use a variable-length array for the size skiplist, we want to be able to "
                             'use any\n'
                             "     * cached WT_SIZE structure as the head of a list, and we don't know the related "
                             'WT_EXT\n'
                             "     * structure's depth.\n"
                             '     */\n'
                             '    WT_SIZE *next[WT_SKIP_MAXDEPTH]; /* Size skiplist */\n'),
            members=[Variable(name=Token(idx=4, range=(2887, 2891), value='size'),
                              typename=[2878:2886] 〈wt_off_t〉,
                              preComment=None,
                              postComment=Token(idx=7, range=(2893, 2903), value='/* Size */'),
                              end=';'),
                     Variable(name=Token(idx=13, range=(2917, 2922), value='depth'),
                              typename=[2909:2916] 〈uint8_t〉,
                              preComment=None,
                              postComment=Token(idx=16, range=(2924, 2945), value='/* Skip list depth */'),
                              end=';'),
                     Variable(name=Token(idx=23, range=(2959, 2962), value='off'),
                              typename=[2951:2957] 〈WT_EXT〉,
                              preComment=None,
                              postComment=Token(idx=27, range=(2982, 3012), value='/* Per-size offset skiplist */'),
                              end=';'),
                     Variable(name=Token(idx=37, range=(3257, 3261), value='next'),
                              typename=[3248:3255] 〈WT_SIZE〉,
                              preComment=Token(idx=31,
                                               range=(3018, 3243),
                                               value='/*\n'
                                                     "     * We don't use a variable-length array for the size "
                                                     'skiplist, we want to be able to use any\n'
                                                     '     * cached WT_SIZE structure as the head of a list, and we '
                                                     "don't know the related WT_EXT\n"
                                                     "     * structure's depth.\n"
                                                     '     */'),
                              postComment=Token(idx=41, range=(3281, 3300), value='/* Size skiplist */'),
                              end=';')],
            typedefs=None,
            vardefs=[],
            preComment=Token(idx=35,
                             range=(2785, 2854),
                             value='/*\n * WT_SIZE --\n *\tEncapsulation of a block size skiplist entry.\n */'),
            postComment=None,
            nested=None,
            parent=None,
            is_unnamed=False)
Statement(tokens=[3304:3591] 〈
⌇/*
 * Per session handle cached block manager information.
 */⌇
⌇typedef⌇ ⌇struct⌇ ⌇{
    WT_EXT *ext_cache;   /* List of WT_EXT handles */
    u_int ext_cache_cnt; /* Count */

    WT_SIZE *sz_cache;  /* List of WT_SIZE handles */
    u_int sz_cache_cnt; /* Count */
}⌇ ⌇WT_BLOCK_MGR_SESSION⌇;⌇
〉,
          kind=StatementKind(is_comment=True,
                             is_preproc=None,
                             is_typedef=True,
                             is_record=True,
                             is_function=None,
                             is_function_def=None,
                             is_function_decl=None,
                             is_statement=None,
                             is_decl=None,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=Token(idx=45,
                                              range=(3305, 3367),
                                              value='/*\n * Per session handle cached block manager information.\n */'),
                             postComment=None))
Record:
RecordParts(recordKind=<RecordKind.STRUCT: 1>,
            name=Token(idx=51, range=(3384, 3567), value='(data/block.h:0:3384:)'),
            typename=[3384:3567] 〈(data/block.h:0:3384:)〉,
            body=Token(idx=51,
                       range=(3384, 3567),
                       value='\n'
                             '    WT_EXT *ext_cache;   /* List of WT_EXT handles */\n'
                             '    u_int ext_cache_cnt; /* Count */\n'
                             '\n'
                             '    WT_SIZE *sz_cache;  /* List of WT_SIZE handles */\n'
                             '    u_int sz_cache_cnt; /* Count */\n'),
            members=[Variable(name=Token(idx=5, range=(3397, 3406), value='ext_cache'),
                              typename=[3389:3395] 〈WT_EXT〉,
                              preComment=None,
                              postComment=Token(idx=8, range=(3410, 3438), value='/* List of WT_EXT handles */'),
                              end=';'),
                     Variable(name=Token(idx=13, range=(3449, 3462), value='ext_cache_cnt'),
                              typename=[3443:3448] 〈u_int〉,
                              preComment=None,
                              postComment=Token(idx=16, range=(3464, 3475), value='/* Count */'),
                              end=';'),
                     Variable(name=Token(idx=23, range=(3490, 3498), value='sz_cache'),
                              typename=[3481:3488] 〈WT_SIZE〉,
                              preComment=None,
                              postComment=Token(idx=26, range=(3501, 3530), value='/* List of WT_SIZE handles */'),
                              end=';'),
                     Variable(name=Token(idx=31, range=(3541, 3553), value='sz_cache_cnt'),
                              typename=[3535:3540] 〈u_int〉,
                              preComment=None,
                              postComment=Token(idx=34, range=(3555, 3566), value='/* Count */'),
                              end=';')],
            typedefs=[Variable(name=Token(idx=53, range=(3569, 3589), value='WT_BLOCK_MGR_SESSION'),
                               typename=[3384:3567] 〈(data/block.h:0:3384:)〉,
                               preComment=None,
                               postComment=None,
                               end=';')],
            vardefs=None,
            preComment=Token(idx=45,
                             range=(3305, 3367),
                             value='/*\n * Per session handle cached block manager information.\n */'),
            postComment=None,
            nested=None,
            parent=None,
            is_unnamed=False)
Statement(tokens=[3591:3878] 〈
⌇/*
 * WT_EXT_FOREACH --
 *	Walk a block manager skiplist.
 * WT_EXT_FOREACH_OFF --
 *	Walk a block manager skiplist where the WT_EXT.next entries are offset
 * by the depth.
 */⌇
⌇#define WT_EXT_FOREACH(skip, head) \
    for ((skip) = (head)[0]; (skip) != NULL; (skip) = (skip)->next[0])
〉,
          kind=StatementKind(is_comment=True,
                             is_preproc=True,
                             is_typedef=None,
                             is_record=None,
                             is_function=None,
                             is_function_def=None,
                             is_function_decl=None,
                             is_statement=None,
                             is_decl=None,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=Token(idx=57,
                                              range=(3592, 3769),
                                              value='/*\n'
                                                    ' * WT_EXT_FOREACH --\n'
                                                    ' *\tWalk a block manager skiplist.\n'
                                                    ' * WT_EXT_FOREACH_OFF --\n'
                                                    ' *\tWalk a block manager skiplist where the WT_EXT.next entries '
                                                    'are offset\n'
                                                    ' * by the depth.\n'
                                                    ' */'),
                             postComment=None))
Macro:
MacroParts(name=Token(idx=0, range=(3778, 3792), value='WT_EXT_FOREACH'),
           args=[Token(idx=0, range=(3793, 3797), value='skip'), Token(idx=1, range=(3799, 3803), value='head')],
           body=Token(idx=0,
                      range=(3805, 3878),
                      value='for ((skip) = (head)[0]; (skip) != NULL; (skip) = (skip)->next[0])'),
           preComment=Token(idx=57,
                            range=(3592, 3769),
                            value='/*\n'
                                  ' * WT_EXT_FOREACH --\n'
                                  ' *\tWalk a block manager skiplist.\n'
                                  ' * WT_EXT_FOREACH_OFF --\n'
                                  ' *\tWalk a block manager skiplist where the WT_EXT.next entries are offset\n'
                                  ' * by the depth.\n'
                                  ' */'),
           is_va_args=False,
           is_wellformed=True,
           is_const=False)
Statement(tokens=[3878:4002] 〈#define WT_EXT_FOREACH_OFF(skip, head) \
    for ((skip) = (head)[0]; (skip) != NULL; (skip) = (skip)->next[(skip)->depth])
〉,
          kind=StatementKind(is_comment=None,
                             is_preproc=True,
                             is_typedef=None,
                             is_record=None,
                             is_function=None,
                             is_function_def=None,
                             is_function_decl=None,
                             is_statement=None,
                             is_decl=None,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=None,
                             postComment=None))
Macro:
MacroParts(name=Token(idx=0, range=(3886, 3904), value='WT_EXT_FOREACH_OFF'),
           args=[Token(idx=0, range=(3905, 3909), value='skip'), Token(idx=1, range=(3911, 3915), value='head')],
           body=Token(idx=0,
                      range=(3917, 4002),
                      value='for ((skip) = (head)[0]; (skip) != NULL; (skip) = (skip)->next[(skip)->depth])'),
           preComment=None,
           is_va_args=False,
           is_wellformed=True,
           is_const=False)
Statement(tokens=[4002:4372] 〈
⌇/*
 * WT_EXT_FOREACH_FROM_OFFSET_INCL --
 *	Walk a by-offset skiplist from the given offset, starting with the extent that contains the
 * given offset if available.
 */⌇
⌇#define WT_EXT_FOREACH_FROM_OFFSET_INCL(skip, el, start)                        \
    for ((skip) = __wt_block_off_srch_inclusive((el), (start)); (skip) != NULL; \
         (skip) = (skip)->next[0])
〉,
          kind=StatementKind(is_comment=True,
                             is_preproc=True,
                             is_typedef=None,
                             is_record=None,
                             is_function=None,
                             is_function_def=None,
                             is_function_decl=None,
                             is_statement=None,
                             is_decl=None,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=Token(idx=62,
                                              range=(4003, 4172),
                                              value='/*\n'
                                                    ' * WT_EXT_FOREACH_FROM_OFFSET_INCL --\n'
                                                    ' *\tWalk a by-offset skiplist from the given offset, starting '
                                                    'with the extent that contains the\n'
                                                    ' * given offset if available.\n'
                                                    ' */'),
                             postComment=None))
Macro:
MacroParts(name=Token(idx=0, range=(4181, 4212), value='WT_EXT_FOREACH_FROM_OFFSET_INCL'),
           args=[Token(idx=0, range=(4213, 4217), value='skip'),
                 Token(idx=1, range=(4219, 4221), value='el'),
                 Token(idx=2, range=(4223, 4228), value='start')],
           body=Token(idx=0,
                      range=(4253, 4372),
                      value='for ((skip) = __wt_block_off_srch_inclusive((el), (start)); (skip) != NULL;  \n'
                            '         (skip) = (skip)->next[0])'),
           preComment=Token(idx=62,
                            range=(4003, 4172),
                            value='/*\n'
                                  ' * WT_EXT_FOREACH_FROM_OFFSET_INCL --\n'
                                  ' *\tWalk a by-offset skiplist from the given offset, starting with the extent that '
                                  'contains the\n'
                                  ' * given offset if available.\n'
                                  ' */'),
           is_va_args=False,
           is_wellformed=True,
           is_const=False)
Statement(tokens=[4372:4764] 〈
⌇/*
 * Checkpoint cookie: carries a version number as I don't want to rev the schema
 * file version should the default block manager checkpoint format change.
 *
 * Version #1 checkpoint cookie format:
 *	[1] [root addr] [alloc addr] [avail addr] [discard addr]
 *	    [file size] [checkpoint size] [write generation]
 */⌇
⌇#define WT_BM_CHECKPOINT_VERSION 1   /* Checkpoint format version */
〉,
          kind=StatementKind(is_comment=True,
                             is_preproc=True,
                             is_typedef=None,
                             is_record=None,
                             is_function=None,
                             is_function_def=None,
                             is_function_decl=None,
                             is_statement=None,
                             is_decl=None,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=Token(idx=66,
                                              range=(4373, 4694),
                                              value='/*\n'
                                                    " * Checkpoint cookie: carries a version number as I don't want to "
                                                    'rev the schema\n'
                                                    ' * file version should the default block manager checkpoint '
                                                    'format change.\n'
                                                    ' *\n'
                                                    ' * Version #1 checkpoint cookie format:\n'
                                                    ' *\t[1] [root addr] [alloc addr] [avail addr] [discard addr]\n'
                                                    ' *\t    [file size] [checkpoint size] [write generation]\n'
                                                    ' */'),
                             postComment=None))
Macro:
MacroParts(name=Token(idx=0, range=(4703, 4727), value='WT_BM_CHECKPOINT_VERSION'),
           args=None,
           body=Token(idx=0, range=(4728, 4764), value='1                                  '),
           preComment=Token(idx=66,
                            range=(4373, 4694),
                            value='/*\n'
                                  " * Checkpoint cookie: carries a version number as I don't want to rev the schema\n"
                                  ' * file version should the default block manager checkpoint format change.\n'
                                  ' *\n'
                                  ' * Version #1 checkpoint cookie format:\n'
                                  ' *\t[1] [root addr] [alloc addr] [avail addr] [discard addr]\n'
                                  ' *\t    [file size] [checkpoint size] [write generation]\n'
                                  ' */'),
           is_va_args=False,
           is_wellformed=True,
           is_const=True)
Statement(tokens=[4764:4823] 〈#define WT_BLOCK_EXTLIST_MAGIC 71002 /* Identify a list */
〉,
          kind=StatementKind(is_comment=None,
                             is_preproc=True,
                             is_typedef=None,
                             is_record=None,
                             is_function=None,
                             is_function_def=None,
                             is_function_decl=None,
                             is_statement=None,
                             is_decl=None,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=None,
                             postComment=None))
Macro:
MacroParts(name=Token(idx=0, range=(4772, 4794), value='WT_BLOCK_EXTLIST_MAGIC'),
           args=None,
           body=Token(idx=0, range=(4795, 4823), value='71002                      '),
           preComment=None,
           is_va_args=False,
           is_wellformed=True,
           is_const=True)
Statement(tokens=[4823:5060] 〈
⌇/*
 * There are two versions of the extent list blocks: the original, and a second version where
 * current checkpoint information is appended to the avail extent list.
 */⌇
⌇#define WT_BLOCK_EXTLIST_VERSION_ORIG 0 /* Original version */
〉,
          kind=StatementKind(is_comment=True,
                             is_preproc=True,
                             is_typedef=None,
                             is_record=None,
                             is_function=None,
                             is_function_def=None,
                             is_function_decl=None,
                             is_statement=None,
                             is_decl=None,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=Token(idx=71,
                                              range=(4824, 4996),
                                              value='/*\n'
                                                    ' * There are two versions of the extent list blocks: the '
                                                    'original, and a second version where\n'
                                                    ' * current checkpoint information is appended to the avail extent '
                                                    'list.\n'
                                                    ' */'),
                             postComment=None))
Macro:
MacroParts(name=Token(idx=0, range=(5005, 5034), value='WT_BLOCK_EXTLIST_VERSION_ORIG'),
           args=None,
           body=Token(idx=0, range=(5035, 5060), value='0                       '),
           preComment=Token(idx=71,
                            range=(4824, 4996),
                            value='/*\n'
                                  ' * There are two versions of the extent list blocks: the original, and a second '
                                  'version where\n'
                                  ' * current checkpoint information is appended to the avail extent list.\n'
                                  ' */'),
           is_va_args=False,
           is_wellformed=True,
           is_const=True)
Statement(tokens=[5060:5133] 〈#define WT_BLOCK_EXTLIST_VERSION_CKPT 1 /* Checkpoint in avail output */
〉,
          kind=StatementKind(is_comment=None,
                             is_preproc=True,
                             is_typedef=None,
                             is_record=None,
                             is_function=None,
                             is_function_def=None,
                             is_function_decl=None,
                             is_statement=None,
                             is_decl=None,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=None,
                             postComment=None))
Macro:
MacroParts(name=Token(idx=0, range=(5068, 5097), value='WT_BLOCK_EXTLIST_VERSION_CKPT'),
           args=None,
           body=Token(idx=0, range=(5098, 5133), value='1                                 '),
           preComment=None,
           is_va_args=False,
           is_wellformed=True,
           is_const=True)
Statement(tokens=[5133:5309] 〈
⌇/*
 * Maximum buffer required to store a checkpoint: 1 version byte followed by
 * 14 packed 8B values.
 */⌇
⌇#define WT_BLOCK_CHECKPOINT_BUFFER (1 + 14 * WT_INTPACK64_MAXSIZE)
〉,
          kind=StatementKind(is_comment=True,
                             is_preproc=True,
                             is_typedef=None,
                             is_record=None,
                             is_function=None,
                             is_function_def=None,
                             is_function_decl=None,
                             is_statement=None,
                             is_decl=None,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=Token(idx=76,
                                              range=(5134, 5241),
                                              value='/*\n'
                                                    ' * Maximum buffer required to store a checkpoint: 1 version byte '
                                                    'followed by\n'
                                                    ' * 14 packed 8B values.\n'
                                                    ' */'),
                             postComment=None))
Macro:
MacroParts(name=Token(idx=0, range=(5250, 5276), value='WT_BLOCK_CHECKPOINT_BUFFER'),
           args=None,
           body=Token(idx=0, range=(5277, 5309), value='(1 + 14 * WT_INTPACK64_MAXSIZE)'),
           preComment=Token(idx=76,
                            range=(5134, 5241),
                            value='/*\n'
                                  ' * Maximum buffer required to store a checkpoint: 1 version byte followed by\n'
                                  ' * 14 packed 8B values.\n'
                                  ' */'),
           is_va_args=False,
           is_wellformed=True,
           is_const=False)
Statement(tokens=[5309:6183] 〈
⌇struct⌇ ⌇__wt_block_ckpt⌇ ⌇{
    uint8_t version; /* Version */

    uint32_t root_objectid;
    wt_off_t root_offset; /* The root */
    uint32_t root_checksum, root_size;

    WT_EXTLIST alloc;   /* Extents allocated */
    WT_EXTLIST avail;   /* Extents available */
    WT_EXTLIST discard; /* Extents discarded */

    wt_off_t file_size; /* Checkpoint file size */
    uint64_t ckpt_size; /* Checkpoint byte count */

    WT_EXTLIST ckpt_avail; /* Checkpoint free'd extents */

    /*
     * Checkpoint archive: the block manager may potentially free a lot of memory from the
     * allocation and discard extent lists when checkpoint completes. Put it off until the
     * checkpoint resolves, that lets the upper btree layer continue eviction sooner.
     */
    WT_EXTLIST ckpt_alloc;   /* Checkpoint archive */
    WT_EXTLIST ckpt_discard; /* Checkpoint archive */
}⌇;⌇
〉,
          kind=StatementKind(is_comment=None,
                             is_preproc=None,
                             is_typedef=None,
                             is_record=True,
                             is_function=None,
                             is_function_def=None,
                             is_function_decl=None,
                             is_statement=None,
                             is_decl=None,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=None,
                             postComment=None))
Record:
RecordParts(recordKind=<RecordKind.STRUCT: 1>,
            name=Token(idx=82, range=(5317, 5332), value='__wt_block_ckpt'),
            typename=[5317:5332] 〈__wt_block_ckpt〉,
            body=Token(idx=84,
                       range=(5334, 6180),
                       value='\n'
                             '    uint8_t version; /* Version */\n'
                             '\n'
                             '    uint32_t root_objectid;\n'
                             '    wt_off_t root_offset; /* The root */\n'
                             '    uint32_t root_checksum, root_size;\n'
                             '\n'
                             '    WT_EXTLIST alloc;   /* Extents allocated */\n'
                             '    WT_EXTLIST avail;   /* Extents available */\n'
                             '    WT_EXTLIST discard; /* Extents discarded */\n'
                             '\n'
                             '    wt_off_t file_size; /* Checkpoint file size */\n'
                             '    uint64_t ckpt_size; /* Checkpoint byte count */\n'
                             '\n'
                             "    WT_EXTLIST ckpt_avail; /* Checkpoint free'd extents */\n"
                             '\n'
                             '    /*\n'
                             '     * Checkpoint archive: the block manager may potentially free a lot of memory from '
                             'the\n'
                             '     * allocation and discard extent lists when checkpoint completes. Put it off until '
                             'the\n'
                             '     * checkpoint resolves, that lets the upper btree layer continue eviction sooner.\n'
                             '     */\n'
                             '    WT_EXTLIST ckpt_alloc;   /* Checkpoint archive */\n'
                             '    WT_EXTLIST ckpt_discard; /* Checkpoint archive */\n'),
            members=[Variable(name=Token(idx=4, range=(5347, 5354), value='version'),
                              typename=[5339:5346] 〈uint8_t〉,
                              preComment=None,
                              postComment=Token(idx=7, range=(5356, 5369), value='/* Version */'),
                              end=';'),
                     Variable(name=Token(idx=13, range=(5384, 5397), value='root_objectid'),
                              typename=[5375:5383] 〈uint32_t〉,
                              preComment=None,
                              postComment=None,
                              end=';'),
                     Variable(name=Token(idx=19, range=(5412, 5423), value='root_offset'),
                              typename=[5403:5411] 〈wt_off_t〉,
                              preComment=None,
                              postComment=Token(idx=22, range=(5425, 5439), value='/* The root */'),
                              end=';'),
                     Variable(name=Token(idx=27, range=(5453, 5466), value='root_checksum'),
                              typename=[5444:5452] 〈uint32_t〉,
                              preComment=None,
                              postComment=None,
                              end=','),
                     Variable(name=Token(idx=30, range=(5468, 5477), value='root_size'),
                              typename=[5444:5452] 〈uint32_t〉,
                              preComment=None,
                              postComment=None,
                              end=';'),
                     Variable(name=Token(idx=37, range=(5495, 5500), value='alloc'),
                              typename=[5484:5494] 〈WT_EXTLIST〉,
                              preComment=None,
                              postComment=Token(idx=40, range=(5504, 5527), value='/* Extents allocated */'),
                              end=';'),
                     Variable(name=Token(idx=45, range=(5543, 5548), value='avail'),
                              typename=[5532:5542] 〈WT_EXTLIST〉,
                              preComment=None,
                              postComment=Token(idx=48, range=(5552, 5575), value='/* Extents available */'),
                              end=';'),
                     Variable(name=Token(idx=53, range=(5591, 5598), value='discard'),
                              typename=[5580:5590] 〈WT_EXTLIST〉,
                              preComment=None,
                              postComment=Token(idx=56, range=(5600, 5623), value='/* Extents discarded */'),
                              end=';'),
                     Variable(name=Token(idx=62, range=(5638, 5647), value='file_size'),
                              typename=[5629:5637] 〈wt_off_t〉,
                              preComment=None,
                              postComment=Token(idx=65, range=(5649, 5675), value='/* Checkpoint file size */'),
                              end=';'),
                     Variable(name=Token(idx=70, range=(5689, 5698), value='ckpt_size'),
                              typename=[5680:5688] 〈uint64_t〉,
                              preComment=None,
                              postComment=Token(idx=73, range=(5700, 5727), value='/* Checkpoint byte count */'),
                              end=';'),
                     Variable(name=Token(idx=79, range=(5744, 5754), value='ckpt_avail'),
                              typename=[5733:5743] 〈WT_EXTLIST〉,
                              preComment=None,
                              postComment=Token(idx=82, range=(5756, 5787), value="/* Checkpoint free'd extents */"),
                              end=';'),
                     Variable(name=Token(idx=91, range=(6087, 6097), value='ckpt_alloc'),
                              typename=[6076:6086] 〈WT_EXTLIST〉,
                              preComment=Token(idx=86,
                                               range=(5793, 6071),
                                               value='/*\n'
                                                     '     * Checkpoint archive: the block manager may potentially '
                                                     'free a lot of memory from the\n'
                                                     '     * allocation and discard extent lists when checkpoint '
                                                     'completes. Put it off until the\n'
                                                     '     * checkpoint resolves, that lets the upper btree layer '
                                                     'continue eviction sooner.\n'
                                                     '     */'),
                              postComment=Token(idx=94, range=(6101, 6125), value='/* Checkpoint archive */'),
                              end=';'),
                     Variable(name=Token(idx=99, range=(6141, 6153), value='ckpt_discard'),
                              typename=[6130:6140] 〈WT_EXTLIST〉,
                              preComment=None,
                              postComment=Token(idx=102, range=(6155, 6179), value='/* Checkpoint archive */'),
                              end=';')],
            typedefs=None,
            vardefs=[],
            preComment=None,
            postComment=None,
            nested=None,
            parent=None,
            is_unnamed=False)
Statement(tokens=[6183:9959] 〈
⌇/*
 * WT_BM --
 *	Block manager handle, references a single checkpoint in a btree.
 */⌇
⌇struct⌇ ⌇__wt_bm⌇ ⌇{
    /* Methods */
    int (*addr_invalid)(WT_BM *, WT_SESSION_IMPL *, const uint8_t *, size_t);
    int (*addr_string)(WT_BM *, WT_SESSION_IMPL *, WT_ITEM *, const uint8_t *, size_t);
    u_int (*block_header)(WT_BM *);
    int (*checkpoint)(WT_BM *, WT_SESSION_IMPL *, WT_ITEM *, WT_CKPT *, bool);
    int (*checkpoint_last)(WT_BM *, WT_SESSION_IMPL *, char **, char **, WT_ITEM *);
    int (*checkpoint_load)(
      WT_BM *, WT_SESSION_IMPL *, const uint8_t *, size_t, uint8_t *, size_t *, bool);
    int (*checkpoint_resolve)(WT_BM *, WT_SESSION_IMPL *, bool);
    int (*checkpoint_start)(WT_BM *, WT_SESSION_IMPL *);
    int (*checkpoint_unload)(WT_BM *, WT_SESSION_IMPL *);
    int (*close)(WT_BM *, WT_SESSION_IMPL *);
    int (*compact_end)(WT_BM *, WT_SESSION_IMPL *);
    int (*compact_page_rewrite)(WT_BM *, WT_SESSION_IMPL *, uint8_t *, size_t *, bool *);
    int (*compact_page_skip)(WT_BM *, WT_SESSION_IMPL *, const uint8_t *, size_t, bool *);
    int (*compact_skip)(WT_BM *, WT_SESSION_IMPL *, bool *);
    void (*compact_progress)(WT_BM *, WT_SESSION_IMPL *);
    int (*compact_start)(WT_BM *, WT_SESSION_IMPL *);
    int (*corrupt)(WT_BM *, WT_SESSION_IMPL *, const uint8_t *, size_t);
    int (*free)(WT_BM *, WT_SESSION_IMPL *, const uint8_t *, size_t);
    bool (*is_mapped)(WT_BM *, WT_SESSION_IMPL *);
    int (*map_discard)(WT_BM *, WT_SESSION_IMPL *, void *, size_t);
    int (*read)(WT_BM *, WT_SESSION_IMPL *, WT_ITEM *, const uint8_t *, size_t);
    int (*salvage_end)(WT_BM *, WT_SESSION_IMPL *);
    int (*salvage_next)(WT_BM *, WT_SESSION_IMPL *, uint8_t *, size_t *, bool *);
    int (*salvage_start)(WT_BM *, WT_SESSION_IMPL *);
    int (*salvage_valid)(WT_BM *, WT_SESSION_IMPL *, uint8_t *, size_t, bool);
    int (*size)(WT_BM *, WT_SESSION_IMPL *, wt_off_t *);
    int (*stat)(WT_BM *, WT_SESSION_IMPL *, WT_DSRC_STATS *stats);
    int (*switch_object)(WT_BM *, WT_SESSION_IMPL *, uint32_t);
    int (*switch_object_end)(WT_BM *, WT_SESSION_IMPL *, uint32_t);
    int (*sync)(WT_BM *, WT_SESSION_IMPL *, bool);
    int (*verify_addr)(WT_BM *, WT_SESSION_IMPL *, const uint8_t *, size_t);
    int (*verify_end)(WT_BM *, WT_SESSION_IMPL *);
    int (*verify_start)(WT_BM *, WT_SESSION_IMPL *, WT_CKPT *, const char *[]);
    int (*write)(WT_BM *, WT_SESSION_IMPL *, WT_ITEM *, uint8_t *, size_t *, bool, bool);
    int (*write_size)(WT_BM *, WT_SESSION_IMPL *, size_t *);

    WT_BLOCK *block; /* Underlying file. For a multi-handle tree this will be the writable file. */
    WT_BLOCK *next_block; /* If doing a tier switch, this is going to be the new file. */
    WT_BLOCK *prev_block; /* If a tier switch was done, this was the old file. */

    void *map; /* Mapped region */
    size_t maplen;
    void *mapped_cookie;

    /*
     * For trees, such as tiered tables, that are allowed to have more than one backing file or
     * object, we maintain an array of the block handles used by the tree. We use a reader-writer
     * mutex to protect the array. We lock it for reading when looking for a handle in the array and
     * lock it for writing when adding or removing handles in the array.
     */
    bool is_multi_handle;
    WT_BLOCK **handle_array;       /* Array of block handles */
    size_t handle_array_allocated; /* Size of handle array */
    WT_RWLOCK handle_array_lock;   /* Lock for block handle array */
    u_int handle_array_next;       /* Next open slot */
    uint32_t max_flushed_objectid; /* Local objects at or below this id should be closed */

    /*
     * There's only a single block manager handle that can be written, all others are checkpoints.
     */
    bool is_live; /* The live system */
}⌇;⌇
〉,
          kind=StatementKind(is_comment=True,
                             is_preproc=None,
                             is_typedef=None,
                             is_record=True,
                             is_function=None,
                             is_function_def=None,
                             is_function_decl=None,
                             is_statement=None,
                             is_decl=None,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=Token(idx=88,
                                              range=(6184, 6270),
                                              value='/*\n'
                                                    ' * WT_BM --\n'
                                                    ' *\tBlock manager handle, references a single checkpoint in a '
                                                    'btree.\n'
                                                    ' */'),
                             postComment=None))
Record:
RecordParts(recordKind=<RecordKind.STRUCT: 1>,
            name=Token(idx=92, range=(6278, 6285), value='__wt_bm'),
            typename=[6278:6285] 〈__wt_bm〉,
            body=Token(idx=94,
                       range=(6287, 9956),
                       value='\n'
                             '    /* Methods */\n'
                             '    int (*addr_invalid)(WT_BM *, WT_SESSION_IMPL *, const uint8_t *, size_t);\n'
                             '    int (*addr_string)(WT_BM *, WT_SESSION_IMPL *, WT_ITEM *, const uint8_t *, size_t);\n'
                             '    u_int (*block_header)(WT_BM *);\n'
                             '    int (*checkpoint)(WT_BM *, WT_SESSION_IMPL *, WT_ITEM *, WT_CKPT *, bool);\n'
                             '    int (*checkpoint_last)(WT_BM *, WT_SESSION_IMPL *, char **, char **, WT_ITEM *);\n'
                             '    int (*checkpoint_load)(\n'
                             '      WT_BM *, WT_SESSION_IMPL *, const uint8_t *, size_t, uint8_t *, size_t *, bool);\n'
                             '    int (*checkpoint_resolve)(WT_BM *, WT_SESSION_IMPL *, bool);\n'
                             '    int (*checkpoint_start)(WT_BM *, WT_SESSION_IMPL *);\n'
                             '    int (*checkpoint_unload)(WT_BM *, WT_SESSION_IMPL *);\n'
                             '    int (*close)(WT_BM *, WT_SESSION_IMPL *);\n'
                             '    int (*compact_end)(WT_BM *, WT_SESSION_IMPL *);\n'
                             '    int (*compact_page_rewrite)(WT_BM *, WT_SESSION_IMPL *, uint8_t *, size_t *, bool '
                             '*);\n'
                             '    int (*compact_page_skip)(WT_BM *, WT_SESSION_IMPL *, const uint8_t *, size_t, bool '
                             '*);\n'
                             '    int (*compact_skip)(WT_BM *, WT_SESSION_IMPL *, bool *);\n'
                             '    void (*compact_progress)(WT_BM *, WT_SESSION_IMPL *);\n'
                             '    int (*compact_start)(WT_BM *, WT_SESSION_IMPL *);\n'
                             '    int (*corrupt)(WT_BM *, WT_SESSION_IMPL *, const uint8_t *, size_t);\n'
                             '    int (*free)(WT_BM *, WT_SESSION_IMPL *, const uint8_t *, size_t);\n'
                             '    bool (*is_mapped)(WT_BM *, WT_SESSION_IMPL *);\n'
                             '    int (*map_discard)(WT_BM *, WT_SESSION_IMPL *, void *, size_t);\n'
                             '    int (*read)(WT_BM *, WT_SESSION_IMPL *, WT_ITEM *, const uint8_t *, size_t);\n'
                             '    int (*salvage_end)(WT_BM *, WT_SESSION_IMPL *);\n'
                             '    int (*salvage_next)(WT_BM *, WT_SESSION_IMPL *, uint8_t *, size_t *, bool *);\n'
                             '    int (*salvage_start)(WT_BM *, WT_SESSION_IMPL *);\n'
                             '    int (*salvage_valid)(WT_BM *, WT_SESSION_IMPL *, uint8_t *, size_t, bool);\n'
                             '    int (*size)(WT_BM *, WT_SESSION_IMPL *, wt_off_t *);\n'
                             '    int (*stat)(WT_BM *, WT_SESSION_IMPL *, WT_DSRC_STATS *stats);\n'
                             '    int (*switch_object)(WT_BM *, WT_SESSION_IMPL *, uint32_t);\n'
                             '    int (*switch_object_end)(WT_BM *, WT_SESSION_IMPL *, uint32_t);\n'
                             '    int (*sync)(WT_BM *, WT_SESSION_IMPL *, bool);\n'
                             '    int (*verify_addr)(WT_BM *, WT_SESSION_IMPL *, const uint8_t *, size_t);\n'
                             '    int (*verify_end)(WT_BM *, WT_SESSION_IMPL *);\n'
                             '    int (*verify_start)(WT_BM *, WT_SESSION_IMPL *, WT_CKPT *, const char *[]);\n'
                             '    int (*write)(WT_BM *, WT_SESSION_IMPL *, WT_ITEM *, uint8_t *, size_t *, bool, '
                             'bool);\n'
                             '    int (*write_size)(WT_BM *, WT_SESSION_IMPL *, size_t *);\n'
                             '\n'
                             '    WT_BLOCK *block; /* Underlying file. For a multi-handle tree this will be the '
                             'writable file. */\n'
                             '    WT_BLOCK *next_block; /* If doing a tier switch, this is going to be the new file. '
                             '*/\n'
                             '    WT_BLOCK *prev_block; /* If a tier switch was done, this was the old file. */\n'
                             '\n'
                             '    void *map; /* Mapped region */\n'
                             '    size_t maplen;\n'
                             '    void *mapped_cookie;\n'
                             '\n'
                             '    /*\n'
                             '     * For trees, such as tiered tables, that are allowed to have more than one backing '
                             'file or\n'
                             '     * object, we maintain an array of the block handles used by the tree. We use a '
                             'reader-writer\n'
                             '     * mutex to protect the array. We lock it for reading when looking for a handle in '
                             'the array and\n'
                             '     * lock it for writing when adding or removing handles in the array.\n'
                             '     */\n'
                             '    bool is_multi_handle;\n'
                             '    WT_BLOCK **handle_array;       /* Array of block handles */\n'
                             '    size_t handle_array_allocated; /* Size of handle array */\n'
                             '    WT_RWLOCK handle_array_lock;   /* Lock for block handle array */\n'
                             '    u_int handle_array_next;       /* Next open slot */\n'
                             '    uint32_t max_flushed_objectid; /* Local objects at or below this id should be closed '
                             '*/\n'
                             '\n'
                             '    /*\n'
                             "     * There's only a single block manager handle that can be written, all others are "
                             'checkpoints.\n'
                             '     */\n'
                             '    bool is_live; /* The live system */\n'),
            members=[Variable(name=Token(idx=7, range=(6314, 6329), value='addr_invalid'),
                              typename=[6310:6313] 〈int〉,
                              preComment=Token(idx=2, range=(6292, 6305), value='/* Methods */'),
                              postComment=None,
                              end=';'),
                     Variable(name=Token(idx=14, range=(6392, 6406), value='addr_string'),
                              typename=[6388:6391] 〈int〉,
                              preComment=None,
                              postComment=None,
                              end=';'),
                     Variable(name=Token(idx=21, range=(6482, 6497), value='block_header'),
                              typename=[6476:6481] 〈u_int〉,
                              preComment=None,
                              postComment=None,
                              end=';'),
                     Variable(name=Token(idx=28, range=(6516, 6529), value='checkpoint'),
                              typename=[6512:6515] 〈int〉,
                              preComment=None,
                              postComment=None,
                              end=';'),
                     Variable(name=Token(idx=35, range=(6595, 6613), value='checkpoint_last'),
                              typename=[6591:6594] 〈int〉,
                              preComment=None,
                              postComment=None,
                              end=';'),
                     Variable(name=Token(idx=42, range=(6680, 6698), value='checkpoint_load'),
                              typename=[6676:6679] 〈int〉,
                              preComment=None,
                              postComment=None,
                              end=';'),
                     Variable(name=Token(idx=49, range=(6795, 6816), value='checkpoint_resolve'),
                              typename=[6791:6794] 〈int〉,
                              preComment=None,
                              postComment=None,
                              end=';'),
                     Variable(name=Token(idx=56, range=(6860, 6879), value='checkpoint_start'),
                              typename=[6856:6859] 〈int〉,
                              preComment=None,
                              postComment=None,
                              end=';'),
                     Variable(name=Token(idx=63, range=(6917, 6937), value='checkpoint_unload'),
                              typename=[6913:6916] 〈int〉,
                              preComment=None,
                              postComment=None,
                              end=';'),
                     Variable(name=Token(idx=70, range=(6975, 6983), value='close'),
                              typename=[6971:6974] 〈int〉,
                              preComment=None,
                              postComment=None,
                              end=';'),
                     Variable(name=Token(idx=77, range=(7021, 7035), value='compact_end'),
                              typename=[7017:7020] 〈int〉,
                              preComment=None,
                              postComment=None,
                              end=';'),
                     Variable(name=Token(idx=84, range=(7073, 7096), value='compact_page_rewrite'),
                              typename=[7069:7072] 〈int〉,
                              preComment=None,
                              postComment=None,
                              end=';'),
                     Variable(name=Token(idx=91, range=(7163, 7183), value='compact_page_skip'),
                              typename=[7159:7162] 〈int〉,
                              preComment=None,
                              postComment=None,
                              end=';'),
                     Variable(name=Token(idx=98, range=(7254, 7269), value='compact_skip'),
                              typename=[7250:7253] 〈int〉,
                              preComment=None,
                              postComment=None,
                              end=';'),
                     Variable(name=Token(idx=105, range=(7316, 7335), value='compact_progress'),
                              typename=[7311:7315] 〈void〉,
                              preComment=None,
                              postComment=None,
                              end=';'),
                     Variable(name=Token(idx=112, range=(7373, 7389), value='compact_start'),
                              typename=[7369:7372] 〈int〉,
                              preComment=None,
                              postComment=None,
                              end=';'),
                     Variable(name=Token(idx=119, range=(7427, 7437), value='corrupt'),
                              typename=[7423:7426] 〈int〉,
                              preComment=None,
                              postComment=None,
                              end=';'),
                     Variable(name=Token(idx=126, range=(7500, 7507), value='free'),
                              typename=[7496:7499] 〈int〉,
                              preComment=None,
                              postComment=None,
                              end=';'),
                     Variable(name=Token(idx=133, range=(7571, 7583), value='is_mapped'),
                              typename=[7566:7570] 〈bool〉,
                              preComment=None,
                              postComment=None,
                              end=';'),
                     Variable(name=Token(idx=140, range=(7621, 7635), value='map_discard'),
                              typename=[7617:7620] 〈int〉,
                              preComment=None,
                              postComment=None,
                              end=';'),
                     Variable(name=Token(idx=147, range=(7689, 7696), value='read'),
                              typename=[7685:7688] 〈int〉,
                              preComment=None,
                              postComment=None,
                              end=';'),
                     Variable(name=Token(idx=154, range=(7770, 7784), value='salvage_end'),
                              typename=[7766:7769] 〈int〉,
                              preComment=None,
                              postComment=None,
                              end=';'),
                     Variable(name=Token(idx=161, range=(7822, 7837), value='salvage_next'),
                              typename=[7818:7821] 〈int〉,
                              preComment=None,
                              postComment=None,
                              end=';'),
                     Variable(name=Token(idx=168, range=(7904, 7920), value='salvage_start'),
                              typename=[7900:7903] 〈int〉,
                              preComment=None,
                              postComment=None,
                              end=';'),
                     Variable(name=Token(idx=175, range=(7958, 7974), value='salvage_valid'),
                              typename=[7954:7957] 〈int〉,
                              preComment=None,
                              postComment=None,
                              end=';'),
                     Variable(name=Token(idx=182, range=(8037, 8044), value='size'),
                              typename=[8033:8036] 〈int〉,
                              preComment=None,
                              postComment=None,
                              end=';'),
                     Variable(name=Token(idx=189, range=(8094, 8101), value='stat'),
                              typename=[8090:8093] 〈int〉,
                              preComment=None,
                              postComment=None,
                              end=';'),
                     Variable(name=Token(idx=196, range=(8161, 8177), value='switch_object'),
                              typename=[8157:8160] 〈int〉,
                              preComment=None,
                              postComment=None,
                              end=';'),
                     Variable(name=Token(idx=203, range=(8225, 8245), value='switch_object_end'),
                              typename=[8221:8224] 〈int〉,
                              preComment=None,
                              postComment=None,
                              end=';'),
                     Variable(name=Token(idx=210, range=(8293, 8300), value='sync'),
                              typename=[8289:8292] 〈int〉,
                              preComment=None,
                              postComment=None,
                              end=';'),
                     Variable(name=Token(idx=217, range=(8344, 8358), value='verify_addr'),
                              typename=[8340:8343] 〈int〉,
                              preComment=None,
                              postComment=None,
                              end=';'),
                     Variable(name=Token(idx=224, range=(8421, 8434), value='verify_end'),
                              typename=[8417:8420] 〈int〉,
                              preComment=None,
                              postComment=None,
                              end=';'),
                     Variable(name=Token(idx=231, range=(8472, 8487), value='verify_start'),
                              typename=[8468:8471] 〈int〉,
                              preComment=None,
                              postComment=None,
                              end=';'),
                     Variable(name=Token(idx=238, range=(8552, 8560), value='write'),
                              typename=[8548:8551] 〈int〉,
                              preComment=None,
                              postComment=None,
                              end=';'),
                     Variable(name=Token(idx=245, range=(8642, 8655), value='write_size'),
                              typename=[8638:8641] 〈int〉,
                              preComment=None,
                              postComment=None,
                              end=';'),
                     Variable(name=Token(idx=254, range=(8710, 8715), value='block'),
                              typename=[8700:8708] 〈WT_BLOCK〉,
                              preComment=None,
                              postComment=Token(idx=257,
                                                range=(8717, 8795),
                                                value='/* Underlying file. For a multi-handle tree this will be the '
                                                      'writable file. */'),
                              end=';'),
                     Variable(name=Token(idx=263, range=(8810, 8820), value='next_block'),
                              typename=[8800:8808] 〈WT_BLOCK〉,
                              preComment=None,
                              postComment=Token(idx=266,
                                                range=(8822, 8885),
                                                value='/* If doing a tier switch, this is going to be the new file. */'),
                              end=';'),
                     Variable(name=Token(idx=272, range=(8900, 8910), value='prev_block'),
                              typename=[8890:8898] 〈WT_BLOCK〉,
                              preComment=None,
                              postComment=Token(idx=275,
                                                range=(8912, 8967),
                                                value='/* If a tier switch was done, this was the old file. */'),
                              end=';'),
                     Variable(name=Token(idx=282, range=(8979, 8982), value='map'),
                              typename=[8973:8977] 〈void〉,
                              preComment=None,
                              postComment=Token(idx=285, range=(8984, 9003), value='/* Mapped region */'),
                              end=';'),
                     Variable(name=Token(idx=290, range=(9015, 9021), value='maplen'),
                              typename=[9008:9014] 〈size_t〉,
                              preComment=None,
                              postComment=None,
                              end=';'),
                     Variable(name=Token(idx=297, range=(9033, 9046), value='mapped_cookie'),
                              typename=[9027:9031] 〈void〉,
                              preComment=None,
                              postComment=None,
                              end=';'),
                     Variable(name=Token(idx=307, range=(9441, 9456), value='is_multi_handle'),
                              typename=[9436:9440] 〈bool〉,
                              preComment=Token(idx=302,
                                               range=(9053, 9431),
                                               value='/*\n'
                                                     '     * For trees, such as tiered tables, that are allowed to '
                                                     'have more than one backing file or\n'
                                                     '     * object, we maintain an array of the block handles used by '
                                                     'the tree. We use a reader-writer\n'
                                                     '     * mutex to protect the array. We lock it for reading when '
                                                     'looking for a handle in the array and\n'
                                                     '     * lock it for writing when adding or removing handles in '
                                                     'the array.\n'
                                                     '     */'),
                              postComment=None,
                              end=';'),
                     Variable(name=Token(idx=315, range=(9473, 9485), value='handle_array'),
                              typename=[9462:9470] 〈WT_BLOCK〉,
                              preComment=None,
                              postComment=Token(idx=318, range=(9493, 9521), value='/* Array of block handles */'),
                              end=';'),
                     Variable(name=Token(idx=323, range=(9533, 9555), value='handle_array_allocated'),
                              typename=[9526:9532] 〈size_t〉,
                              preComment=None,
                              postComment=Token(idx=326, range=(9557, 9583), value='/* Size of handle array */'),
                              end=';'),
                     Variable(name=Token(idx=331, range=(9598, 9615), value='handle_array_lock'),
                              typename=[9588:9597] 〈WT_RWLOCK〉,
                              preComment=None,
                              postComment=Token(idx=334, range=(9619, 9652), value='/* Lock for block handle array */'),
                              end=';'),
                     Variable(name=Token(idx=339, range=(9663, 9680), value='handle_array_next'),
                              typename=[9657:9662] 〈u_int〉,
                              preComment=None,
                              postComment=Token(idx=342, range=(9688, 9708), value='/* Next open slot */'),
                              end=';'),
                     Variable(name=Token(idx=347, range=(9722, 9742), value='max_flushed_objectid'),
                              typename=[9713:9721] 〈uint32_t〉,
                              preComment=None,
                              postComment=Token(idx=350,
                                                range=(9744, 9800),
                                                value='/* Local objects at or below this id should be closed */'),
                              end=';'),
                     Variable(name=Token(idx=359, range=(9925, 9932), value='is_live'),
                              typename=[9920:9924] 〈bool〉,
                              preComment=Token(idx=354,
                                               range=(9806, 9915),
                                               value='/*\n'
                                                     "     * There's only a single block manager handle that can be "
                                                     'written, all others are checkpoints.\n'
                                                     '     */'),
                              postComment=Token(idx=362, range=(9934, 9955), value='/* The live system */'),
                              end=';')],
            typedefs=None,
            vardefs=[],
            preComment=Token(idx=88,
                             range=(6184, 6270),
                             value='/*\n'
                                   ' * WT_BM --\n'
                                   ' *\tBlock manager handle, references a single checkpoint in a btree.\n'
                                   ' */'),
            postComment=None,
            nested=None,
            parent=None,
            is_unnamed=False)
Statement(tokens=[9959:13572] 〈
⌇/*
 * WT_BLOCK --
 *	Block manager handle, references a single file.
 */⌇
⌇struct⌇ ⌇__wt_block⌇ ⌇{
    const char *name;  /* Name */
    uint32_t objectid; /* Object id */
    uint32_t ref;      /* References */

    TAILQ_ENTRY(__wt_block) q;     /* Linked list of handles */
    TAILQ_ENTRY(__wt_block) hashq; /* Hashed list of handles */

    WT_FH *fh;            /* Backing file handle */
    wt_off_t size;        /* File size */
    wt_off_t extend_size; /* File extended size */
    wt_off_t extend_len;  /* File extend chunk size */

    bool created_during_backup; /* Created during incremental backup */
    bool sync_on_checkpoint;    /* fsync the handle after the next checkpoint */
    bool remote;                /* Handle references non-local object */
    bool readonly;              /* Underlying file was opened only for reading */

    /* Configuration information, set when the file is opened. */
    wt_shared uint32_t allocfirst; /* Allocation is first-fit */
    uint32_t allocsize;            /* Allocation size */
    size_t os_cache;               /* System buffer cache flush max */
    size_t os_cache_max;
    size_t os_cache_dirty_max;

    u_int block_header; /* Header length */

    /*
     * There is only a single checkpoint in a file that can be written; stored here, only accessed
     * by one WT_BM handle.
     */
    WT_SPINLOCK live_lock; /* Live checkpoint lock */
    WT_BLOCK_CKPT live;    /* Live checkpoint */
    bool live_open;        /* Live system is open */
    enum {                 /* Live checkpoint status */
        WT_CKPT_NONE = 0,
        WT_CKPT_INPROGRESS,
        WT_CKPT_PANIC_ON_FAILURE,
        WT_CKPT_SALVAGE
    } ckpt_state;

    WT_CKPT *final_ckpt; /* Final live checkpoint write */

    /* Compaction support */
    bool compact_estimated;                    /* If compaction work has been estimated */
    int compact_pct_tenths;                    /* Percent to compact */
    uint64_t compact_bytes_reviewed;           /* Bytes reviewed */
    uint64_t compact_bytes_rewritten;          /* Bytes rewritten */
    uint64_t compact_bytes_rewritten_expected; /* The expected number of bytes to rewrite */
    uint64_t compact_internal_pages_reviewed;  /* Internal pages reviewed */
    uint64_t compact_pages_reviewed;           /* Pages reviewed */
    uint64_t compact_pages_rewritten;          /* Pages rewritten */
    uint64_t compact_pages_rewritten_expected; /* The expected number of pages to rewrite */
    uint64_t compact_pages_skipped;            /* Pages skipped */
    uint64_t compact_prev_pages_rewritten;     /* Pages rewritten during the previous iteration */
    wt_off_t compact_prev_size;                /* File size at the start of a compaction pass */
    uint32_t compact_session_id;               /* Session compacting */

    /* Salvage support */
    wt_off_t slvg_off; /* Salvage file offset */

    /* Verification support */
    bool verify;             /* If performing verification */
    bool verify_layout;      /* Print out file layout information */
    bool dump_tree_shape;    /* Print out tree shape */
    bool verify_strict;      /* Fail hard on any error */
    wt_off_t verify_size;    /* Checkpoint's file size */
    WT_EXTLIST verify_alloc; /* Verification allocation list */
    uint64_t frags;          /* Maximum frags in the file */
    uint8_t *fragfile;       /* Per-file frag tracking list */
    uint8_t *fragckpt;       /* Per-checkpoint frag tracking list */

    /* Multi-file support */
    wt_shared uint32_t read_count; /* Count of active read requests using this block handle */
}⌇;⌇
〉,
          kind=StatementKind(is_comment=True,
                             is_preproc=None,
                             is_typedef=None,
                             is_record=True,
                             is_function=None,
                             is_function_def=None,
                             is_function_decl=None,
                             is_statement=None,
                             is_decl=None,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=Token(idx=98,
                                              range=(9960, 10032),
                                              value='/*\n'
                                                    ' * WT_BLOCK --\n'
                                                    ' *\tBlock manager handle, references a single file.\n'
                                                    ' */'),
                             postComment=None))
Record:
RecordParts(recordKind=<RecordKind.STRUCT: 1>,
            name=Token(idx=102, range=(10040, 10050), value='__wt_block'),
            typename=[10040:10050] 〈__wt_block〉,
            body=Token(idx=104,
                       range=(10052, 13569),
                       value='\n'
                             '    const char *name;  /* Name */\n'
                             '    uint32_t objectid; /* Object id */\n'
                             '    uint32_t ref;      /* References */\n'
                             '\n'
                             '    TAILQ_ENTRY(__wt_block) q;     /* Linked list of handles */\n'
                             '    TAILQ_ENTRY(__wt_block) hashq; /* Hashed list of handles */\n'
                             '\n'
                             '    WT_FH *fh;            /* Backing file handle */\n'
                             '    wt_off_t size;        /* File size */\n'
                             '    wt_off_t extend_size; /* File extended size */\n'
                             '    wt_off_t extend_len;  /* File extend chunk size */\n'
                             '\n'
                             '    bool created_during_backup; /* Created during incremental backup */\n'
                             '    bool sync_on_checkpoint;    /* fsync the handle after the next checkpoint */\n'
                             '    bool remote;                /* Handle references non-local object */\n'
                             '    bool readonly;              /* Underlying file was opened only for reading */\n'
                             '\n'
                             '    /* Configuration information, set when the file is opened. */\n'
                             '    wt_shared uint32_t allocfirst; /* Allocation is first-fit */\n'
                             '    uint32_t allocsize;            /* Allocation size */\n'
                             '    size_t os_cache;               /* System buffer cache flush max */\n'
                             '    size_t os_cache_max;\n'
                             '    size_t os_cache_dirty_max;\n'
                             '\n'
                             '    u_int block_header; /* Header length */\n'
                             '\n'
                             '    /*\n'
                             '     * There is only a single checkpoint in a file that can be written; stored here, '
                             'only accessed\n'
                             '     * by one WT_BM handle.\n'
                             '     */\n'
                             '    WT_SPINLOCK live_lock; /* Live checkpoint lock */\n'
                             '    WT_BLOCK_CKPT live;    /* Live checkpoint */\n'
                             '    bool live_open;        /* Live system is open */\n'
                             '    enum {                 /* Live checkpoint status */\n'
                             '        WT_CKPT_NONE = 0,\n'
                             '        WT_CKPT_INPROGRESS,\n'
                             '        WT_CKPT_PANIC_ON_FAILURE,\n'
                             '        WT_CKPT_SALVAGE\n'
                             '    } ckpt_state;\n'
                             '\n'
                             '    WT_CKPT *final_ckpt; /* Final live checkpoint write */\n'
                             '\n'
                             '    /* Compaction support */\n'
                             '    bool compact_estimated;                    /* If compaction work has been estimated '
                             '*/\n'
                             '    int compact_pct_tenths;                    /* Percent to compact */\n'
                             '    uint64_t compact_bytes_reviewed;           /* Bytes reviewed */\n'
                             '    uint64_t compact_bytes_rewritten;          /* Bytes rewritten */\n'
                             '    uint64_t compact_bytes_rewritten_expected; /* The expected number of bytes to '
                             'rewrite */\n'
                             '    uint64_t compact_internal_pages_reviewed;  /* Internal pages reviewed */\n'
                             '    uint64_t compact_pages_reviewed;           /* Pages reviewed */\n'
                             '    uint64_t compact_pages_rewritten;          /* Pages rewritten */\n'
                             '    uint64_t compact_pages_rewritten_expected; /* The expected number of pages to '
                             'rewrite */\n'
                             '    uint64_t compact_pages_skipped;            /* Pages skipped */\n'
                             '    uint64_t compact_prev_pages_rewritten;     /* Pages rewritten during the previous '
                             'iteration */\n'
                             '    wt_off_t compact_prev_size;                /* File size at the start of a compaction '
                             'pass */\n'
                             '    uint32_t compact_session_id;               /* Session compacting */\n'
                             '\n'
                             '    /* Salvage support */\n'
                             '    wt_off_t slvg_off; /* Salvage file offset */\n'
                             '\n'
                             '    /* Verification support */\n'
                             '    bool verify;             /* If performing verification */\n'
                             '    bool verify_layout;      /* Print out file layout information */\n'
                             '    bool dump_tree_shape;    /* Print out tree shape */\n'
                             '    bool verify_strict;      /* Fail hard on any error */\n'
                             "    wt_off_t verify_size;    /* Checkpoint's file size */\n"
                             '    WT_EXTLIST verify_alloc; /* Verification allocation list */\n'
                             '    uint64_t frags;          /* Maximum frags in the file */\n'
                             '    uint8_t *fragfile;       /* Per-file frag tracking list */\n'
                             '    uint8_t *fragckpt;       /* Per-checkpoint frag tracking list */\n'
                             '\n'
                             '    /* Multi-file support */\n'
                             '    wt_shared uint32_t read_count; /* Count of active read requests using this block '
                             'handle */\n'),
            members=[Variable(name=Token(idx=7, range=(10069, 10073), value='name'),
                              typename=[10063:10067] 〈char〉,
                              preComment=None,
                              postComment=Token(idx=10, range=(10076, 10086), value='/* Name */'),
                              end=';'),
                     Variable(name=Token(idx=15, range=(10100, 10108), value='objectid'),
                              typename=[10091:10099] 〈uint32_t〉,
                              preComment=None,
                              postComment=Token(idx=18, range=(10110, 10125), value='/* Object id */'),
                              end=';'),
                     Variable(name=Token(idx=23, range=(10139, 10142), value='ref'),
                              typename=[10130:10138] 〈uint32_t〉,
                              preComment=None,
                              postComment=Token(idx=26, range=(10149, 10165), value='/* References */'),
                              end=';'),
                     Variable(name=Token(idx=33, range=(10195, 10196), value='q'),
                              typename=[10171:10194] 〈TAILQ_ENTRY⌇(__wt_block)〉,
                              preComment=None,
                              postComment=Token(idx=36, range=(10202, 10230), value='/* Linked list of handles */'),
                              end=';'),
                     Variable(name=Token(idx=42, range=(10259, 10264), value='hashq'),
                              typename=[10235:10258] 〈TAILQ_ENTRY⌇(__wt_block)〉,
                              preComment=None,
                              postComment=Token(idx=45, range=(10266, 10294), value='/* Hashed list of handles */'),
                              end=';'),
                     Variable(name=Token(idx=52, range=(10307, 10309), value='fh'),
                              typename=[10300:10305] 〈WT_FH〉,
                              preComment=None,
                              postComment=Token(idx=55, range=(10322, 10347), value='/* Backing file handle */'),
                              end=';'),
                     Variable(name=Token(idx=60, range=(10361, 10365), value='size'),
                              typename=[10352:10360] 〈wt_off_t〉,
                              preComment=None,
                              postComment=Token(idx=63, range=(10374, 10389), value='/* File size */'),
                              end=';'),
                     Variable(name=Token(idx=68, range=(10403, 10414), value='extend_size'),
                              typename=[10394:10402] 〈wt_off_t〉,
                              preComment=None,
                              postComment=Token(idx=71, range=(10416, 10440), value='/* File extended size */'),
                              end=';'),
                     Variable(name=Token(idx=76, range=(10454, 10464), value='extend_len'),
                              typename=[10445:10453] 〈wt_off_t〉,
                              preComment=None,
                              postComment=Token(idx=79, range=(10467, 10495), value='/* File extend chunk size */'),
                              end=';'),
                     Variable(name=Token(idx=85, range=(10506, 10527), value='created_during_backup'),
                              typename=[10501:10505] 〈bool〉,
                              preComment=None,
                              postComment=Token(idx=88,
                                                range=(10529, 10568),
                                                value='/* Created during incremental backup */'),
                              end=';'),
                     Variable(name=Token(idx=93, range=(10578, 10596), value='sync_on_checkpoint'),
                              typename=[10573:10577] 〈bool〉,
                              preComment=None,
                              postComment=Token(idx=96,
                                                range=(10601, 10649),
                                                value='/* fsync the handle after the next checkpoint */'),
                              end=';'),
                     Variable(name=Token(idx=101, range=(10659, 10665), value='remote'),
                              typename=[10654:10658] 〈bool〉,
                              preComment=None,
                              postComment=Token(idx=104,
                                                range=(10682, 10722),
                                                value='/* Handle references non-local object */'),
                              end=';'),
                     Variable(name=Token(idx=109, range=(10732, 10740), value='readonly'),
                              typename=[10727:10731] 〈bool〉,
                              preComment=None,
                              postComment=Token(idx=112,
                                                range=(10755, 10804),
                                                value='/* Underlying file was opened only for reading */'),
                              end=';'),
                     Variable(name=Token(idx=123, range=(10895, 10905), value='allocfirst'),
                              typename=[10876:10894] 〈wt_shared⌇uint32_t〉,
                              preComment=Token(idx=116,
                                               range=(10810, 10871),
                                               value='/* Configuration information, set when the file is opened. */'),
                              postComment=Token(idx=126, range=(10907, 10936), value='/* Allocation is first-fit */'),
                              end=';'),
                     Variable(name=Token(idx=131, range=(10950, 10959), value='allocsize'),
                              typename=[10941:10949] 〈uint32_t〉,
                              preComment=None,
                              postComment=Token(idx=134, range=(10972, 10993), value='/* Allocation size */'),
                              end=';'),
                     Variable(name=Token(idx=139, range=(11005, 11013), value='os_cache'),
                              typename=[10998:11004] 〈size_t〉,
                              preComment=None,
                              postComment=Token(idx=142,
                                                range=(11029, 11064),
                                                value='/* System buffer cache flush max */'),
                              end=';'),
                     Variable(name=Token(idx=147, range=(11076, 11088), value='os_cache_max'),
                              typename=[11069:11075] 〈size_t〉,
                              preComment=None,
                              postComment=None,
                              end=';'),
                     Variable(name=Token(idx=153, range=(11101, 11119), value='os_cache_dirty_max'),
                              typename=[11094:11100] 〈size_t〉,
                              preComment=None,
                              postComment=None,
                              end=';'),
                     Variable(name=Token(idx=160, range=(11132, 11144), value='block_header'),
                              typename=[11126:11131] 〈u_int〉,
                              preComment=None,
                              postComment=Token(idx=163, range=(11146, 11165), value='/* Header length */'),
                              end=';'),
                     Variable(name=Token(idx=172, range=(11325, 11334), value='live_lock'),
                              typename=[11313:11324] 〈WT_SPINLOCK〉,
                              preComment=Token(idx=167,
                                               range=(11171, 11308),
                                               value='/*\n'
                                                     '     * There is only a single checkpoint in a file that can be '
                                                     'written; stored here, only accessed\n'
                                                     '     * by one WT_BM handle.\n'
                                                     '     */'),
                              postComment=Token(idx=175, range=(11336, 11362), value='/* Live checkpoint lock */'),
                              end=';'),
                     Variable(name=Token(idx=180, range=(11381, 11385), value='live'),
                              typename=[11367:11380] 〈WT_BLOCK_CKPT〉,
                              preComment=None,
                              postComment=Token(idx=183, range=(11390, 11411), value='/* Live checkpoint */'),
                              end=';'),
                     Variable(name=Token(idx=188, range=(11421, 11430), value='live_open'),
                              typename=[11416:11420] 〈bool〉,
                              preComment=None,
                              postComment=Token(idx=191, range=(11439, 11464), value='/* Live system is open */'),
                              end=';'),
                     Variable(name=Token(idx=198, range=(11639, 11649), value='ckpt_state'),
                              typename=[11475:11637] 〈(data/block.h:0:21527:)〉,
                              preComment=None,
                              postComment=None,
                              end=';'),
                     Variable(name=Token(idx=206, range=(11665, 11675), value='final_ckpt'),
                              typename=[11656:11663] 〈WT_CKPT〉,
                              preComment=None,
                              postComment=Token(idx=209,
                                                range=(11677, 11710),
                                                value='/* Final live checkpoint write */'),
                              end=';'),
                     Variable(name=Token(idx=218, range=(11750, 11767), value='compact_estimated'),
                              typename=[11745:11749] 〈bool〉,
                              preComment=Token(idx=213, range=(11716, 11740), value='/* Compaction support */'),
                              postComment=Token(idx=221,
                                                range=(11788, 11831),
                                                value='/* If compaction work has been estimated */'),
                              end=';'),
                     Variable(name=Token(idx=226, range=(11840, 11858), value='compact_pct_tenths'),
                              typename=[11836:11839] 〈int〉,
                              preComment=None,
                              postComment=Token(idx=229, range=(11879, 11903), value='/* Percent to compact */'),
                              end=';'),
                     Variable(name=Token(idx=234, range=(11917, 11939), value='compact_bytes_reviewed'),
                              typename=[11908:11916] 〈uint64_t〉,
                              preComment=None,
                              postComment=Token(idx=237, range=(11951, 11971), value='/* Bytes reviewed */'),
                              end=';'),
                     Variable(name=Token(idx=242, range=(11985, 12008), value='compact_bytes_rewritten'),
                              typename=[11976:11984] 〈uint64_t〉,
                              preComment=None,
                              postComment=Token(idx=245, range=(12019, 12040), value='/* Bytes rewritten */'),
                              end=';'),
                     Variable(name=Token(idx=250, range=(12054, 12086), value='compact_bytes_rewritten_expected'),
                              typename=[12045:12053] 〈uint64_t〉,
                              preComment=None,
                              postComment=Token(idx=253,
                                                range=(12088, 12133),
                                                value='/* The expected number of bytes to rewrite */'),
                              end=';'),
                     Variable(name=Token(idx=258, range=(12147, 12178), value='compact_internal_pages_reviewed'),
                              typename=[12138:12146] 〈uint64_t〉,
                              preComment=None,
                              postComment=Token(idx=261, range=(12181, 12210), value='/* Internal pages reviewed */'),
                              end=';'),
                     Variable(name=Token(idx=266, range=(12224, 12246), value='compact_pages_reviewed'),
                              typename=[12215:12223] 〈uint64_t〉,
                              preComment=None,
                              postComment=Token(idx=269, range=(12258, 12278), value='/* Pages reviewed */'),
                              end=';'),
                     Variable(name=Token(idx=274, range=(12292, 12315), value='compact_pages_rewritten'),
                              typename=[12283:12291] 〈uint64_t〉,
                              preComment=None,
                              postComment=Token(idx=277, range=(12326, 12347), value='/* Pages rewritten */'),
                              end=';'),
                     Variable(name=Token(idx=282, range=(12361, 12393), value='compact_pages_rewritten_expected'),
                              typename=[12352:12360] 〈uint64_t〉,
                              preComment=None,
                              postComment=Token(idx=285,
                                                range=(12395, 12440),
                                                value='/* The expected number of pages to rewrite */'),
                              end=';'),
                     Variable(name=Token(idx=290, range=(12454, 12475), value='compact_pages_skipped'),
                              typename=[12445:12453] 〈uint64_t〉,
                              preComment=None,
                              postComment=Token(idx=293, range=(12488, 12507), value='/* Pages skipped */'),
                              end=';'),
                     Variable(name=Token(idx=298, range=(12521, 12549), value='compact_prev_pages_rewritten'),
                              typename=[12512:12520] 〈uint64_t〉,
                              preComment=None,
                              postComment=Token(idx=301,
                                                range=(12555, 12606),
                                                value='/* Pages rewritten during the previous iteration */'),
                              end=';'),
                     Variable(name=Token(idx=306, range=(12620, 12637), value='compact_prev_size'),
                              typename=[12611:12619] 〈wt_off_t〉,
                              preComment=None,
                              postComment=Token(idx=309,
                                                range=(12654, 12703),
                                                value='/* File size at the start of a compaction pass */'),
                              end=';'),
                     Variable(name=Token(idx=314, range=(12717, 12735), value='compact_session_id'),
                              typename=[12708:12716] 〈uint32_t〉,
                              preComment=None,
                              postComment=Token(idx=317, range=(12751, 12775), value='/* Session compacting */'),
                              end=';'),
                     Variable(name=Token(idx=326, range=(12816, 12824), value='slvg_off'),
                              typename=[12807:12815] 〈wt_off_t〉,
                              preComment=Token(idx=321, range=(12781, 12802), value='/* Salvage support */'),
                              postComment=Token(idx=329, range=(12826, 12851), value='/* Salvage file offset */'),
                              end=';'),
                     Variable(name=Token(idx=338, range=(12893, 12899), value='verify'),
                              typename=[12888:12892] 〈bool〉,
                              preComment=Token(idx=333, range=(12857, 12883), value='/* Verification support */'),
                              postComment=Token(idx=341,
                                                range=(12913, 12945),
                                                value='/* If performing verification */'),
                              end=';'),
                     Variable(name=Token(idx=346, range=(12955, 12968), value='verify_layout'),
                              typename=[12950:12954] 〈bool〉,
                              preComment=None,
                              postComment=Token(idx=349,
                                                range=(12975, 13014),
                                                value='/* Print out file layout information */'),
                              end=';'),
                     Variable(name=Token(idx=354, range=(13024, 13039), value='dump_tree_shape'),
                              typename=[13019:13023] 〈bool〉,
                              preComment=None,
                              postComment=Token(idx=357, range=(13044, 13070), value='/* Print out tree shape */'),
                              end=';'),
                     Variable(name=Token(idx=362, range=(13080, 13093), value='verify_strict'),
                              typename=[13075:13079] 〈bool〉,
                              preComment=None,
                              postComment=Token(idx=365, range=(13100, 13128), value='/* Fail hard on any error */'),
                              end=';'),
                     Variable(name=Token(idx=370, range=(13142, 13153), value='verify_size'),
                              typename=[13133:13141] 〈wt_off_t〉,
                              preComment=None,
                              postComment=Token(idx=373, range=(13158, 13186), value="/* Checkpoint's file size */"),
                              end=';'),
                     Variable(name=Token(idx=378, range=(13202, 13214), value='verify_alloc'),
                              typename=[13191:13201] 〈WT_EXTLIST〉,
                              preComment=None,
                              postComment=Token(idx=381,
                                                range=(13216, 13250),
                                                value='/* Verification allocation list */'),
                              end=';'),
                     Variable(name=Token(idx=386, range=(13264, 13269), value='frags'),
                              typename=[13255:13263] 〈uint64_t〉,
                              preComment=None,
                              postComment=Token(idx=389, range=(13280, 13311), value='/* Maximum frags in the file */'),
                              end=';'),
                     Variable(name=Token(idx=395, range=(13325, 13333), value='fragfile'),
                              typename=[13316:13323] 〈uint8_t〉,
                              preComment=None,
                              postComment=Token(idx=398,
                                                range=(13341, 13374),
                                                value='/* Per-file frag tracking list */'),
                              end=';'),
                     Variable(name=Token(idx=404, range=(13388, 13396), value='fragckpt'),
                              typename=[13379:13386] 〈uint8_t〉,
                              preComment=None,
                              postComment=Token(idx=407,
                                                range=(13404, 13443),
                                                value='/* Per-checkpoint frag tracking list */'),
                              end=';'),
                     Variable(name=Token(idx=418, range=(13497, 13507), value='read_count'),
                              typename=[13478:13496] 〈wt_shared⌇uint32_t〉,
                              preComment=Token(idx=411, range=(13449, 13473), value='/* Multi-file support */'),
                              postComment=Token(idx=421,
                                                range=(13509, 13568),
                                                value='/* Count of active read requests using this block handle */'),
                              end=';')],
            typedefs=None,
            vardefs=[],
            preComment=Token(idx=98,
                             range=(9960, 10032),
                             value='/*\n * WT_BLOCK --\n *\tBlock manager handle, references a single file.\n */'),
            postComment=None,
            nested=[RecordParts(recordKind=<RecordKind.ENUM: 3>,
                                name=Token(idx=196, range=(11475, 11637), value='(data/block.h:0:21527:)'),
                                typename=[11475:11637] 〈(data/block.h:0:21527:)〉,
                                body=Token(idx=196,
                                           range=(11475, 11637),
                                           value='                 /* Live checkpoint status */\n'
                                                 '        WT_CKPT_NONE = 0,\n'
                                                 '        WT_CKPT_INPROGRESS,\n'
                                                 '        WT_CKPT_PANIC_ON_FAILURE,\n'
                                                 '        WT_CKPT_SALVAGE\n'
                                                 '    '),
                                members=[Variable(name=Token(idx=4, range=(11529, 11541), value='WT_CKPT_NONE'),
                                                  typename=None,
                                                  preComment=Token(idx=1,
                                                                   range=(11492, 11520),
                                                                   value='/* Live checkpoint status */'),
                                                  postComment=None,
                                                  end=None)],
                                typedefs=None,
                                vardefs=[Variable(name=Token(idx=198, range=(11639, 11649), value='ckpt_state'),
                                                  typename=[11475:11637] 〈(data/block.h:0:21527:)〉,
                                                  preComment=None,
                                                  postComment=None,
                                                  end=';')],
                                preComment=None,
                                postComment=None,
                                nested=None,
                                parent=...,
                                is_unnamed=False)],
            parent=None,
            is_unnamed=False)
Statement(tokens=[13572:14000] 〈
⌇/*
 * WT_BLOCK_DESC --
 *	The file's description.
 */⌇
⌇struct⌇ ⌇__wt_block_desc⌇ ⌇{
#define WT_BLOCK_MAGIC 120897
    uint32_t magic; /* 00-03: Magic number */
#define WT_BLOCK_MAJOR_VERSION 1
    uint16_t majorv; /* 04-05: Major version */
#define WT_BLOCK_MINOR_VERSION 0
    uint16_t minorv; /* 06-07: Minor version */

    uint32_t checksum; /* 08-11: Description block checksum */

    uint32_t unused; /* 12-15: Padding */
}⌇;⌇
〉,
          kind=StatementKind(is_comment=True,
                             is_preproc=None,
                             is_typedef=None,
                             is_record=True,
                             is_function=None,
                             is_function_def=None,
                             is_function_decl=None,
                             is_statement=None,
                             is_decl=None,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=Token(idx=108,
                                              range=(13573, 13626),
                                              value="/*\n * WT_BLOCK_DESC --\n *\tThe file's description.\n */"),
                             postComment=None))
Record:
RecordParts(recordKind=<RecordKind.STRUCT: 1>,
            name=Token(idx=112, range=(13634, 13649), value='__wt_block_desc'),
            typename=[13634:13649] 〈__wt_block_desc〉,
            body=Token(idx=114,
                       range=(13651, 13997),
                       value='\n'
                             '#define WT_BLOCK_MAGIC 120897\n'
                             '    uint32_t magic; /* 00-03: Magic number */\n'
                             '#define WT_BLOCK_MAJOR_VERSION 1\n'
                             '    uint16_t majorv; /* 04-05: Major version */\n'
                             '#define WT_BLOCK_MINOR_VERSION 0\n'
                             '    uint16_t minorv; /* 06-07: Minor version */\n'
                             '\n'
                             '    uint32_t checksum; /* 08-11: Description block checksum */\n'
                             '\n'
                             '    uint32_t unused; /* 12-15: Padding */\n'),
            members=[Variable(name=Token(idx=5, range=(13695, 13700), value='magic'),
                              typename=[13686:13694] 〈uint32_t〉,
                              preComment=None,
                              postComment=Token(idx=8, range=(13702, 13727), value='/* 00-03: Magic number */'),
                              end=';'),
                     Variable(name=Token(idx=14, range=(13774, 13780), value='majorv'),
                              typename=[13765:13773] 〈uint16_t〉,
                              preComment=None,
                              postComment=Token(idx=17, range=(13782, 13808), value='/* 04-05: Major version */'),
                              end=';'),
                     Variable(name=Token(idx=23, range=(13855, 13861), value='minorv'),
                              typename=[13846:13854] 〈uint16_t〉,
                              preComment=None,
                              postComment=Token(idx=26, range=(13863, 13889), value='/* 06-07: Minor version */'),
                              end=';'),
                     Variable(name=Token(idx=32, range=(13904, 13912), value='checksum'),
                              typename=[13895:13903] 〈uint32_t〉,
                              preComment=None,
                              postComment=Token(idx=35,
                                                range=(13914, 13953),
                                                value='/* 08-11: Description block checksum */'),
                              end=';'),
                     Variable(name=Token(idx=41, range=(13968, 13974), value='unused'),
                              typename=[13959:13967] 〈uint32_t〉,
                              preComment=None,
                              postComment=Token(idx=44, range=(13976, 13996), value='/* 12-15: Padding */'),
                              end=';')],
            typedefs=None,
            vardefs=[],
            preComment=Token(idx=108,
                             range=(13573, 13626),
                             value="/*\n * WT_BLOCK_DESC --\n *\tThe file's description.\n */"),
            postComment=None,
            nested=None,
            parent=None,
            is_unnamed=False)
Statement(tokens=[14000:14323] 〈/*
 * WT_BLOCK_DESC_SIZE is the expected structure size -- we verify the build to ensure the compiler
 * hasn't inserted padding (padding won't cause failure, we reserve the first allocation-size block
 * of the file for this information, but it would be worth investigation, regardless).
 */⌇
⌇#define WT_BLOCK_DESC_SIZE 16
〉,
          kind=StatementKind(is_comment=True,
                             is_preproc=True,
                             is_typedef=None,
                             is_record=None,
                             is_function=None,
                             is_function_def=None,
                             is_function_decl=None,
                             is_statement=None,
                             is_decl=None,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=Token(idx=117,
                                              range=(14000, 14292),
                                              value='/*\n'
                                                    ' * WT_BLOCK_DESC_SIZE is the expected structure size -- we verify '
                                                    'the build to ensure the compiler\n'
                                                    " * hasn't inserted padding (padding won't cause failure, we "
                                                    'reserve the first allocation-size block\n'
                                                    ' * of the file for this information, but it would be worth '
                                                    'investigation, regardless).\n'
                                                    ' */'),
                             postComment=None))
Macro:
MacroParts(name=Token(idx=0, range=(14301, 14319), value='WT_BLOCK_DESC_SIZE'),
           args=None,
           body=Token(idx=0, range=(14320, 14323), value='16'),
           preComment=Token(idx=117,
                            range=(14000, 14292),
                            value='/*\n'
                                  ' * WT_BLOCK_DESC_SIZE is the expected structure size -- we verify the build to '
                                  'ensure the compiler\n'
                                  " * hasn't inserted padding (padding won't cause failure, we reserve the first "
                                  'allocation-size block\n'
                                  ' * of the file for this information, but it would be worth investigation, '
                                  'regardless).\n'
                                  ' */'),
           is_va_args=False,
           is_wellformed=True,
           is_const=True)
Statement(tokens=[14323:14757] 〈
⌇/*
 * __wt_block_desc_byteswap --
 *     Handle big- and little-endian transformation of a description block.
 */⌇
⌇static⌇ ⌇WT_INLINE⌇ ⌇void⌇
⌇__wt_block_desc_byteswap⌇(WT_BLOCK_DESC *desc)⌇
⌇{
#ifdef WORDS_BIGENDIAN
    desc->magic = __wt_bswap32(desc->magic);
    desc->majorv = __wt_bswap16(desc->majorv);
    desc->minorv = __wt_bswap16(desc->minorv);
    desc->checksum = __wt_bswap32(desc->checksum);
#else
    WT_UNUSED(desc);
#endif
}⌇
〉,
          kind=StatementKind(is_comment=True,
                             is_preproc=None,
                             is_typedef=None,
                             is_record=None,
                             is_function=True,
                             is_function_def=True,
                             is_function_decl=True,
                             is_statement=None,
                             is_decl=True,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=Token(idx=121,
                                              range=(14324, 14437),
                                              value='/*\n'
                                                    ' * __wt_block_desc_byteswap --\n'
                                                    ' *     Handle big- and little-endian transformation of a '
                                                    'description block.\n'
                                                    ' */'),
                             postComment=None))
Function:
FunctionParts(typename=[14455:14459] 〈void〉,
              name=Token(idx=129, range=(14460, 14484), value='__wt_block_desc_byteswap'),
              args=Token(idx=130, range=(14485, 14504), value='WT_BLOCK_DESC *desc'),
              body=Token(idx=132,
                         range=(14507, 14755),
                         value='\n'
                               '#ifdef WORDS_BIGENDIAN\n'
                               '    desc->magic = __wt_bswap32(desc->magic);\n'
                               '    desc->majorv = __wt_bswap16(desc->majorv);\n'
                               '    desc->minorv = __wt_bswap16(desc->minorv);\n'
                               '    desc->checksum = __wt_bswap32(desc->checksum);\n'
                               '#else\n'
                               '    WT_UNUSED(desc);\n'
                               '#endif\n'),
              preComment=Token(idx=121,
                               range=(14324, 14437),
                               value='/*\n'
                                     ' * __wt_block_desc_byteswap --\n'
                                     ' *     Handle big- and little-endian transformation of a description block.\n'
                                     ' */'),
              postComment=None,
              is_type_const=False,
              is_type_static=True)
Args:
[Variable(name=Token(idx=3, range=(14500, 14504), value='desc'),
          typename=[14485:14498] 〈WT_BLOCK_DESC〉,
          preComment=None,
          postComment=None,
          end=None)]
Vars:
[]
Statement(tokens=[14757:16358] 〈
⌇/*
 * WT_BLOCK_HEADER --
 *	Blocks have a common header, a WT_PAGE_HEADER structure followed by a
 * block-manager specific structure: WT_BLOCK_HEADER is WiredTiger's default.
 */⌇
⌇struct⌇ ⌇__wt_block_header⌇ ⌇{
    /*
     * We write the page size in the on-disk page header because it makes salvage easier. (If we
     * don't know the expected page length, we'd have to read increasingly larger chunks from the
     * file until we find one that checksums, and that's going to be harsh given WiredTiger's
     * potentially large page sizes.)
     */
    uint32_t disk_size; /* 00-03: on-disk page size */

    /*
     * Page checksums are stored in two places. First, the page checksum is written within the
     * internal page that references it as part of the address cookie. This is done to improve the
     * chances of detecting not only disk corruption but other bugs (for example, overwriting a page
     * with another valid page image). Second, a page's checksum is stored in the disk header. This
     * is for salvage, so salvage knows it has found a page that may be useful.
     */
    uint32_t checksum; /* 04-07: checksum */

/*
 * No automatic generation: flag values cannot change, they're written to disk.
 */
#define WT_BLOCK_DATA_CKSUM 0x1u /* Block data is part of the checksum */
    uint8_t flags;               /* 08: flags */

    /*
     * End the structure with 3 bytes of padding: it wastes space, but it leaves the structure
     * 32-bit aligned and having a few bytes to play with in the future can't hurt.
     */
    uint8_t unused[3]; /* 09-11: unused padding */
}⌇;⌇
〉,
          kind=StatementKind(is_comment=True,
                             is_preproc=None,
                             is_typedef=None,
                             is_record=True,
                             is_function=None,
                             is_function_def=None,
                             is_function_decl=None,
                             is_statement=None,
                             is_decl=None,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=Token(idx=135,
                                              range=(14758, 14937),
                                              value='/*\n'
                                                    ' * WT_BLOCK_HEADER --\n'
                                                    ' *\tBlocks have a common header, a WT_PAGE_HEADER structure '
                                                    'followed by a\n'
                                                    ' * block-manager specific structure: WT_BLOCK_HEADER is '
                                                    "WiredTiger's default.\n"
                                                    ' */'),
                             postComment=None))
Record:
RecordParts(recordKind=<RecordKind.STRUCT: 1>,
            name=Token(idx=139, range=(14945, 14962), value='__wt_block_header'),
            typename=[14945:14962] 〈__wt_block_header〉,
            body=Token(idx=141,
                       range=(14964, 16355),
                       value='\n'
                             '    /*\n'
                             '     * We write the page size in the on-disk page header because it makes salvage '
                             'easier. (If we\n'
                             "     * don't know the expected page length, we'd have to read increasingly larger chunks "
                             'from the\n'
                             "     * file until we find one that checksums, and that's going to be harsh given "
                             "WiredTiger's\n"
                             '     * potentially large page sizes.)\n'
                             '     */\n'
                             '    uint32_t disk_size; /* 00-03: on-disk page size */\n'
                             '\n'
                             '    /*\n'
                             '     * Page checksums are stored in two places. First, the page checksum is written '
                             'within the\n'
                             '     * internal page that references it as part of the address cookie. This is done to '
                             'improve the\n'
                             '     * chances of detecting not only disk corruption but other bugs (for example, '
                             'overwriting a page\n'
                             "     * with another valid page image). Second, a page's checksum is stored in the disk "
                             'header. This\n'
                             '     * is for salvage, so salvage knows it has found a page that may be useful.\n'
                             '     */\n'
                             '    uint32_t checksum; /* 04-07: checksum */\n'
                             '\n'
                             '/*\n'
                             " * No automatic generation: flag values cannot change, they're written to disk.\n"
                             ' */\n'
                             '#define WT_BLOCK_DATA_CKSUM 0x1u /* Block data is part of the checksum */\n'
                             '    uint8_t flags;               /* 08: flags */\n'
                             '\n'
                             '    /*\n'
                             '     * End the structure with 3 bytes of padding: it wastes space, but it leaves the '
                             'structure\n'
                             "     * 32-bit aligned and having a few bytes to play with in the future can't hurt.\n"
                             '     */\n'
                             '    uint8_t unused[3]; /* 09-11: unused padding */\n'),
            members=[Variable(name=Token(idx=7, range=(15320, 15329), value='disk_size'),
                              typename=[15311:15319] 〈uint32_t〉,
                              preComment=Token(idx=2,
                                               range=(14969, 15306),
                                               value='/*\n'
                                                     '     * We write the page size in the on-disk page header because '
                                                     'it makes salvage easier. (If we\n'
                                                     "     * don't know the expected page length, we'd have to read "
                                                     'increasingly larger chunks from the\n'
                                                     "     * file until we find one that checksums, and that's going "
                                                     "to be harsh given WiredTiger's\n"
                                                     '     * potentially large page sizes.)\n'
                                                     '     */'),
                              postComment=Token(idx=10, range=(15331, 15361), value='/* 00-03: on-disk page size */'),
                              end=';'),
                     Variable(name=Token(idx=19, range=(15866, 15874), value='checksum'),
                              typename=[15857:15865] 〈uint32_t〉,
                              preComment=Token(idx=14,
                                               range=(15367, 15852),
                                               value='/*\n'
                                                     '     * Page checksums are stored in two places. First, the page '
                                                     'checksum is written within the\n'
                                                     '     * internal page that references it as part of the address '
                                                     'cookie. This is done to improve the\n'
                                                     '     * chances of detecting not only disk corruption but other '
                                                     'bugs (for example, overwriting a page\n'
                                                     "     * with another valid page image). Second, a page's checksum "
                                                     'is stored in the disk header. This\n'
                                                     '     * is for salvage, so salvage knows it has found a page that '
                                                     'may be useful.\n'
                                                     '     */'),
                              postComment=Token(idx=22, range=(15876, 15897), value='/* 04-07: checksum */'),
                              end=';'),
                     Variable(name=Token(idx=31, range=(16072, 16077), value='flags'),
                              typename=[16064:16071] 〈uint8_t〉,
                              preComment=None,
                              postComment=Token(idx=34, range=(16093, 16108), value='/* 08: flags */'),
                              end=';'),
                     Variable(name=Token(idx=43, range=(16316, 16322), value='unused'),
                              typename=[16308:16315] 〈uint8_t〉,
                              preComment=Token(idx=38,
                                               range=(16114, 16303),
                                               value='/*\n'
                                                     '     * End the structure with 3 bytes of padding: it wastes '
                                                     'space, but it leaves the structure\n'
                                                     '     * 32-bit aligned and having a few bytes to play with in the '
                                                     "future can't hurt.\n"
                                                     '     */'),
                              postComment=Token(idx=47, range=(16327, 16354), value='/* 09-11: unused padding */'),
                              end=';')],
            typedefs=None,
            vardefs=[],
            preComment=Token(idx=135,
                             range=(14758, 14937),
                             value='/*\n'
                                   ' * WT_BLOCK_HEADER --\n'
                                   ' *\tBlocks have a common header, a WT_PAGE_HEADER structure followed by a\n'
                                   " * block-manager specific structure: WT_BLOCK_HEADER is WiredTiger's default.\n"
                                   ' */'),
            postComment=None,
            nested=None,
            parent=None,
            is_unnamed=False)
Statement(tokens=[16358:16535] 〈/*
 * WT_BLOCK_HEADER_SIZE is the number of bytes we allocate for the structure: if the compiler
 * inserts padding it will break the world.
 */⌇
⌇#define WT_BLOCK_HEADER_SIZE 12
〉,
          kind=StatementKind(is_comment=True,
                             is_preproc=True,
                             is_typedef=None,
                             is_record=None,
                             is_function=None,
                             is_function_def=None,
                             is_function_decl=None,
                             is_statement=None,
                             is_decl=None,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=Token(idx=144,
                                              range=(16358, 16502),
                                              value='/*\n'
                                                    ' * WT_BLOCK_HEADER_SIZE is the number of bytes we allocate for '
                                                    'the structure: if the compiler\n'
                                                    ' * inserts padding it will break the world.\n'
                                                    ' */'),
                             postComment=None))
Macro:
MacroParts(name=Token(idx=0, range=(16511, 16531), value='WT_BLOCK_HEADER_SIZE'),
           args=None,
           body=Token(idx=0, range=(16532, 16535), value='12'),
           preComment=Token(idx=144,
                            range=(16358, 16502),
                            value='/*\n'
                                  ' * WT_BLOCK_HEADER_SIZE is the number of bytes we allocate for the structure: if '
                                  'the compiler\n'
                                  ' * inserts padding it will break the world.\n'
                                  ' */'),
           is_va_args=False,
           is_wellformed=True,
           is_const=True)
Statement(tokens=[16535:16943] 〈
⌇/*
 * __wt_block_header_byteswap_copy --
 *     Handle big- and little-endian transformation of a header block, copying from a source to a
 *     target.
 */⌇
⌇static⌇ ⌇WT_INLINE⌇ ⌇void⌇
⌇__wt_block_header_byteswap_copy⌇(WT_BLOCK_HEADER *from, WT_BLOCK_HEADER *to)⌇
⌇{
    *to = *from;
#ifdef WORDS_BIGENDIAN
    to->disk_size = __wt_bswap32(from->disk_size);
    to->checksum = __wt_bswap32(from->checksum);
#endif
}⌇
〉,
          kind=StatementKind(is_comment=True,
                             is_preproc=None,
                             is_typedef=None,
                             is_record=None,
                             is_function=True,
                             is_function_def=True,
                             is_function_decl=True,
                             is_statement=None,
                             is_decl=True,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=Token(idx=148,
                                              range=(16536, 16693),
                                              value='/*\n'
                                                    ' * __wt_block_header_byteswap_copy --\n'
                                                    ' *     Handle big- and little-endian transformation of a header '
                                                    'block, copying from a source to a\n'
                                                    ' *     target.\n'
                                                    ' */'),
                             postComment=None))
Function:
FunctionParts(typename=[16711:16715] 〈void〉,
              name=Token(idx=156, range=(16716, 16747), value='__wt_block_header_byteswap_copy'),
              args=Token(idx=157, range=(16748, 16790), value='WT_BLOCK_HEADER *from, WT_BLOCK_HEADER *to'),
              body=Token(idx=159,
                         range=(16793, 16941),
                         value='\n'
                               '    *to = *from;\n'
                               '#ifdef WORDS_BIGENDIAN\n'
                               '    to->disk_size = __wt_bswap32(from->disk_size);\n'
                               '    to->checksum = __wt_bswap32(from->checksum);\n'
                               '#endif\n'),
              preComment=Token(idx=148,
                               range=(16536, 16693),
                               value='/*\n'
                                     ' * __wt_block_header_byteswap_copy --\n'
                                     ' *     Handle big- and little-endian transformation of a header block, copying '
                                     'from a source to a\n'
                                     ' *     target.\n'
                                     ' */'),
              postComment=None,
              is_type_const=False,
              is_type_static=True)
Args:
[Variable(name=Token(idx=3, range=(16765, 16769), value='from'),
          typename=[16748:16763] 〈WT_BLOCK_HEADER〉,
          preComment=None,
          postComment=None,
          end=','),
 Variable(name=Token(idx=9, range=(16788, 16790), value='to'),
          typename=[16771:16786] 〈WT_BLOCK_HEADER〉,
          preComment=None,
          postComment=None,
          end=None)]
Vars:
[]
Statement(tokens=[16943:17233] 〈
⌇/*
 * __wt_block_header_byteswap --
 *     Handle big- and little-endian transformation of a header block.
 */⌇
⌇static⌇ ⌇WT_INLINE⌇ ⌇void⌇
⌇__wt_block_header_byteswap⌇(WT_BLOCK_HEADER *blk)⌇
⌇{
#ifdef WORDS_BIGENDIAN
    __wt_block_header_byteswap_copy(blk, blk);
#else
    WT_UNUSED(blk);
#endif
}⌇
〉,
          kind=StatementKind(is_comment=True,
                             is_preproc=None,
                             is_typedef=None,
                             is_record=None,
                             is_function=True,
                             is_function_def=True,
                             is_function_decl=True,
                             is_statement=None,
                             is_decl=True,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=Token(idx=162,
                                              range=(16944, 17054),
                                              value='/*\n'
                                                    ' * __wt_block_header_byteswap --\n'
                                                    ' *     Handle big- and little-endian transformation of a header '
                                                    'block.\n'
                                                    ' */'),
                             postComment=None))
Function:
FunctionParts(typename=[17072:17076] 〈void〉,
              name=Token(idx=170, range=(17077, 17103), value='__wt_block_header_byteswap'),
              args=Token(idx=171, range=(17104, 17124), value='WT_BLOCK_HEADER *blk'),
              body=Token(idx=173,
                         range=(17127, 17231),
                         value='\n'
                               '#ifdef WORDS_BIGENDIAN\n'
                               '    __wt_block_header_byteswap_copy(blk, blk);\n'
                               '#else\n'
                               '    WT_UNUSED(blk);\n'
                               '#endif\n'),
              preComment=Token(idx=162,
                               range=(16944, 17054),
                               value='/*\n'
                                     ' * __wt_block_header_byteswap --\n'
                                     ' *     Handle big- and little-endian transformation of a header block.\n'
                                     ' */'),
              postComment=None,
              is_type_const=False,
              is_type_static=True)
Args:
[Variable(name=Token(idx=3, range=(17121, 17124), value='blk'),
          typename=[17104:17119] 〈WT_BLOCK_HEADER〉,
          preComment=None,
          postComment=None,
          end=None)]
Vars:
[]
Statement(tokens=[17233:17448] 〈
⌇/*
 * WT_BLOCK_HEADER_BYTE
 * WT_BLOCK_HEADER_BYTE_SIZE --
 *	The first usable data byte on the block (past the combined headers).
 */⌇
⌇#define WT_BLOCK_HEADER_BYTE_SIZE (WT_PAGE_HEADER_SIZE + WT_BLOCK_HEADER_SIZE)
〉,
          kind=StatementKind(is_comment=True,
                             is_preproc=True,
                             is_typedef=None,
                             is_record=None,
                             is_function=None,
                             is_function_def=None,
                             is_function_decl=None,
                             is_statement=None,
                             is_decl=None,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=Token(idx=176,
                                              range=(17234, 17368),
                                              value='/*\n'
                                                    ' * WT_BLOCK_HEADER_BYTE\n'
                                                    ' * WT_BLOCK_HEADER_BYTE_SIZE --\n'
                                                    ' *\tThe first usable data byte on the block (past the combined '
                                                    'headers).\n'
                                                    ' */'),
                             postComment=None))
Macro:
MacroParts(name=Token(idx=0, range=(17377, 17402), value='WT_BLOCK_HEADER_BYTE_SIZE'),
           args=None,
           body=Token(idx=0, range=(17403, 17448), value='(WT_PAGE_HEADER_SIZE + WT_BLOCK_HEADER_SIZE)'),
           preComment=Token(idx=176,
                            range=(17234, 17368),
                            value='/*\n'
                                  ' * WT_BLOCK_HEADER_BYTE\n'
                                  ' * WT_BLOCK_HEADER_BYTE_SIZE --\n'
                                  ' *\tThe first usable data byte on the block (past the combined headers).\n'
                                  ' */'),
           is_va_args=False,
           is_wellformed=True,
           is_const=False)
Statement(tokens=[17448:17539] 〈#define WT_BLOCK_HEADER_BYTE(dsk) ((void *)((uint8_t *)(dsk) + WT_BLOCK_HEADER_BYTE_SIZE))
〉,
          kind=StatementKind(is_comment=None,
                             is_preproc=True,
                             is_typedef=None,
                             is_record=None,
                             is_function=None,
                             is_function_def=None,
                             is_function_decl=None,
                             is_statement=None,
                             is_decl=None,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=None,
                             postComment=None))
Macro:
MacroParts(name=Token(idx=0, range=(17456, 17476), value='WT_BLOCK_HEADER_BYTE'),
           args=[Token(idx=0, range=(17477, 17480), value='dsk')],
           body=Token(idx=0, range=(17482, 17539), value='((void *)((uint8_t *)(dsk) + WT_BLOCK_HEADER_BYTE_SIZE))'),
           preComment=None,
           is_va_args=False,
           is_wellformed=True,
           is_const=False)
Statement(tokens=[17539:18262] 〈
⌇/*
 * We don't compress or encrypt the block's WT_PAGE_HEADER or WT_BLOCK_HEADER structures because we
 * need both available with decompression or decryption. We use the WT_BLOCK_HEADER checksum and
 * on-disk size during salvage to figure out where the blocks are, and we use the WT_PAGE_HEADER
 * in-memory size during decompression and decryption to know how large a target buffer to allocate.
 * We can only skip the header information when doing encryption, but we skip the first 64B when
 * doing compression; a 64B boundary may offer better alignment for the underlying compression
 * engine, and skipping 64B shouldn't make any difference in terms of compression efficiency.
 */⌇
⌇#define WT_BLOCK_COMPRESS_SKIP 64
〉,
          kind=StatementKind(is_comment=True,
                             is_preproc=True,
                             is_typedef=None,
                             is_record=None,
                             is_function=None,
                             is_function_def=None,
                             is_function_decl=None,
                             is_statement=None,
                             is_decl=None,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=Token(idx=181,
                                              range=(17540, 18227),
                                              value='/*\n'
                                                    " * We don't compress or encrypt the block's WT_PAGE_HEADER or "
                                                    'WT_BLOCK_HEADER structures because we\n'
                                                    ' * need both available with decompression or decryption. We use '
                                                    'the WT_BLOCK_HEADER checksum and\n'
                                                    ' * on-disk size during salvage to figure out where the blocks '
                                                    'are, and we use the WT_PAGE_HEADER\n'
                                                    ' * in-memory size during decompression and decryption to know how '
                                                    'large a target buffer to allocate.\n'
                                                    ' * We can only skip the header information when doing encryption, '
                                                    'but we skip the first 64B when\n'
                                                    ' * doing compression; a 64B boundary may offer better alignment '
                                                    'for the underlying compression\n'
                                                    " * engine, and skipping 64B shouldn't make any difference in "
                                                    'terms of compression efficiency.\n'
                                                    ' */'),
                             postComment=None))
Macro:
MacroParts(name=Token(idx=0, range=(18236, 18258), value='WT_BLOCK_COMPRESS_SKIP'),
           args=None,
           body=Token(idx=0, range=(18259, 18262), value='64'),
           preComment=Token(idx=181,
                            range=(17540, 18227),
                            value='/*\n'
                                  " * We don't compress or encrypt the block's WT_PAGE_HEADER or WT_BLOCK_HEADER "
                                  'structures because we\n'
                                  ' * need both available with decompression or decryption. We use the WT_BLOCK_HEADER '
                                  'checksum and\n'
                                  ' * on-disk size during salvage to figure out where the blocks are, and we use the '
                                  'WT_PAGE_HEADER\n'
                                  ' * in-memory size during decompression and decryption to know how large a target '
                                  'buffer to allocate.\n'
                                  ' * We can only skip the header information when doing encryption, but we skip the '
                                  'first 64B when\n'
                                  ' * doing compression; a 64B boundary may offer better alignment for the underlying '
                                  'compression\n'
                                  " * engine, and skipping 64B shouldn't make any difference in terms of compression "
                                  'efficiency.\n'
                                  ' */'),
           is_va_args=False,
           is_wellformed=True,
           is_const=True)
Statement(tokens=[18262:18318] 〈#define WT_BLOCK_ENCRYPT_SKIP WT_BLOCK_HEADER_BYTE_SIZE
〉,
          kind=StatementKind(is_comment=None,
                             is_preproc=True,
                             is_typedef=None,
                             is_record=None,
                             is_function=None,
                             is_function_def=None,
                             is_function_decl=None,
                             is_statement=None,
                             is_decl=None,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=None,
                             postComment=None))
Macro:
MacroParts(name=Token(idx=0, range=(18270, 18291), value='WT_BLOCK_ENCRYPT_SKIP'),
           args=None,
           body=Token(idx=0, range=(18292, 18318), value='WT_BLOCK_HEADER_BYTE_SIZE'),
           preComment=None,
           is_va_args=False,
           is_wellformed=True,
           is_const=False)
Statement(tokens=[18318:18530] 〈
⌇/*
 * __wt_block_header --
 *     Return the size of the block-specific header.
 */⌇
⌇static⌇ ⌇WT_INLINE⌇ ⌇u_int⌇
⌇__wt_block_header⌇(WT_BLOCK *block)⌇
⌇{
    WT_UNUSED(block);

    return ((u_int)WT_BLOCK_HEADER_SIZE);
}⌇
〉,
          kind=StatementKind(is_comment=True,
                             is_preproc=None,
                             is_typedef=None,
                             is_record=None,
                             is_function=True,
                             is_function_def=True,
                             is_function_decl=True,
                             is_statement=None,
                             is_decl=True,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=Token(idx=186,
                                              range=(18319, 18402),
                                              value='/*\n'
                                                    ' * __wt_block_header --\n'
                                                    ' *     Return the size of the block-specific header.\n'
                                                    ' */'),
                             postComment=None))
Function:
FunctionParts(typename=[18420:18425] 〈u_int〉,
              name=Token(idx=194, range=(18426, 18443), value='__wt_block_header'),
              args=Token(idx=195, range=(18444, 18459), value='WT_BLOCK *block'),
              body=Token(idx=197,
                         range=(18462, 18528),
                         value='\n    WT_UNUSED(block);\n\n    return ((u_int)WT_BLOCK_HEADER_SIZE);\n'),
              preComment=Token(idx=186,
                               range=(18319, 18402),
                               value='/*\n'
                                     ' * __wt_block_header --\n'
                                     ' *     Return the size of the block-specific header.\n'
                                     ' */'),
              postComment=None,
              is_type_const=False,
              is_type_static=True)
Args:
[Variable(name=Token(idx=3, range=(18454, 18459), value='block'),
          typename=[18444:18452] 〈WT_BLOCK〉,
          preComment=None,
          postComment=None,
          end=None)]
Vars:
[]
Statement(tokens=[18530:18869] 〈
⌇/*
 * __wt_block_eligible_for_sweep --
 *     Return true if the block meets requirements for sweeping. The check that read reference count
 *     is zero is made elsewhere.
 */⌇
⌇static⌇ ⌇WT_INLINE⌇ ⌇bool⌇
⌇__wt_block_eligible_for_sweep⌇(WT_BM *bm, WT_BLOCK *block)⌇
⌇{
    return (!block->remote && block->objectid <= bm->max_flushed_objectid);
}⌇
〉,
          kind=StatementKind(is_comment=True,
                             is_preproc=None,
                             is_typedef=None,
                             is_record=None,
                             is_function=True,
                             is_function_def=True,
                             is_function_decl=True,
                             is_statement=None,
                             is_decl=True,
                             is_expression=None,
                             is_initialization=None,
                             is_extern_c=None,
                             is_unnamed_record=None,
                             end=None,
                             preComment=Token(idx=200,
                                              range=(18531, 18708),
                                              value='/*\n'
                                                    ' * __wt_block_eligible_for_sweep --\n'
                                                    ' *     Return true if the block meets requirements for sweeping. '
                                                    'The check that read reference count\n'
                                                    ' *     is zero is made elsewhere.\n'
                                                    ' */'),
                             postComment=None))
Function:
FunctionParts(typename=[18726:18730] 〈bool〉,
              name=Token(idx=208, range=(18731, 18760), value='__wt_block_eligible_for_sweep'),
              args=Token(idx=209, range=(18761, 18787), value='WT_BM *bm, WT_BLOCK *block'),
              body=Token(idx=211,
                         range=(18790, 18867),
                         value='\n    return (!block->remote && block->objectid <= bm->max_flushed_objectid);\n'),
              preComment=Token(idx=200,
                               range=(18531, 18708),
                               value='/*\n'
                                     ' * __wt_block_eligible_for_sweep --\n'
                                     ' *     Return true if the block meets requirements for sweeping. The check that '
                                     'read reference count\n'
                                     ' *     is zero is made elsewhere.\n'
                                     ' */'),
              postComment=None,
              is_type_const=False,
              is_type_static=True)
Args:
[Variable(name=Token(idx=3, range=(18768, 18770), value='bm'),
          typename=[18761:18766] 〈WT_BM〉,
          preComment=None,
          postComment=None,
          end=','),
 Variable(name=Token(idx=9, range=(18782, 18787), value='block'),
          typename=[18772:18780] 〈WT_BLOCK〉,
          preComment=None,
          postComment=None,
          end=None)]
Vars:
[]