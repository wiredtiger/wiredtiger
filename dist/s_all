#!/bin/bash

# Run standard scripts.
t=__wt.$$
t_pfx=__s_all_tmp_
trap 'rm -f $t *.pyc __tmp* __wt.* __s_all_tmp*; kill -- `jobs -p | sed 's/^/-/'` 2>/dev/null' 0 1 2 3 13 15

# We require python3 which may not be installed.
type python3 > /dev/null 2>&1 || {
    echo 's_all: python3 not found'
    exit 1
}

echo 'dist/s_all run started...'

fast=""
force=
errmode=0
errfound=0

while :
    do case "$1" in
    -E)    # Return an error code on failure
        errmode=1
        shift;;
    -f)    # Force versions to be updated
        force="-f"
        shift;;
    -F) # Run fast.
        echo "dist/s_all running in fast mode..."
        fast="-F"
        shift;;
    *)
        break;;
    esac
done

echo "Updating files that include the package version" &&
    bash ./s_version $force

errchk()
{
    if ! `test -s $2`; then
        return 0
    fi

    echo '#########' s_all run of: "$1" resulted in:$'\n'"$(cat $2)"$'\n''#########'

    # If the test was skipped or marked warning only, ignore the failure.
    { grep -q "$1.*skipped" $2 || test "$3" = "--warning-only"; } || {
        errfound=1;
        echo "$1" >> "${t_pfx}_errfound"
    }

    rm -f $2
    return $errfound
}

run()
{
    cmd="$1"
    name="${cmd%% *}"
    t="${t_pfx}-${name}-$$"
    [[ "$name" =~ .*\.py$ ]] && cmd="python3 $cmd" || cmd="/bin/bash $cmd"
    $cmd 2>&1 > $t
    errchk "$name" "$t" "$2"
}

# Non parallelizable scripts. The following scripts either modify files or
# already parallelize internally.
run "bash ./s_readme $force"
run "bash ./s_install $force"
run "python3 api_config_gen.py"
run "python3 api_err.py"
run "python3 flags.py"
run "python3 log.py"
run "python3 stat.py"
run "python3 verbose.py"
run "bash ./s_copyright"
run "bash ./s_style ${fast}"
run "./s_clang_format ${fast}"
run "python3 prototypes.py"
run "bash ./s_typedef -b"
run "python3 test_tag.py"
# The s_mentions script requires bash.
run "./s_mentions" "--warning-only"

for cmd in \
    "s_define" \
    "s_docs" \
    "s_evergreen" \
    "s_evergreen_validate ${fast}" \
    "s_export" \
    "s_free" \
    "s_funcs" \
    "s_function ${fast}" \
    "s_getopt" \
    "s_lang" \
    "s_longlines" \
    "s_python" \
    "s_stat" \
    "s_string" \
    "s_tags" \
    "s_typedef -c" \
    "s_visibility_checks" \
    "s_void" \
    "s_whitespace" \
    "function.py" \
    "style.py" \
    "comment_style.py ${fast}" \
    "type_to_str.py" \
    ;
do
    run "$cmd" &
done
wait

[[ -s "${t_pfx}_errfound" ]] && errfound=1

echo "dist/s_all run finished. Error? $errfound"
[[ $errfound -ne 0 ]] && echo Errors in: `cat "${t_pfx}_errfound"`
if test $errmode -ne 0; then
    exit $errfound;
fi
exit 0
