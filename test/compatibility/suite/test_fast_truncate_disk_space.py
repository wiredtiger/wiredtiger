#!/usr/bin/env python
#
# Public Domain 2014-present MongoDB, Inc.
# Public Domain 2008-2014 WiredTiger, Inc.
#
# This is free and unencumbered software released into the public domain.
#
# Anyone is free to copy, modify, publish, use, compile, sell, or
# distribute this software, either in source code form or as a compiled
# binary, for any purpose, commercial or non-commercial, and by any
# means.
#
# In jurisdictions that recognize copyright laws, the author or authors
# of this software dedicate any and all copyright interest in the
# software to the public domain. We make this dedication for the benefit
# of the public at large and to the detriment of our heirs and
# successors. We intend this dedication to be an overt act of
# relinquishment in perpetuity of all present and future rights to this
# software under copyright law.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
# OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
# OTHER DEALINGS IN THE SOFTWARE.

import compatibility_test, os

class test_fast_truncate_disk_space(compatibility_test.CompatibilityTestCase):
    '''
    Test disk space usage with fast-truncate information across database upgrade and downgrade.
    Disk space should not be leaked if fast-truncate information is written out and the
    database is downgraded.
    '''

    # Use a standalone build.
    build_config = {'standalone': True}

    # For this test specifically, the older branch needs to be restricted to 6.0. The purpose
    # of this test is to ensure version 6.0 is able to clean up pages containing fast-truncate
    # information because that particular version does not logically consider fast-truncate
    # information when operating.
    #
    # Newer versions will consider the fast-truncate information when operating, and so we may
    # not be able to immediately clean up pages containing this information. Hence, this test
    # should not be run as there is no guarantee of using less disk space and the assert
    # comparing disk space usage may fail.
    older = ['mongodb-6.0']

    # Use a small page size and lots of keys because we want to create lots
    # of individual pages in the file.
    config = 'allocation_size=512,leaf_page_max=512'
    nentries = 10000
    uri = 'file:test_fast_truncate'

    def timestamp_str(self, t):
        return '%x' % t

    def test_fast_truncate_disk_space(self):
        '''
        Demonstrate that checkpoint cleanup should clean up fast-truncated child pages
        to prevent leaking disk space.
        '''

        # Run the first part of the test on the 6.0 branch. This generates database files
        # that do not contain fast-truncate information.
        self.run_method_on_branch(self.older_branch, 'generate_older_database_files')

        # Run the second part of the test on the 7.0 branch. This reads 6.0 database files
        # and appends fast-truncate information onto database records when needed.
        self.run_method_on_branch(self.newer_branch, 'write_fast_truncate_info')

        # Show that running on an older branch with the cleanup logic does not leak disk space.
        self.run_method_on_branch(self.older_branch, 'read_fast_truncate_info_with_cleanup')

    def generate_older_database_files(self):
        import wiredtiger

        conn = wiredtiger.wiredtiger_open('.', 'create,')
        session = conn.open_session()
        session.begin_transaction()

        self.pr(f'Running on {wiredtiger.wiredtiger_version()[0]}')
        session.create(self.uri, self.config + ',key_format=i,value_format=S')

        c = session.open_cursor(self.uri)
        for i in range(1, self.nentries):
            c[i] = 'i' + str(i)
        c.close()

        session.commit_transaction('commit_timestamp=' + self.timestamp_str(2))

        session.checkpoint()

        session.close()
        conn.close()

    def write_fast_truncate_info(self):
        import wiredtiger
        from wiredtiger import stat

        # Open the connection on the database directory containing the database
        # generated by the older binary.
        new_conn = wiredtiger.wiredtiger_open('.', 'create=false,statistics=(all)')

        self.pr(f'Running on {wiredtiger.wiredtiger_version()[0]}')

        new_conn.set_timestamp('oldest_timestamp='+ self.timestamp_str(200))
        new_conn.set_timestamp('stable_timestamp='+ self.timestamp_str(200))

        session = new_conn.open_session()
        session.begin_transaction()

        # Truncate a big range of rows.
        start = session.open_cursor(self.uri, None)
        start.set_key(10)
        end = session.open_cursor(self.uri, None)
        end.set_key(self.nentries - 10)
        session.truncate(None, start, end, None)
        start.close()
        end.close()

        session.commit_transaction('commit_timestamp=' + self.timestamp_str(250))

        # Ensure that fast-truncate happened.
        stat_cursor = session.open_cursor('statistics:', None, None)
        fastdelete_pages = stat_cursor[stat.conn.rec_page_delete_fast][2]
        self.assertGreater(fastdelete_pages, 0)

        # Move the stable timestamp ahead of the fast-truncate timestamp so that
        # recovery will not remove this fast-truncate information.
        new_conn.set_timestamp('stable_timestamp='+ self.timestamp_str(300))

        # Checkpoint, forcing address-deleted cells to be written.
        session.checkpoint()

        session.close()
        new_conn.close()

        # Re-open the connection and verify the object.
        new_conn = wiredtiger.wiredtiger_open('.', 'create=false')
        session = new_conn.open_session()
        session.verify(self.uri)

        session.close()
        new_conn.close()

    def read_fast_truncate_info_with_cleanup(self):
        import wiredtiger

        # Open the connection on the database directory containing the database
        # generated by the newer binary which contains fast-truncate information.
        new_conn = wiredtiger.wiredtiger_open('.', 'create=false')

        self.pr(f'Running on {wiredtiger.wiredtiger_version()[0]}')

        disk_space_original = os.path.getsize("test_fast_truncate")

        # Update some records in the truncate range to dirty the tree.
        # Additionally, do multiple checkpoints.
        session = new_conn.open_session()
        session.begin_transaction()
        c = session.open_cursor(self.uri)
        c.set_key(50)
        c.set_value("cleanup")
        c.update()
        c.reset()
        session.commit_transaction('commit_timestamp=' + self.timestamp_str(350))
        session.checkpoint()

        session.begin_transaction()
        c.set_key(5000)
        c.set_value("cleanup")
        c.update()
        c.reset()
        session.commit_transaction('commit_timestamp=' + self.timestamp_str(350))
        session.checkpoint()

        # Check that we are using less space than before after the pages
        # containing fast-truncate information were cleaned up.
        self.assertLess(os.path.getsize("test_fast_truncate"), disk_space_original)

        session.close()
        new_conn.close()

if __name__ == '__main__':
    compatibility_test.run()
