#!/usr/bin/env python
#
# Public Domain 2014-present MongoDB, Inc.
# Public Domain 2008-2014 WiredTiger, Inc.
#
# This is free and unencumbered software released into the public domain.
#
# Anyone is free to copy, modify, publish, use, compile, sell, or
# distribute this software, either in source code form or as a compiled
# binary, for any purpose, commercial or non-commercial, and by any
# means.
#
# In jurisdictions that recognize copyright laws, the author or authors
# of this software dedicate any and all copyright interest in the
# software to the public domain. We make this dedication for the benefit
# of the public at large and to the detriment of our heirs and
# successors. We intend this dedication to be an overt act of
# relinquishment in perpetuity of all present and future rights to this
# software under copyright law.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
# OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
# OTHER DEALINGS IN THE SOFTWARE.

import compatibility_test, os, shutil, sys

class test_fast_truncate_info(compatibility_test.CompatibilityTestCase):
    '''
    Test handling of fast-truncate information across database upgrade and downgrade.
    '''

    # Use a standalone build.
    build_config = {'standalone': True}

    # Use a small page size and lots of keys because we want to create lots
    # of individual pages in the file.
    config = 'allocation_size=512,leaf_page_max=512'
    nentries = 10000
    uri = 'file:test_fast_truncate'

    def timestamp_str(self, t):
        return '%x' % t

    def test_fast_truncate_data_format(self):
        '''
        Test downgrading after performing a non globally-visible fast-truncate operation
        on a major release newer than 6.1, which writes fast-truncate related information
        into the database file. The older version should still be able to parse through
        this fast-truncate information although it has no support to write it.
        '''

        # Run the first part of the test on the 6.0 branch. This generates database files
        # that do not contain fast-truncate information.
        self.run_method_on_branch(self.older_branch, 'generate_older_database_files')

        # Run the second part of the test on the 7.0 branch. This reads 6.0 database files
        # and appends fast-truncate information onto database records when needed.
        self.run_method_on_branch(self.newer_branch, 'write_fast_truncate_info')

        # Run the third part of the test on the 6.0 branch. This attempts to read database
        # files containing fast-truncate information from an older version that does not
        # support writing out fast-truncate information. We should be able to read the
        # information though we will simply ignore it.
        self.run_method_on_branch(self.older_branch, 'read_fast_truncate_info_from_older')

    def generate_older_database_files(self):
        import wiredtiger

        conn = wiredtiger.wiredtiger_open('.', 'create,')
        session = conn.open_session()

        self.pr(f'Running on {wiredtiger.wiredtiger_version()[0]}')
        session.create(self.uri, self.config + ',key_format=i,value_format=S')

        c = session.open_cursor(self.uri)
        for i in range(1, self.nentries):
            c[i] = 'i' + str(i)
        c.close()

        session.checkpoint()

        session.close()
        conn.close()

    def write_fast_truncate_info(self):
        import wiredtiger
        from wiredtiger import stat

        # Open the connection on the database directory containing the database
        # generated by the older binary.
        new_conn = wiredtiger.wiredtiger_open('.', 'create=false,statistics=(all)')

        self.pr(f'Running on {wiredtiger.wiredtiger_version()[0]}')

        new_conn.set_timestamp('oldest_timestamp='+ self.timestamp_str(200))
        new_conn.set_timestamp('stable_timestamp='+ self.timestamp_str(200))

        session = new_conn.open_session()
        session.begin_transaction()

        # Truncate a big range of rows.
        start = session.open_cursor(self.uri, None)
        start.set_key(10)
        end = session.open_cursor(self.uri, None)
        end.set_key(self.nentries - 10)
        session.truncate(None, start, end, None)
        start.close()
        end.close()

        session.commit_transaction('commit_timestamp=' + self.timestamp_str(250))

        # Ensure that fast-truncate happened.
        stat_cursor = session.open_cursor('statistics:', None, None)
        fastdelete_pages = stat_cursor[stat.conn.rec_page_delete_fast][2]
        self.assertGreater(fastdelete_pages, 0)

        # Move the stable timestamp ahead of the fast-truncate timestamp so that
        # recovery will not remove this fast-truncate information.
        new_conn.set_timestamp('stable_timestamp='+ self.timestamp_str(300))

        # Checkpoint, forcing address-deleted cells to be written.
        session.checkpoint()

        session.close()
        new_conn.close()

        # Re-open the connection and verify the object.
        new_conn = wiredtiger.wiredtiger_open('.', 'create=false')
        session = new_conn.open_session()
        session.verify(self.uri)

        session.close()
        new_conn.close()

    def read_fast_truncate_info_from_older(self):
        import wiredtiger

        # Open the connection on the database directory containing the database
        # generated by the newer binary which contains fast-truncate information.
        new_conn = wiredtiger.wiredtiger_open('.', 'create=false')

        self.pr(f'Running on {wiredtiger.wiredtiger_version()[0]}')

        # Open a cursor and update a record to dirty the tree.
        session = new_conn.open_session()
        c = session.open_cursor(self.uri)
        c.set_key(5)
        c.set_value("downgraded")
        c.update()
        c.reset()

        # Do a direct search for a key inside the truncated range - this key
        # should not be visible.
        c.set_key(1000)
        self.assertEqual(c.search(), wiredtiger.WT_NOTFOUND)
        c.close()

        # Do a checkpoint, which triggers the packing and unpacking logic.
        session.checkpoint()
        session.verify(self.uri)

        session.close()
        new_conn.close()

if __name__ == '__main__':
    compatibility_test.run()
