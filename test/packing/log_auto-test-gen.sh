#!/bin/bash

#
# This script generates test/packing/log_auto_fmt.h from an older src/log/log_auto.c
#

set -euo pipefail

GITHOME="$(git rev-parse --show-toplevel)"
cd "$GITHOME"

export MYNAME=`basename "$0"`

prepare_file() {
  perl -E '
    @a=<>;                                   # read all lines
    for (@a) { /^(?:#define\s+)?(__\w++)(?=\()/ and $fn{$1}=1; }  # collect locally defined functions and fn-like macros
    $FNRE = join "|", keys %fn;              # make a regex out of them
    print << "_END";
/* DO NOT EDIT: THIS FILE IS AUTOMATICALLY GENERATED BY $ENV{MYNAME} */

#pragma GCC diagnostic error "-Wno-used-but-marked-unused"
#pragma clang diagnostic ignored "-Wused-but-marked-unused"

#ifdef WT_STRUCT_PACKING_@{[uc $ENV{SUFFIX}]}
@{[join "\n", map {"#define ${_} ${_}__$ENV{SUFFIX}"} sort keys %fn]}
#endif
_END
    for (@a) {
#        /^#include |DO NOT EDIT/ && next;    # strip includes and previous "DO NOT EDIT" notice
        s/^(int|void)/__attribute__((__unused__))\nstatic $1/ ||          # add "static" to all function defs
        s/($FNRE)/${1}__$ENV{SUFFIX}/g;      # append suffix to all locally defined funcs
        print;
    }'
}

git show 3f576a00af:src/log/log_auto.c | SUFFIX=fmt    prepare_file > test/packing/log_auto_fmt.h
                cat src/log/log_auto.c | SUFFIX=direct prepare_file > test/packing/log_auto_direct.h


cd dist
python3 << "_END" > ../test/packing/log_auto_test.h
import os
from log import *

S = '\\'
NN = '\\n'
TT = '\\t'
N = '\n'
T = '\t'

print(f'''/* DO NOT EDIT: THIS FILE IS AUTOMATICALLY GENERATED BY {os.environ['MYNAME']} */

#pragma GCC diagnostic error "-Wno-used-but-marked-unused"
#pragma clang diagnostic ignored "-Wused-but-marked-unused"

#include "log_auto_fmt.h"
#include "log_auto_direct.h"


#define testutil_assertfmt__(a, fmt, ...)                                               {S}
    do {{                                                                                {S}
        if (!(a))                                                                       {S}
            testutil_die(0, "{NN}%s:%d:{NN}  %s:{NN}    " fmt, __FILE__, __LINE__, __PRETTY_FUNCTION__, __VA_ARGS__); {S}
    }} while (0)

#define assert_eq(a, b) testutil_assertfmt__((a) == (b), "%s != %s", #a, #b)
#define assert_eq_uint16_t(a, b) testutil_assertfmt__((a) == (b), "%s != %s : (%u) != (%u)", #a, #b, (a), (b))
#define assert_eq_uint32_t(a, b) testutil_assertfmt__((a) == (b), "%s != %s : (%lu) != (%lu)", #a, #b, (a), (b))
#define assert_eq_uint64_t(a, b) testutil_assertfmt__((a) == (b), "%s != %s : (%llu) != (%llu)", #a, #b, (a), (b))

''')

def optype_format_args(optype):
    return {
        'local_decls': (('\n'.join(
            '    '+f.ctype+' '+f.fieldname+';'
            for f in optype.fields))
            if optype.fields else ''),
        'local_decls2': (('\n'.join(
            '    const char *'+f.fieldname+'_fmt, *'+f.fieldname+'_direct;'
            if f.typename == 'string' else
            '    '+f.ctype+' '+f.fieldname+'_fmt, '+f.fieldname+'_direct;'
            for f in optype.fields))
            if optype.fields else ''),
        'local_init2': (('\n'.join(
            '    '+f.fieldname+'_fmt.data='+f.fieldname+'->data; '+f.fieldname+'_direct.data='+f.fieldname+'->data;'+
            '    '+f.fieldname+'_fmt.size='+f.fieldname+'->size; '+f.fieldname+'_direct.size='+f.fieldname+'->size;'
            if f.typename == 'WT_ITEM' else
            '    '+f.fieldname+'_fmt.l.file='+f.fieldname+'->l.file; '+f.fieldname+'_direct.l.file='+f.fieldname+'->l.file;'+
            '    '+f.fieldname+'_fmt.l.offset='+f.fieldname+'->l.offset; '+f.fieldname+'_direct.l.offset='+f.fieldname+'->l.offset;'
            if f.typename == 'WT_LSN' else
            '    '+f.fieldname+'_fmt='+f.fieldname+'; '+f.fieldname+'_direct='+f.fieldname+';'
            for f in optype.fields))
            if optype.fields else ''),
        'arg_decls_in': ''.join(', ' + f.cindecl for f in optype.fields),
        'pack_args': ''.join(', ' + ('&' if f.byptr else '') + f.fieldname for f in optype.fields),
        'pack_args_fmt': ''.join(', ' + ('&' if f.byptr else '') + f.fieldname + '_fmt' for f in optype.fields),
        'pack_args_direct': ''.join(', ' + ('&' if f.byptr else '') + f.fieldname + '_direct' for f in optype.fields),
        'unpack_args_fmt': ''.join(', &' + f.fieldname + '_fmt' for f in optype.fields),
        'unpack_args_direct': ''.join(', &' + f.fieldname + '_direct' for f in optype.fields),
        'check_fields': '\n'.join(
            '    assert_eq_uint64_t('+f.fieldname+'_fmt.size, '+f.fieldname+'_direct.size);\n    assert(memcmp('+f.fieldname+'_fmt.data, '+f.fieldname+'_direct.data, '+f.fieldname+'_fmt.size) == 0);\n'
            if f.typename == 'WT_ITEM' else
            '    assert('+f.fieldname+'_fmt.l.file == '+f.fieldname+'_direct.l.file);\n    assert('+f.fieldname+'_fmt.l.offset == '+f.fieldname+'_direct.l.offset);\n'
            if f.typename == 'WT_LSN' else
            '    assert(!strcmp('+f.fieldname+'_fmt, '+f.fieldname+'_direct));'
            if f.typename == 'string' else
            '    assert_eq_'+f.ctype+'('+f.fieldname+'_fmt, '+f.fieldname+'_direct);'
            for f in optype.fields),
    }

def optype_format_local_init(optype, name, init):
    return {
        name: (('\n'.join(
            '    '+f.fieldname+'.data='+init['WT_ITEM']['data']+';'
            '    '+f.fieldname+'.size='+init['WT_ITEM']['size']+';'
            if f.typename == 'WT_ITEM' else
            '    '+f.fieldname+'.l.file=(uint32_t)('+init['WT_LSN']['file']+');'
            '    '+f.fieldname+'.l.offset=(uint32_t)('+init['WT_LSN']['offset']+');'
            if f.typename == 'WT_LSN' else
            '    '+f.fieldname+'='+init['string']+';'
            if f.typename == 'string' else
            '    '+f.fieldname+'=('+f.ctype+')('+init['int']+');'
            for f in optype.fields))
            if optype.fields else ''),
    }


def optype_format_local_init_int(optype, name, num):
    return optype_format_local_init(optype, name, {
        'WT_ITEM': {'data': 'NULL', 'size': '0'},
        'WT_LSN': {'file': num, 'offset': num},
        'string': '""',
        'int': num,
    });


for optype in log_data.optypes:
    print('''
__attribute__((__unused__))
static void
test_cmp_one__wt_logop_{optype.name}(WT_SESSION_IMPL *session, WT_ITEM *logrec_fmt, WT_ITEM *logrec_direct{arg_decls_in}) {{
    const uint8_t *data_fmt, *data_direct;
    /*size_t sz_fmt, sz_direct;*/
{local_decls2}

{local_init2}
    logrec_fmt->size = logrec_direct->size = 0;
    /*sz_fmt = logrec_fmt->size;*/
    /*sz_direct = logrec_direct->size;*/

    /* test packing */
    assert(__wt_logop_{optype.name}_pack__fmt(session, logrec_fmt{pack_args_fmt}) == 0);
    assert(__wt_logop_{optype.name}_pack__direct(session, logrec_direct{pack_args_direct}) == 0);

    assert_eq_uint64_t(logrec_fmt->size, logrec_direct->size);
    assert(memcmp(logrec_fmt->data, logrec_direct->data, logrec_fmt->size) == 0);

    /* test unpacking */
    data_fmt = logrec_fmt->data;
    data_direct = logrec_direct->data;
    assert(__wt_logop_{optype.name}_unpack__fmt(session, &data_fmt, data_fmt+logrec_fmt->size{unpack_args_fmt}) == 0);
    assert(__wt_logop_{optype.name}_unpack__direct(session, &data_direct, data_direct+logrec_direct->size{unpack_args_direct}) == 0);

{check_fields}
    /*logrec_fmt->size = sz_fmt;*/
    /*logrec_direct->size = sz_direct;*/
}}
'''.format(
    **optype_format_args(optype),
    **locals()))


for optype in log_data.optypes:
    print('''
__attribute__((__unused__))
static void
test_cmp_all__wt_logop_{optype.name}(WT_SESSION_IMPL *session, WT_ITEM *logrec_fmt, WT_ITEM *logrec_direct) {{
{local_decls}

{local_init_test_int1}
    test_cmp_one__wt_logop_{optype.name}(session, logrec_fmt, logrec_direct{pack_args});

{local_init_test_int2}
    test_cmp_one__wt_logop_{optype.name}(session, logrec_fmt, logrec_direct{pack_args});

{local_init_test_int3}
    test_cmp_one__wt_logop_{optype.name}(session, logrec_fmt, logrec_direct{pack_args});

{local_init_test_int4}
    test_cmp_one__wt_logop_{optype.name}(session, logrec_fmt, logrec_direct{pack_args});

{local_init_test_int5}
    test_cmp_one__wt_logop_{optype.name}(session, logrec_fmt, logrec_direct{pack_args});

{local_init_test_int6}
    test_cmp_one__wt_logop_{optype.name}(session, logrec_fmt, logrec_direct{pack_args});

{local_init_test_int7}
    test_cmp_one__wt_logop_{optype.name}(session, logrec_fmt, logrec_direct{pack_args});

{local_init_test_int8}
    test_cmp_one__wt_logop_{optype.name}(session, logrec_fmt, logrec_direct{pack_args});

{local_init_test_int9}
    test_cmp_one__wt_logop_{optype.name}(session, logrec_fmt, logrec_direct{pack_args});

{local_init_test_data1}
    test_cmp_one__wt_logop_{optype.name}(session, logrec_fmt, logrec_direct{pack_args});
}}
'''.format(
            **optype_format_args(optype),
            **optype_format_local_init_int(optype, 'local_init_test_int1', '0'),
            **optype_format_local_init_int(optype, 'local_init_test_int2', '1'),
            **optype_format_local_init_int(optype, 'local_init_test_int3', 'POS_1BYTE_MAX-1'),
            **optype_format_local_init_int(optype, 'local_init_test_int4', 'POS_1BYTE_MAX'),
            **optype_format_local_init_int(optype, 'local_init_test_int5', 'POS_1BYTE_MAX+1'),
            **optype_format_local_init_int(optype, 'local_init_test_int6', 'POS_2BYTE_MAX-1'),
            **optype_format_local_init_int(optype, 'local_init_test_int7', 'POS_2BYTE_MAX'),
            **optype_format_local_init_int(optype, 'local_init_test_int8', 'POS_2BYTE_MAX+1'),
            **optype_format_local_init_int(optype, 'local_init_test_int9', 'rand()'),
            **optype_format_local_init(optype, 'local_init_test_data1', {
                'WT_ITEM': {'data': '"data"', 'size': '4'},
                'WT_LSN': {'file': 'rand()', 'offset': 'rand()'},
                'string': '"string"',
                'int': 'rand()',
            }),
            **locals()
        )
    )



print(f'''

__attribute__((__unused__))
static void
test_cmp_all(WT_SESSION_IMPL *session) {{
    WT_ITEM logrec_fmt, logrec_direct;

    WT_CLEAR(logrec_fmt);
    assert(__wt_buf_init(session, &logrec_fmt, 0) == 0);
    WT_CLEAR(logrec_direct);
    assert(__wt_buf_init(session, &logrec_direct, 0) == 0);

''')

for optype in log_data.optypes:
    print('    test_cmp_all__wt_logop_{optype.name}(session, &logrec_fmt, &logrec_direct);'.format(
        **optype_format_args(optype),
        **locals()))

print(f'''

    __wt_buf_free(session, &logrec_fmt);
    __wt_buf_free(session, &logrec_direct);
}}

''')

_END

./s_clang_format "$GITHOME/test/packing/log_auto_test.h"
