Memrata/KVS README.

The basic data structures are: "KVS sources" which map to one or more
physical devices; each KVS source supports any number of WiredTiger sources,
where a WiredTiger source will be an object similar to a "file:" object.

Each WiredTiger source supports any number of WiredTiger cursors.

For each WiredTiger source, we create two namespaces on the underlying device,
a "cache" and a "primary".

The cache contains key/value pairs based on updates or changes that have been
made, and includes transactional information.  So, for example, if transaction
3 modifies key/value pair "foo/aaa", and then transaction 4 removes key "foo",
then transaction 5 inserts key/value pair "foo/bbb", the entry in the cache
will look something like:

	Key:	foo
	Value:	[transaction ID 3] [aaa]
		[transaction ID 4] [remove]
		[transaction ID 5] [bbb]

Obviously, we have to marshall/unmarshall these values to/from the cache.

In contrast, the primary contains only key/value pairs known to be committed
and visible to any reader.

When an insert, update or remove is done:
	acquire a lock
	read any matching key from the cache
	check to see if the update can proceed
	append a new value for this transaction
	release the lock

When a search is done:
	if there's a matching key/value pair in the cache {
		if there's an item visible to the reading transaction
			return it
	}
	if there's a matching key/value pair in the primary {
		return it
	}

When a next/prev is done:
	move to the next/prev visible item in the cache
	move to the next/prev visible item in the primary
	return the one closest to the starting position

Note locks are not acquired for read operations, and no flushes are done for
any of these operations.

We also create one additional namespace, the "txn" name space, which serves
all of the WiredTiger and KVS sources.  Whenever a transaction commits, we
insert a commit record into the txn name space and flush the device.  When a
transaction rolls back, we insert a rollback record into the txn name space,
but don't flush the device.

The visibility check is slightly different than the rest of WiredTiger: we do
not reset anything when a transaction aborts, and so we have to check the
transaction ID for visibility as well as if the transaction has been aborted.

We create a "cleanup" thread for every KVS source.  The job of this thread is
to migrate rows from the cache into the primary.  Any committed, globally
visible change in the cache can be copied into the primary and removed from
the cache:

	set BaseTxnID to the oldest transaction ID
	    not yet visible to a running transaction

	for each row in the cache:
		if all of the updates are greater than BaseTxnID
			copy the last update to the primary

	flush the primary to stable storage

	lock the cache
	for each row in the cache:
		if all of the updates are greater than BaseTxnID
			remove the row from the cache
	unlock the cache

	for each row in the transaction store:
		if the transaction ID is less than BaseTxnID
			remove the row

We only need to lock the cache when removing rows, the initial copy to the
primary does not require a lock.

No lock is required when removing rows from the transaction store, once the
transaction ID is less than the BaseTxnID, it will never be read.

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Questions, problems, whatever:

* This design doesn't support named checkpoints.

* This implementation is endian-specific, that is, a store created on a
little-endian machine is not portable to a big-endian machine.

* Recovery is not yet implemented.  The process is the same as migrating rows
from the cache to the primary, with the BaseTxnID set to the maximum possible
transaction ID, that is, all updates are globally visible by definition, and
all update elements are discarded.

    We don't need recovery: we can simply start using the cache again, it's
up-to-date (once transaction IDs are durable in WiredTiger).

    We can't discard any elements from the txn namespace until we know all of
the objects have been opened and "recovered", else we'd discard commit records
and that's not safe.   Can we depend on all data sources being opened before
we change any of them?

    What if the txn namespace isn't found -- we have to open the devices in
the same order to find it, which we can't guarantee?

    For now, we should limit ourselves to a single KVS device.

* Each open-cursor call has to list the KVS devices for the object (and
they must be the same as the ones used to create the object).  We need a
better naming scheme.

* Consider ways to avoid the lookup to see if a transaction has aborted
(maybe avoid the lookup when there are no aborted transactions in the
transaction store, which should be the case most of the time).

* There's a general problem with data-sources in WiredTiger.   If we commit
and push the commit record to stable storage, and then crash, the enclosing
WiredTiger transaction will/should end up aborting, and there's no way for us
to back out the change in KVS.  This only applies to transactions that span
more than one data-source; I'm leaving this problem alone until fine-grained
durability is complete, we're going to need WiredTiger support to solve this.

* If a record in the cache gets too busy, we could end up unable to remove it
(there would always be an active transaction), and it would grow forever.  I
suspect the solution is to clean it up when we realize we can't remove it,
that is, we can rebuild the record, discarding the no longer needed entries.
