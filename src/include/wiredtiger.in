/*-
 * Copyright (c) 2008-2013 WiredTiger, Inc.
 *	All rights reserved.
 *
 * See the file LICENSE for redistribution information.
 */

#ifndef	__WIREDTIGER_H_
#define	__WIREDTIGER_H_

#if defined(__cplusplus)
extern "C" {
#endif

/*******************************************
 * Version information
 *******************************************/
#define	WIREDTIGER_VERSION_MAJOR	@VERSION_MAJOR@
#define	WIREDTIGER_VERSION_MINOR	@VERSION_MINOR@
#define	WIREDTIGER_VERSION_PATCH	@VERSION_PATCH@
#define	WIREDTIGER_VERSION_STRING	@VERSION_STRING@

/*******************************************
 * Required includes
 *******************************************/
@wiredtiger_includes_decl@

/*******************************************
 * Portable type names
 *******************************************/
@int8_decl@
@u_int8_decl@
@int16_decl@
@u_int16_decl@
@int32_decl@
@u_int32_decl@
@int64_decl@
@u_int64_decl@

@u_char_decl@
@u_short_decl@
@u_int_decl@
@u_long_decl@
@u_quad_decl@

@uintmax_t_decl@
@uintptr_t_decl@

#if defined(DOXYGEN) || defined(SWIG)
#define	__F(func) func
#else
#define	__F(func) (*func)
#endif

#ifdef SWIG
%{
#include <wiredtiger.h>
%}
#endif

/*!
 * @defgroup wt WiredTiger API
 * The functions, handles and methods applications use to access and manage
 * data with WiredTiger.
 *
 * @{
 */

/*******************************************
 * Public forward structure declarations
 *******************************************/
struct __wt_collator;	    typedef struct __wt_collator WT_COLLATOR;
struct __wt_compressor;	    typedef struct __wt_compressor WT_COMPRESSOR;
struct __wt_connection;	    typedef struct __wt_connection WT_CONNECTION;
struct __wt_cursor;	    typedef struct __wt_cursor WT_CURSOR;
struct __wt_data_source;    typedef struct __wt_data_source WT_DATA_SOURCE;
struct __wt_event_handler;  typedef struct __wt_event_handler WT_EVENT_HANDLER;
struct __wt_extension_api;  typedef struct __wt_extension_api WT_EXTENSION_API;
struct __wt_extractor;	    typedef struct __wt_extractor WT_EXTRACTOR;
struct __wt_item;	    typedef struct __wt_item WT_ITEM;
struct __wt_session;	    typedef struct __wt_session WT_SESSION;

/*!
 * A raw item of data to be managed.  Data items have a pointer to the data and
 * a length (limited to 4GB for items stored in tables).
 */
struct __wt_item {
	/*!
	 * The memory reference of the data item.
	 *
	 * For items returned by a WT_CURSOR, the pointer is only valid until
	 * the next operation on that cursor.  Applications that need to keep
	 * an item across multiple cursor operations must make a copy.
	 */
	const void *data;

	/*!
	 * The number of bytes in the data item.
	 */
	uint32_t size;

#ifndef DOXYGEN
#define	WT_ITEM_ALIGNED					0x00000001
#define	WT_ITEM_INUSE					0x00000002
#define	WT_ITEM_MAPPED					0x00000004
	/* This appears in the middle of the struct to avoid padding. */
	/*! Object flags (internal use). */
	uint32_t flags;

	/*! Managed memory chunk (internal use). */
	void *mem;
	/*! Managed memory size (internal use). */
	size_t memsize;
#endif
};

/*!
 * The maximum packed size of a 64-bit integer.  The ::wiredtiger_struct_pack
 * function will pack single long integers into at most this many bytes.
 */
#define	WT_INTPACK64_MAXSIZE	((int)sizeof (int64_t) + 1)

/*!
 * The maximum packed size of a 32-bit integer.  The ::wiredtiger_struct_pack
 * function will pack single integers into at most this many bytes.
 */
#define	WT_INTPACK32_MAXSIZE	((int)sizeof (int32_t) + 1)

/*!
 * A WT_CURSOR handle is the interface to a cursor.
 *
 * Cursors allow data to be searched, iterated and modified, implementing the
 * CRUD (create, read, update and delete) operations.  Cursors are opened in
 * the context of a session.  If a transaction is started, cursors operate in
 * the context of the transaction until the transaction is resolved.
 *
 * Raw data is represented by key/value pairs of WT_ITEM structures, but
 * cursors can also provide access to fields within the key and value if the
 * formats are described in the WT_SESSION::create method.
 *
 * In the common case, a cursor is used to access records in a table.  However,
 * cursors can be used on subsets of tables (such as a single column or a
 * projection of multiple columns), as an interface to statistics, configuration
 * data or application-specific data sources.  See WT_SESSION::open_cursor for
 * more information.
 *
 * <b>Thread safety:</b> A WT_CURSOR handle is not usually shared between
 * threads, see @ref threads for more information.
 */
struct __wt_cursor {
	WT_SESSION *session;	/*!< The session handle for this cursor. */

	/*!
	 * The name of the data source for the cursor, matches the \c uri
	 * parameter to WT_SESSION::open_cursor used to open the cursor.
	 */
	const char *uri;

	/*!
	 * The format of the data packed into key items.  See @ref packing for
	 * details.  If not set, a default value of "u" is assumed, and
	 * applications must use WT_ITEM structures to manipulate untyped byte
	 * arrays.
	 */
	const char *key_format;

	/*!
	 * The format of the data packed into value items.  See @ref packing
	 * for details.  If not set, a default value of "u" is assumed, and
	 * applications must use WT_ITEM structures to manipulate untyped byte
	 * arrays.
	 */
	const char *value_format;

	/*!
	 * @name Data access
	 * @{
	 */
	/*!
	 * Get the key for the current record.
	 *
	 * @snippet ex_all.c Get the cursor's string key
	 *
	 * @snippet ex_all.c Get the cursor's record number key
	 *
	 * @param cursor the cursor handle
	 * @param ... pointers to hold key fields corresponding to
	 * WT_CURSOR::key_format.
	 * @errors
	 */
	int __F(get_key)(WT_CURSOR *cursor, ...);

	/*!
	 * Get the value for the current record.
	 *
	 * @snippet ex_all.c Get the cursor's string value
	 *
	 * @snippet ex_all.c Get the cursor's raw value
	 *
	 * @param cursor the cursor handle
	 * @param ... pointers to hold value fields corresponding to
	 * WT_CURSOR::value_format.
	 * @errors
	 */
	int __F(get_value)(WT_CURSOR *cursor, ...);

	/*!
	 * Set the key for the next operation.
	 *
	 * @snippet ex_all.c Set the cursor's string key
	 *
	 * @snippet ex_all.c Set the cursor's record number key
	 *
	 * @param cursor the cursor handle
	 * @param ... key fields corresponding to WT_CURSOR::key_format.
	 *
	 * If an error occurs during this operation, a flag will be set in the
	 * cursor, and the next operation to access the key will fail.  This
	 * simplifies error handling in applications.
	 */
	void __F(set_key)(WT_CURSOR *cursor, ...);

	/*!
	 * Set the value for the next operation.
	 *
	 * @snippet ex_all.c Set the cursor's string value
	 *
	 * @snippet ex_all.c Set the cursor's raw value
	 *
	 * @param cursor the cursor handle
	 * @param ... value fields corresponding to WT_CURSOR::value_format.
	 *
	 * If an error occurs during this operation, a flag will be set in the
	 * cursor, and the next operation to access the value will fail.  This
	 * simplifies error handling in applications.
	 */
	void __F(set_value)(WT_CURSOR *cursor, ...);
	/*! @} */

	/*!
	 * @name Cursor positioning
	 * @{
	 */
	/*!
	 * Return the ordering relationship between two cursors: both cursors
	 * must have the same data source and have valid keys.
	 *
	 * @snippet ex_all.c Cursor comparison
	 *
	 * @param cursor the cursor handle
	 * @param other another cursor handle
	 * @param comparep the status of the comparison: < 0 if
	 * <code>cursor</code> refers to a key that appears before
	 * <code>other</code>, 0 if the cursors refer to the same key,
	 * and > 0 if <code>cursor</code> refers to a key that appears after
	 * <code>other</code>.
	 * @errors
	 */
	int __F(compare)(WT_CURSOR *cursor, WT_CURSOR *other, int *comparep);

	/*!
	 * Return the next record.
	 *
	 * @snippet ex_all.c Return the next record
	 *
	 * @param cursor the cursor handle
	 * @errors
	 */
	int __F(next)(WT_CURSOR *cursor);

	/*!
	 * Return the previous record.
	 *
	 * @snippet ex_all.c Return the previous record
	 *
	 * @param cursor the cursor handle
	 * @errors
	 */
	int __F(prev)(WT_CURSOR *cursor);

	/*!
	 * Reset the position of the cursor.  Any resources held by the cursor
	 * are released, and the cursor's key and position are no longer valid.
	 * A subsequent iteration with WT_CURSOR::next will move to the first
	 * record, or with WT_CURSOR::prev will move to the last record.
	 *
	 * @snippet ex_all.c Reset the cursor
	 *
	 * @param cursor the cursor handle
	 * @errors
	 */
	int __F(reset)(WT_CURSOR *cursor);

	/*!
	 * Move to the record matching the key. The key must first be set.
	 *
	 * @snippet ex_all.c Search for an exact match
	 *
	 * @param cursor the cursor handle
	 * @errors
	 */
	int __F(search)(WT_CURSOR *cursor);

	/*!
	 * Move to the record matching the key if it exists, or a record that
	 * would be adjacent.  Either the smallest record larger than the key
	 * or the largest record smaller than the key (in other words, a
	 * logically adjacent key).  The key must first be set.
	 *
	 * @snippet ex_all.c Search for an exact or adjacent match
	 *
	 * @snippet ex_all.c Forward scan greater than or equal
	 *
	 * @snippet ex_all.c Backward scan less than
	 *
	 * @param cursor the cursor handle
	 * @param exactp the status of the search: 0 if an exact match is
	 * found, < 0 if a smaller key is returned, > 0 if a larger key is
	 * returned
	 * @errors
	 */
	int __F(search_near)(WT_CURSOR *cursor, int *exactp);
	/*! @} */

	/*!
	 * @name Data modification
	 * @{
	 */
	/*!
	 * Insert a record, and optionally overwrite an existing record.
	 * If the cursor was not configured with "append" or "overwrite", both
	 * the key and value must be set and the record must not already exist;
	 * the record will be inserted.
	 *
	 * If the cursor was configured with "overwrite", both the key and value
	 * must be set; if the record already exists, the key's value will be
	 * updated, otherwise, the record will be inserted.
	 *
	 * If a cursor with record number keys was configured with "append",
	 * the value must be set; a new record will be appended and the record
	 * number set as the cursor key value.
	 *
	 * Inserting a new record after the current maximum record in a
	 * fixed-length bit field column-store (that is, a store with an
	 * 'r' type key and 't' type value) implicitly creates the missing
	 * records as records with a value of 0.
	 *
	 * @snippet ex_all.c Insert a new record
	 *
	 * @snippet ex_all.c Insert a new record or overwrite an existing record
	 *
	 * @snippet ex_all.c Insert a new record and assign a record number
	 *
	 * @param cursor the cursor handle
	 * @errors
	 */
	int __F(insert)(WT_CURSOR *cursor);

	/*!
	 * Update a record.  Both key and value must be set, the key must
	 * exist, and the value of the key's record will be updated.
	 *
	 * @snippet ex_all.c Update an existing record
	 *
	 * @param cursor the cursor handle
	 * @errors
	 * In particular, if no record with the specified key exists,
	 * ::WT_NOTFOUND is returned.
	 */
	int __F(update)(WT_CURSOR *cursor);

	/*!
	 * Remove a record.  The key must be set, and the key's record will be
	 * removed.
	 *
	 * Removing a record in a fixed-length bit field column-store
	 * (that is, a store with an 'r' type key and 't' type value) is
	 * identical to setting the record's value to 0.
	 *
	 * @snippet ex_all.c Remove a record
	 *
	 * @param cursor the cursor handle
	 * @errors
	 * In particular, if no record with the specified key exists,
	 * ::WT_NOTFOUND is returned.
	 */
	int __F(remove)(WT_CURSOR *cursor);
	/*! @} */

	/*!
	 * Close the cursor.
	 *
	 * This releases the resources associated with the cursor handle.
	 * Cursors are closed implicitly by ending the enclosing connection or
	 * closing the session in which they were opened.
	 *
	 * @snippet ex_all.c Close the cursor
	 *
	 * @param cursor the cursor handle
	 * @errors
	 */
	int __F(close)(WT_CURSOR *cursor);

	/*
	 * Protected fields, only to be used by cursor implementations.
	 */
#if !defined(SWIG) && !defined(DOXYGEN)
	/*
	 * !!!
	 * Explicit representations of structures from queue.h.
	 * TAILQ_ENTRY(wt_cursor) q;
	 */
	struct {
		WT_CURSOR *tqe_next;
		WT_CURSOR **tqe_prev;
	} q;				/* Linked list of WT_CURSORs. */

	uint64_t recno;
	uint8_t raw_recno_buf[WT_INTPACK64_MAXSIZE];
					/* Holds a recno in raw mode. */
	WT_ITEM key, value;
	int saved_err;			/* Saved error in set_{key,value}. */

	/* Data source cursors have underlying application-owned cursors. */
	WT_CURSOR *data_source;

#define	WT_CURSTD_APPEND	0x0001
#define	WT_CURSTD_DUMP_HEX	0x0002
#define	WT_CURSTD_DUMP_PRINT	0x0004
#define	WT_CURSTD_KEY_APP	0x0008
#define	WT_CURSTD_KEY_RET	0x0010
#define	WT_CURSTD_KEY_SET	(WT_CURSTD_KEY_APP | WT_CURSTD_KEY_RET)
#define	WT_CURSTD_OPEN		0x0020
#define	WT_CURSTD_OVERWRITE	0x0040
#define	WT_CURSTD_RAW		0x0080
#define	WT_CURSTD_VALUE_APP	0x0100
#define	WT_CURSTD_VALUE_RET	0x0200
#define	WT_CURSTD_VALUE_SET	(WT_CURSTD_VALUE_APP | WT_CURSTD_VALUE_RET)
	uint32_t flags;
#endif
};

/*!
 * All data operations are performed in the context of a WT_SESSION.  This
 * encapsulates the thread and transactional context of the operation.
 *
 * <b>Thread safety:</b> A WT_SESSION handle is not usually shared between
 * threads, see @ref threads for more information.
 */
struct __wt_session {
	/*! The connection for this session. */
	WT_CONNECTION *connection;

	/*!
	 * Close the session handle.
	 *
	 * This will release the resources associated with the session handle,
	 * including rolling back any active transactions and closing any
	 * cursors that remain open in the session.
	 *
	 * @snippet ex_all.c Close a session
	 *
	 * @param session the session handle
	 * @configempty{session.close, see dist/api_data.py}
	 * @errors
	 */
	int __F(close)(WT_SESSION *session, const char *config);

	/*!
	 * Reconfigure a session handle.
	 *
	 * @snippet ex_all.c Reconfigure a session
	 *
	 * WT_SESSION::reconfigure will fail if a transaction is in progress
	 * in the session.
	 * All open cursors are reset.
	 *
	 * @param session the session handle
	 * @configstart{session.reconfigure, see dist/api_data.py}
	 * @config{isolation, the default isolation level for operations in this
	 * session., a string\, chosen from the following options: \c
	 * "read-uncommitted"\, \c "read-committed"\, \c "snapshot"; default \c
	 * read-committed.}
	 * @configend
	 * @errors
	 */
	int __F(reconfigure)(WT_SESSION *session, const char *config);

	/*!
	 * @name Cursor handles
	 * @{
	 */

	/*!
	 * Open a new cursor on a data source or duplicate an existing cursor.
	 *
	 * @snippet ex_all.c Open a cursor
	 *
	 * An existing cursor can be duplicated by passing it as the \c to_dup
	 * parameter and setting the \c uri parameter to \c NULL:
	 *
	 * @snippet ex_all.c Duplicate a cursor
	 *
	 * Cursors being duplicated must have a key set, and successfully
	 * duplicated cursors are positioned at the same place in the data
	 * source as the original.
	 *
	 * To reconfigure a cursor, duplicate it with a new configuration value:
	 *
	 * @snippet ex_all.c Reconfigure a cursor
	 *
	 * Cursor handles should be discarded by calling WT_CURSOR::close.
	 *
	 * Cursors capable of supporting transactional operations operate in the
	 * context of the current transaction, if any.  Ending a transaction
	 * implicitly resets all open cursors.
	 *
	 * Cursors are relatively light-weight objects but may hold references
	 * to heavier-weight objects; applications should re-use cursors when
	 * possible, but instantiating new cursors is not so expensive that
	 * applications need to cache cursors at all cost.
	 *
	 * @param session the session handle
	 * @param uri the data source on which the cursor operates; cursors
	 *  are usually opened on tables, however, cursors can be opened on
	 *  any data source, regardless of whether it is ultimately stored
	 *  in a table.  Some cursor types may have limited functionality
	 *  (for example, they may be read-only or not support transactional
	 *  updates).  See @ref data_sources for more information.
	 *  <br>
	 *  The following are the builtin cursor types:
	 *  <table>
	 *  @hrow{URI, Type, Key/Value types}
	 *  @row{<tt>backup:</tt>,
	 *	hot backup cursor,
	 *	key=<code>string</code>\, see @ref hot_backup for details}
	 *  @row{<tt>colgroup:\<table name\>:\<column group name\></tt>,
	 *	column group cursor,
	 *	table key\, column group value(s)}
	 *  @row{<tt>config:[\<uri\>]</tt>,
	 *	object configuration cursor, (key=config string\,
	 *	value=config value)}
	 *  @row{<tt>file:\<file name\></tt>,
	 *	file cursor,
	 *	file key\, file value(s)}
	 *  @row{<tt>index:\<table name\>:\<index name\></tt>,
	 *	index cursor,
	 *	key=index key\, value=table value(s)}
	 *  @row{<tt>lsm:\<name\></tt>,
	 *	LSM cursor (key=LSM key\, value=LSM value), See also: @ref lsm}
	 *  @row{<tt>statistics:[\<data source URI\>]</tt>,
	 *	database or data source statistics cursor,
	 *	key=<code>int id</code>\, value=(<code>string description\,
	 *	string value\, uint64_t value</code>)\,
	 *	see @ref data_statistics for details}
	 *  @row{<tt>table:\<table name\></tt>,
	 *	table cursor,
	 *	table key\, table value(s)}
	 *  </table>
	 * @param to_dup a cursor to duplicate
	 * @configstart{session.open_cursor, see dist/api_data.py}
	 * @config{append, append the value as a new record\, creating a new
	 * record number key; valid only for cursors with record number keys., a
	 * boolean flag; default \c false.}
	 * @config{bulk, configure the cursor for bulk-loading\, a fast\,
	 * initial load path (see @ref bulk_load for more information).
	 * Bulk-load may only be used for newly created objects and cursors
	 * configured for bulk-load only support the WT_CURSOR::insert and
	 * WT_CURSOR::close methods.  When bulk-loading row-store objects\, keys
	 * must be loaded in sorted order.  The value is usually a true/false
	 * flag; when bulk-loading fixed-length column store objects\, the
	 * special value \c bitmap allows chunks of a memory resident bitmap to
	 * be loaded directly into a file by passing a \c WT_ITEM to
	 * WT_CURSOR::set_value where the \c size field indicates the number of
	 * records in the bitmap (as specified by the object's \c value_format
	 * configuration). Bulk-loaded bitmap values must end on a byte boundary
	 * relative to the bit count (except for the last set of values
	 * loaded)., a string; default \c false.}
	 * @config{checkpoint, the name of a checkpoint to open (the reserved
	 * name "WiredTigerCheckpoint" opens the most recent internal checkpoint
	 * taken for the object). The cursor does not support data
	 * modification., a string; default empty.}
	 * @config{dump, configure the cursor for dump format inputs and
	 * outputs: "hex" selects a simple hexadecimal format\, "print" selects
	 * a format where only non-printing characters are hexadecimal encoded.
	 * The cursor dump format is compatible with the @ref util_dump and @ref
	 * util_load commands., a string\, chosen from the following options: \c
	 * "hex"\, \c "print"; default empty.}
	 * @config{next_random, configure the cursor to return a pseudo-random
	 * record from the object; valid only for row-store cursors.  Cursors
	 * configured with next_random only support the WT_CURSOR::next and
	 * WT_CURSOR::close methods.  See @ref cursor_random for details., a
	 * boolean flag; default \c false.}
	 * @config{overwrite, change the behavior of the cursor's insert method
	 * to overwrite previously existing values., a boolean flag; default \c
	 * false.}
	 * @config{raw, ignore the encodings for the key and value\, manage data
	 * as if the formats were \c "u". See @ref cursor_raw for details., a
	 * boolean flag; default \c false.}
	 * @config{statistics_clear, reset statistics counters when the cursor
	 * is closed; valid only for statistics cursors., a boolean flag;
	 * default \c false.}
	 * @config{statistics_fast, only gather statistics that don't require
	 * traversing the tree; valid only for statistics cursors., a boolean
	 * flag; default \c false.}
	 * @config{target, if non-empty\, backup the list of objects; valid only
	 * for a backup data source., a list of strings; default empty.}
	 * @configend
	 * @param[out] cursorp a pointer to the newly opened cursor
	 * @errors
	 */
	int __F(open_cursor)(WT_SESSION *session,
	    const char *uri, WT_CURSOR *to_dup,
	    const char *config, WT_CURSOR **cursorp);
	/*! @} */

	/*!
	 * @name Table operations
	 * @{
	 */
	/*!
	 * Create a table, column group, index or file.
	 *
	 * @snippet ex_all.c Create a table
	 *
	 * @param session the session handle
	 * @param name the URI of the object to create, such as
	 * \c "table:stock". For a description of URI formats
	 * see @ref data_sources.
	 * @configstart{session.create, see dist/api_data.py}
	 * @config{allocation_size, the file unit allocation size\, in bytes\,
	 * must a power-of-two; smaller values decrease the file space required
	 * by overflow items\, and the default value of 512B is a good choice
	 * absent requirements from the operating system or storage device., an
	 * integer between 512B and 128MB; default \c 512B.}
	 * @config{block_compressor, configure a compressor for file blocks.
	 * Permitted values are empty (off) or \c "bzip2"\, \c "snappy" or
	 * custom compression engine \c "name" created with
	 * WT_CONNECTION::add_compressor.  See @ref compression for more
	 * information., a string; default empty.}
	 * @config{cache_resident, do not ever evict the object's pages; see
	 * @ref tuning_cache_resident for more information., a boolean flag;
	 * default \c false.}
	 * @config{checksum, configure file block checksums; permitted values
	 * are <code>on</code> (checksum all file blocks)\, <code>off</code>
	 * (checksum no file blocks) and <code>uncompresssed</code> (checksum
	 * only file blocks which are not compressed for some reason). The \c
	 * uncompressed value is for applications which can reasonably rely on
	 * decompression to fail if a block has been corrupted., a string\,
	 * chosen from the following options: \c "on"\, \c "off"\, \c
	 * "uncompressed"; default \c on.}
	 * @config{colgroups, comma-separated list of names of column groups.
	 * Each column group is stored separately\, keyed by the primary key of
	 * the table.  If no column groups are specified\, all columns are
	 * stored together in a single file.  All value columns in the table
	 * must appear in at least one column group.  Each column group must be
	 * created with a separate call to WT_SESSION::create., a list of
	 * strings; default empty.}
	 * @config{collator, configure custom collation for keys.  Value must be
	 * a collator name created with WT_CONNECTION::add_collator., a string;
	 * default empty.}
	 * @config{columns, list of the column names.  Comma-separated list of
	 * the form <code>(column[\,...])</code>. For tables\, the number of
	 * entries must match the total number of values in \c key_format and \c
	 * value_format.  For colgroups and indices\, all column names must
	 * appear in the list of columns for the table., a list of strings;
	 * default empty.}
	 * @config{dictionary, the maximum number of unique values remembered in
	 * the Btree row-store leaf page value dictionary; see @ref
	 * file_formats_compression for more information., an integer greater
	 * than or equal to 0; default \c 0.}
	 * @config{exclusive, fail if the object exists.  When false (the
	 * default)\, if the object exists\, check that its settings match the
	 * specified configuration., a boolean flag; default \c false.}
	 * @config{format, the file format., a string\, chosen from the
	 * following options: \c "btree"; default \c btree.}
	 * @config{huffman_key, configure Huffman encoding for keys.  Permitted
	 * values are empty (off)\, \c "english"\, \c "utf8<file>" or \c
	 * "utf16<file>". See @ref huffman for more information., a string;
	 * default empty.}
	 * @config{huffman_value, configure Huffman encoding for values.
	 * Permitted values are empty (off)\, \c "english"\, \c "utf8<file>" or
	 * \c "utf16<file>". See @ref huffman for more information., a string;
	 * default empty.}
	 * @config{internal_item_max, the largest key stored within an internal
	 * node\, in bytes.  If non-zero\, any key larger than the specified
	 * size will be stored as an overflow item (which may require additional
	 * I/O to access). If zero\, a default size is chosen that permits at
	 * least 8 keys per internal page., an integer greater than or equal to
	 * 0; default \c 0.}
	 * @config{internal_key_truncate, configure internal key truncation\,
	 * discarding unnecessary trailing bytes on internal keys (ignored for
	 * custom collators)., a boolean flag; default \c true.}
	 * @config{internal_page_max, the maximum page size for internal nodes\,
	 * in bytes; the size must be a multiple of the allocation size and is
	 * significant for applications wanting to avoid excessive L2 cache
	 * misses while searching the tree.  The page maximum is the bytes of
	 * uncompressed data\, that is\, the limit is applied before any block
	 * compression is done., an integer between 512B and 512MB; default \c
	 * 2KB.}
	 * @config{key_format, the format of the data packed into key items.
	 * See @ref schema_format_types for details.  By default\, the
	 * key_format is \c 'u' and applications use WT_ITEM structures to
	 * manipulate raw byte arrays.  By default\, records are stored in
	 * row-store files: keys of type \c 'r' are record numbers and records
	 * referenced by record number are stored in column-store files., a
	 * format string; default \c u.}
	 * @config{key_gap, the maximum gap between instantiated keys in a Btree
	 * leaf page\, constraining the number of keys processed to instantiate
	 * a random Btree leaf page key., an integer greater than or equal to 0;
	 * default \c 10.}
	 * @config{leaf_item_max, the largest key or value stored within a leaf
	 * node\, in bytes.  If non-zero\, any key or value larger than the
	 * specified size will be stored as an overflow item (which may require
	 * additional I/O to access). If zero\, a default size is chosen that
	 * permits at least 4 key and value pairs per leaf page., an integer
	 * greater than or equal to 0; default \c 0.}
	 * @config{leaf_page_max, the maximum page size for leaf nodes\, in
	 * bytes; the size must be a multiple of the allocation size\, and is
	 * significant for applications wanting to maximize sequential data
	 * transfer from a storage device.  The page maximum is the bytes of
	 * uncompressed data\, that is\, the limit is applied before any block
	 * compression is done., an integer between 512B and 512MB; default \c
	 * 1MB.}
	 * @config{lsm_auto_throttle, Throttle inserts into LSM trees if
	 * flushing to disk isn't keeping up., a boolean flag; default \c true.}
	 * @config{lsm_bloom, create bloom filters on LSM tree chunks as they
	 * are merged., a boolean flag; default \c true.}
	 * @config{lsm_bloom_bit_count, the number of bits used per item for LSM
	 * bloom filters., an integer between 2 and 1000; default \c 8.}
	 * @config{lsm_bloom_config, config string used when creating Bloom
	 * filter files\, passed to WT_SESSION::create., a string; default
	 * empty.}
	 * @config{lsm_bloom_hash_count, the number of hash values per item used
	 * for LSM bloom filters., an integer between 2 and 100; default \c 4.}
	 * @config{lsm_bloom_newest, create a bloom filter on an LSM tree chunk
	 * before it's first merge.  Only supported if bloom filters are
	 * enabled., a boolean flag; default \c false.}
	 * @config{lsm_bloom_oldest, create a bloom filter on the oldest LSM
	 * tree chunk.  Only supported if bloom filters are enabled., a boolean
	 * flag; default \c false.}
	 * @config{lsm_chunk_size, the maximum size of the in-memory chunk of an
	 * LSM tree., an integer between 512K and 500MB; default \c 2MB.}
	 * @config{lsm_merge_max, the maximum number of chunks to include in a
	 * merge operation., an integer between 2 and 100; default \c 15.}
	 * @config{lsm_merge_threads, the number of thread to perform merge
	 * operations., an integer between 1 and 10; default \c 1.}
	 * @config{memory_page_max, the maximum size a page can grow to in
	 * memory before being reconciled to disk.  The specified size will be
	 * adjusted to a lower bound of <code>50 * leaf_page_max</code>. This
	 * limit is soft - it is possible for pages to be temporarily larger
	 * than this value., an integer between 512B and 10TB; default \c 5MB.}
	 * @config{os_cache_dirty_max, maximum dirty system buffer cache usage\,
	 * in bytes.  If non-zero\, schedule writes for dirty blocks belonging
	 * to this object in the system buffer cache after that many bytes from
	 * this object are written into the buffer cache., an integer greater
	 * than or equal to 0; default \c 0.}
	 * @config{os_cache_max, maximum system buffer cache usage\, in bytes.
	 * If non-zero\, evict object blocks from the system buffer cache after
	 * that many bytes from this object are read or written into the buffer
	 * cache., an integer greater than or equal to 0; default \c 0.}
	 * @config{prefix_compression, configure row-store format key prefix
	 * compression., a boolean flag; default \c true.}
	 * @config{source, set a custom data source URI for a column group\,
	 * index or simple table.  By default\, the data source URI is derived
	 * from the \c type and the column group or index name.  Applications
	 * can create tables from existing data sources by supplying a \c source
	 * configuration., a string; default empty.}
	 * @config{split_pct, the Btree page split size as a percentage of the
	 * maximum Btree page size\, that is\, when a Btree page is split\, it
	 * will be split into smaller pages\, where each page is the specified
	 * percentage of the maximum Btree page size., an integer between 25 and
	 * 100; default \c 75.}
	 * @config{type, set the type of data source used to store a column
	 * group\, index or simple table.  By default\, a \c "file:" URI is
	 * derived from the object name.  The \c type configuration can be used
	 * to switch to a different storage format\, such as LSM. Ignored if an
	 * explicit URI is supplied with a \c source configuration., a string\,
	 * chosen from the following options: \c "file"\, \c "lsm"; default \c
	 * file.}
	 * @config{value_format, the format of the data packed into value items.
	 * See @ref schema_format_types for details.  By default\, the
	 * value_format is \c 'u' and applications use a WT_ITEM structure to
	 * manipulate raw byte arrays.  Value items of type 't' are bitfields\,
	 * and when configured with record number type keys\, will be stored
	 * using a fixed-length store., a format string; default \c u.}
	 * @configend
	 * @errors
	 */
	int __F(create)(WT_SESSION *session,
	    const char *name, const char *config);

	/*!
	 * Compact an object.
	 *
	 * @snippet ex_all.c Compact a table
	 *
	 * @param session the session handle
	 * @param name the URI of the object to drop, such as \c "table:stock"
	 * @configstart{session.compact, see dist/api_data.py}
	 * @config{trigger, Compaction will not be attempted unless the
	 * specified percentage of the underlying objects is expected to be
	 * recovered by compaction., an integer between 10 and 50; default \c
	 * 30.}
	 * @configend
	 * @errors
	 */
	int __F(compact)(WT_SESSION *session,
	    const char *name, const char *config);

	/*!
	 * Drop (delete) an object.
	 *
	 * @snippet ex_all.c Drop a table
	 *
	 * @param session the session handle
	 * @param name the URI of the object to drop, such as \c "table:stock"
	 * @configstart{session.drop, see dist/api_data.py}
	 * @config{force, return success if the object does not exist., a
	 * boolean flag; default \c false.}
	 * @config{remove_files, should the underlying files be removed?., a
	 * boolean flag; default \c true.}
	 * @configend
	 * @errors
	 */
	int __F(drop)(WT_SESSION *session,
	    const char *name, const char *config);

	/*!
	 * Rename an object.
	 *
	 * @snippet ex_all.c Rename a table
	 *
	 * @param session the session handle
	 * @param uri the current URI of the object, such as \c "table:old"
	 * @param newuri the new URI of the object, such as \c "table:new"
	 * @configempty{session.rename, see dist/api_data.py}
	 * @errors
	 */
	int __F(rename)(WT_SESSION *session,
	    const char *uri, const char *newuri, const char *config);

	/*!
	 * Salvage a file or table
	 *
	 * Salvage rebuilds the file, or files of which a table is comprised,
	 * discarding any corrupted file blocks.
	 *
	 * Previously deleted records may re-appear, and inserted records may
	 * disappear, when salvage is done, so salvage should not be run
	 * unless it is known to be necessary.  Normally, salvage should be
	 * called after a file or table has been corrupted, as reported by the
	 * WT_SESSION::verify method.
	 *
	 * Files are rebuilt in place, the salvage method overwrites the
	 * existing files.
	 *
	 * @snippet ex_all.c Salvage a table
	 *
	 * @param session the session handle
	 * @param name the URI of the file or table to salvage
	 * @configstart{session.salvage, see dist/api_data.py}
	 * @config{force, force salvage even of files that do not appear to be
	 * WiredTiger files., a boolean flag; default \c false.}
	 * @configend
	 * @errors
	 */
	int __F(salvage)(WT_SESSION *session,
	    const char *name, const char *config);

	/*!
	 * Truncate a file, table or cursor range.
	 *
	 * Truncate a file or table.
	 * @snippet ex_all.c Truncate a table
	 *
	 * Truncate a cursor range.  When truncating based on a cursor position,
	 * it is not required the cursor reference a record in the object, only
	 * that the key be set.  This allows applications to discard portions of
	 * the object name space without knowing exactly what records the object
	 * contains.
	 * @snippet ex_all.c Truncate a range
	 *
	 * @param session the session handle
	 * @param name the URI of the file or table to truncate
	 * @param start optional cursor marking the first record discarded;
	 * if <code>NULL</code>, the truncate starts from the beginning of
	 * the object
	 * @param stop optional cursor marking the last record discarded;
	 * if <code>NULL</code>, the truncate continues to the end of the
	 * object
	 * @configempty{session.truncate, see dist/api_data.py}
	 * @errors
	 */
	int __F(truncate)(WT_SESSION *session,
	    const char *name,
	    WT_CURSOR *start, WT_CURSOR *stop, const char *config);

	/*!
	 * Upgrade a file or table.
	 *
	 * Upgrade upgrades a file or table, if upgrade is required.
	 *
	 * @snippet ex_all.c Upgrade a table
	 *
	 * @param session the session handle
	 * @param name the URI of the file or table to upgrade
	 * @configempty{session.upgrade, see dist/api_data.py}
	 * @errors
	 */
	int __F(upgrade)(WT_SESSION *session,
	    const char *name, const char *config);

	/*!
	 * Verify a file or table.
	 *
	 * Verify reports if a file, or the files of which a table is
	 * comprised, have been corrupted.  The WT_SESSION::salvage method
	 * can be used to repair a corrupted file,
	 *
	 * @snippet ex_all.c Verify a table
	 *
	 * @param session the session handle
	 * @param name the URI of the file or table to verify
	 * @configstart{session.verify, see dist/api_data.py}
	 * @config{dump_address, Display addresses and page types as pages are
	 * verified\, using the application's message handler\, intended for
	 * debugging., a boolean flag; default \c false.}
	 * @config{dump_blocks, Display the contents of on-disk blocks as they
	 * are verified\, using the application's message handler\, intended for
	 * debugging., a boolean flag; default \c false.}
	 * @config{dump_pages, Display the contents of in-memory pages as they
	 * are verified\, using the application's message handler\, intended for
	 * debugging., a boolean flag; default \c false.}
	 * @configend
	 * @errors
	 */
	int __F(verify)(WT_SESSION *session,
	    const char *name, const char *config);
	/*! @} */

	/*!
	 * @name Transactions
	 * @{
	 */
	/*!
	 * Start a transaction in this session.
	 *
	 * The transaction remains active until ended by
	 * WT_SESSION::commit_transaction or WT_SESSION::rollback_transaction.
	 * Operations performed on cursors capable of supporting transactional
	 * operations that are already open in this session, or which are opened
	 * before the transaction ends, will operate in the context of the
	 * transaction.
	 *
	 * All open cursors are reset.
	 *
	 * WT_SESSION::begin_transaction will fail if a transaction is already
	 * in progress in the session.
	 *
	 * @snippet ex_all.c transaction commit/rollback
	 *
	 * @param session the session handle
	 * @configstart{session.begin_transaction, see dist/api_data.py}
	 * @config{isolation, the isolation level for this transaction; defaults
	 * to the session's isolation level., a string\, chosen from the
	 * following options: \c "read-uncommitted"\, \c "read-committed"\, \c
	 * "snapshot"; default empty.}
	 * @config{name, name of the transaction for tracing and debugging., a
	 * string; default empty.}
	 * @config{priority, priority of the transaction for resolving
	 * conflicts.  Transactions with higher values are less likely to
	 * abort., an integer between -100 and 100; default \c 0.}
	 * @config{sync, how to sync log records when the transaction commits.,
	 * a string\, chosen from the following options: \c "full"\, \c
	 * "flush"\, \c "write"\, \c "none"; default \c full.}
	 * @configend
	 * @errors
	 */
	int __F(begin_transaction)(WT_SESSION *session, const char *config);

	/*!
	 * Commit the current transaction.
	 *
	 * A transaction must be in progress when this method is called.
	 *
	 * All open cursors are reset.
	 *
	 * If WT_SESSION::commit_transaction returns an error, the transaction
	 * was rolled-back, not committed.
	 *
	 * @snippet ex_all.c transaction commit/rollback
	 *
	 * @param session the session handle
	 * @configempty{session.commit_transaction, see dist/api_data.py}
	 * @errors
	 */
	int __F(commit_transaction)(WT_SESSION *session, const char *config);

	/*!
	 * Roll back the current transaction.
	 *
	 * A transaction must be in progress when this method is called.
	 *
	 * All open cursors are reset.
	 *
	 * @snippet ex_all.c transaction commit/rollback
	 *
	 * @param session the session handle
	 * @configempty{session.rollback_transaction, see dist/api_data.py}
	 * @errors
	 */
	int __F(rollback_transaction)(WT_SESSION *session, const char *config);

	/*!
	 * Write a transactionally consistent snapshot of a database or set of
	 * objects.  The checkpoint includes all transactions committed before
	 * the checkpoint starts.  Additionally, checkpoints may optionally be
	 * discarded.
	 *
	 * @snippet ex_all.c Checkpoint examples
	 *
	 * @param session the session handle
	 * @configstart{session.checkpoint, see dist/api_data.py}
	 * @config{drop, specify a list of checkpoints to drop.  The list may
	 * additionally contain one of the following keys: \c "from=all" to drop
	 * all checkpoints\, \c "from=<checkpoint>" to drop all checkpoints
	 * after and including the named checkpoint\, or \c "to=<checkpoint>" to
	 * drop all checkpoints before and including the named checkpoint.
	 * Checkpoints cannot be dropped while a hot backup is in progress or if
	 * open in a cursor., a list of strings; default empty.}
	 * @config{force, checkpoints may be skipped if the underlying object
	 * has not been modified\, this option forces the checkpoint., a boolean
	 * flag; default \c false.}
	 * @config{name, if non-empty\, specify a name for the checkpoint., a
	 * string; default empty.}
	 * @config{target, if non-empty\, checkpoint the list of objects., a
	 * list of strings; default empty.}
	 * @configend
	 * @errors
	 */
	int __F(checkpoint)(WT_SESSION *session, const char *config);

	/*! @} */
};

/*!
 * A connection to a WiredTiger database.  The connection may be opened within
 * the same address space as the caller or accessed over a socket connection.
 *
 * Most applications will open a single connection to a database for each
 * process.  The first process to open a connection to a database will access
 * the database in its own address space.  Subsequent connections (if allowed)
 * will communicate with the first process over a socket connection to perform
 * their operations.
 *
 * <b>Thread safety:</b> A WT_CONNECTION handle may be shared between threads,
 * see @ref threads for more information.
 */
struct __wt_connection {
	/*!
	 * Close a connection.
	 *
	 * Any open sessions will be closed.
	 *
	 * @snippet ex_all.c Close a connection
	 *
	 * @param connection the connection handle
	 * @configempty{connection.close, see dist/api_data.py}
	 * @errors
	 */
	int __F(close)(WT_CONNECTION *connection, const char *config);

	/*!
	 * Reconfigure a connection handle.
	 *
	 * @snippet ex_all.c Reconfigure a connection
	 *
	 * @param connection the connection handle
	 * @configstart{connection.reconfigure, see dist/api_data.py}
	 * @config{cache_size, maximum heap memory to allocate for the cache.  A
	 * database should configure either a cache_size or a shared_cache not
	 * both., an integer between 1MB and 10TB; default \c 100MB.}
	 * @config{error_prefix, prefix string for error messages., a string;
	 * default empty.}
	 * @config{eviction_dirty_target, continue evicting until the cache has
	 * less dirty pages than this (as a percentage). Dirty pages will only
	 * be evicted if the cache is full enough to trigger eviction., an
	 * integer between 10 and 99; default \c 80.}
	 * @config{eviction_target, continue evicting until the cache becomes
	 * less full than this (as a percentage). Must be less than \c
	 * eviction_trigger., an integer between 10 and 99; default \c 80.}
	 * @config{eviction_trigger, trigger eviction when the cache becomes
	 * this full (as a percentage)., an integer between 10 and 99; default
	 * \c 95.}
	 * @config{shared_cache = (, shared cache configuration options.  A
	 * database should configure either a cache_size or a shared_cache not
	 * both., a set of related configuration options defined below.}
	 * @config{&nbsp;&nbsp;&nbsp;&nbsp;chunk, the granularity that a shared
	 * cache is redistributed., an integer between 1MB and 10TB; default \c
	 * 10MB.}
	 * @config{&nbsp;&nbsp;&nbsp;&nbsp;reserve, amount of cache this
	 * database is guaranteed to have available from the shared cache.  This
	 * setting is per database.  Defaults to the chunk size., an integer;
	 * default \c 0.}
	 * @config{&nbsp;&nbsp;&nbsp;&nbsp;name, name of a cache
	 * that is shared between databases., a string; default \c pool.}
	 * @config{&nbsp;&nbsp;&nbsp;&nbsp;size, maximum memory to allocate for
	 * the shared cache.  Setting this will update the value if one is
	 * already set., an integer between 1MB and 10TB; default \c 500MB.}
	 * @config{ ),,}
	 * @config{statistics, Maintain database statistics that may impact
	 * performance., a boolean flag; default \c false.}
	 * @config{verbose, enable messages for various events.  Options are
	 * given as a list\, such as
	 * <code>"verbose=[evictserver\,read]"</code>., a list\, with values
	 * chosen from the following options: \c "block"\, \c "shared_cache"\,
	 * \c "ckpt"\, \c "evict"\, \c "evictserver"\, \c "fileops"\, \c
	 * "hazard"\, \c "lsm"\, \c "mutex"\, \c "read"\, \c "readserver"\, \c
	 * "reconcile"\, \c "salvage"\, \c "verify"\, \c "write"; default
	 * empty.}
	 * @configend
	 * @errors
	 */
	int __F(reconfigure)(WT_CONNECTION *connection, const char *config);

	/*!
	 * The home directory of the connection.
	 *
	 * @snippet ex_all.c Get the database home directory
	 *
	 * @param connection the connection handle
	 * @returns a pointer to a string naming the home directory
	 */
	const char *__F(get_home)(WT_CONNECTION *connection);

	/*!
	 * Add configuration options for a method.  See
	 * @ref custom_ds_config_add for more information.
	 *
	 * @snippet ex_all.c Configure method configuration
	 *
	 * @param connection the connection handle
	 * @param method the name of the method
	 * @param uri the object type or NULL for all object types
	 * @param config the additional configuration's name and default value
	 * @param type the additional configuration's type (must be one of
	 * \c "boolean"\, \c "int", \c "list" or \c "string")
	 * @param check the additional configuration check string, or NULL if
	 * none
	 * @errors
	 */
	int __F(configure_method)(WT_CONNECTION *connection,
	    const char *method, const char *uri,
	    const char *config, const char *type, const char *check);

	/*!
	 * Return if opening this handle created the database.
	 *
	 * @snippet ex_all.c Check if the database is newly created
	 *
	 * @param connection the connection handle
	 * @returns false (zero) if the connection existed before the call to
	 * ::wiredtiger_open, true (non-zero) if it was created by opening this
	 * handle.
	 */
	int __F(is_new)(WT_CONNECTION *connection);

	/*!
	 * @name Session handles
	 * @{
	 */
	/*!
	 * Open a session.
	 *
	 * @snippet ex_all.c Open a session
	 *
	 * @param connection the connection handle
	 * @param errhandler An error handler.  If <code>NULL</code>, the
	 * connection's error handler is used
	 * @configstart{connection.open_session, see dist/api_data.py}
	 * @config{isolation, the default isolation level for operations in this
	 * session., a string\, chosen from the following options: \c
	 * "read-uncommitted"\, \c "read-committed"\, \c "snapshot"; default \c
	 * read-committed.}
	 * @configend
	 * @param[out] sessionp the new session handle
	 * @errors
	 */
	int __F(open_session)(WT_CONNECTION *connection,
	    WT_EVENT_HANDLER *errhandler, const char *config,
	    WT_SESSION **sessionp);
	/*! @} */

	/*!
	 * @name Extensions
	 * @{
	 */
	/*!
	 * Load an extension.
	 *
	 * @snippet ex_all.c Load an extension
	 *
	 * @param connection the connection handle
	 * @param path the filename of the extension module
	 * @configstart{connection.load_extension, see dist/api_data.py}
	 * @config{entry, the entry point of the extension\, called to
	 * initialize the extension when it is loaded.  The signature of the
	 * function must match ::wiredtiger_extension_init., a string; default
	 * \c wiredtiger_extension_init.}
	 * @config{prefix, a prefix for all names registered by this extension
	 * (e.g.\, to make namespaces distinct or during upgrades., a string;
	 * default empty.}
	 * @config{terminate, a optional function in the extension that is
	 * called before the extension is unloaded during WT_CONNECTION::close.
	 * The signature of the function must match
	 * ::wiredtiger_extension_terminate., a string; default \c
	 * wiredtiger_extension_terminate.}
	 * @configend
	 * @errors
	 */
	int __F(load_extension)(WT_CONNECTION *connection,
	    const char *path, const char *config);

	/*!
	 * Add a custom data source.  See @ref custom_data_sources for more
	 * information.
	 *
	 * The application must first implement the WT_DATA_SOURCE interface
	 * and then register the implementation with WiredTiger:
	 *
	 * @snippet ex_data_source.c WT_DATA_SOURCE register
	 *
	 * @param connection the connection handle
	 * @param prefix the URI prefix for this data source, e.g., "file:"
	 * @param data_source the application-supplied implementation of
	 *	WT_DATA_SOURCE to manage this data source.
	 * @configempty{connection.add_data_source, see dist/api_data.py}
	 * @errors
	 */
	int __F(add_data_source)(WT_CONNECTION *connection, const char *prefix,
	    WT_DATA_SOURCE *data_source, const char *config);

	/*!
	 * Add a custom collation function.
	 *
	 * The application must first implement the WT_COLLATOR interface and
	 * then register the implementation with WiredTiger:
	 *
	 * @snippet ex_all.c WT_COLLATOR register
	 *
	 * @param connection the connection handle
	 * @param name the name of the collation to be used in calls to
	 * 	WT_SESSION::create
	 * @param collator the application-supplied collation handler
	 * @configempty{connection.add_collator, see dist/api_data.py}
	 * @errors
	 */
	int __F(add_collator)(WT_CONNECTION *connection,
	    const char *name, WT_COLLATOR *collator, const char *config);

	/*!
	 * Add a compression function.
	 *
	 * The application must first implement the WT_COMPRESSOR interface
	 * and then register the implementation with WiredTiger:
	 *
	 * @snippet ex_all.c WT_COMPRESSOR register
	 *
	 * @param connection the connection handle
	 * @param name the name of the compression function to be used in calls
	 *	to WT_SESSION::create
	 * @param compressor the application-supplied compression handler
	 * @configempty{connection.add_compressor, see dist/api_data.py}
	 * @errors
	 */
	int __F(add_compressor)(WT_CONNECTION *connection,
	    const char *name, WT_COMPRESSOR *compressor, const char *config);

	/*!
	 * Add a custom extractor for index keys or column groups.
	 * @notyet{custom extractors}
	 *
	 * The application must first implement the WT_EXTRACTOR interface and
	 * then register the implementation with WiredTiger:
	 *
	 * @snippet ex_all.c WT_EXTRACTOR register
	 *
	 * @param connection the connection handle
	 * @param name the name of the extractor to be used in calls to
	 * 	WT_SESSION::create
	 * @param extractor the application-supplied extractor
	 * @configempty{connection.add_extractor, see dist/api_data.py}
	 * @errors
	 */
	int __F(add_extractor)(WT_CONNECTION *connection, const char *name,
	    WT_EXTRACTOR *extractor, const char *config);

	/*!
	 * Return a reference to the WiredTiger extension functions.
	 *
	 * @snippet ex_data_source.c WT_EXTENSION_API declaration
	 *
	 * @param wt_conn the WT_CONNECTION handle
	 * @returns a reference to a WT_EXTENSION_API structure.
	 */
	WT_EXTENSION_API *__F(get_extension_api)(WT_CONNECTION *wt_conn);
	/*! @} */
};

/*!
 * Open a connection to a database.
 *
 * @snippet ex_all.c Open a connection
 *
 * @param home The path to the database home directory.  See @ref home
 * for more information.
 * @param errhandler An error handler.  If <code>NULL</code>, a builtin error
 * handler is installed that writes error messages to stderr
 * @configstart{wiredtiger_open, see dist/api_data.py}
 * @config{buffer_alignment, in-memory alignment (in bytes) for buffers used for
 * I/O. The default value of -1 indicates that a platform-specific alignment
 * value should be used (512 bytes on Linux systems\, zero elsewhere)., an
 * integer between -1 and 1MB; default \c -1.}
 * @config{cache_size, maximum heap memory to allocate for the cache.  A
 * database should configure either a cache_size or a shared_cache not both., an
 * integer between 1MB and 10TB; default \c 100MB.}
 * @config{checkpoint = (, periodically checkpoint the database., a set of
 * related configuration options defined below.}
 * @config{&nbsp;&nbsp;&nbsp;&nbsp;name, the checkpoint name., a string; default
 * \c "WiredTigerCheckpoint".}
 * @config{&nbsp;&nbsp;&nbsp;&nbsp;wait, seconds to
 * wait between each checkpoint; setting this value configures periodic
 * checkpoints., an integer between 1 and 100000; default \c 0.}
 * @config{ ),,}
 * @config{create, create the database if it does not exist., a boolean flag;
 * default \c false.}
 * @config{direct_io, Use \c O_DIRECT to access files.  Options are given as a
 * list\, such as <code>"direct_io=[data]"</code>., a list\, with values chosen
 * from the following options: \c "data"\, \c "log"; default empty.}
 * @config{error_prefix, prefix string for error messages., a string; default
 * empty.}
 * @config{eviction_dirty_target, continue evicting until the cache has less
 * dirty pages than this (as a percentage). Dirty pages will only be evicted if
 * the cache is full enough to trigger eviction., an integer between 10 and 99;
 * default \c 80.}
 * @config{eviction_target, continue evicting until the cache becomes less full
 * than this (as a percentage). Must be less than \c eviction_trigger., an
 * integer between 10 and 99; default \c 80.}
 * @config{eviction_trigger, trigger eviction when the cache becomes this full
 * (as a percentage)., an integer between 10 and 99; default \c 95.}
 * @config{extensions, list of shared library extensions to load (using dlopen).
 * Optional values are passed as the \c config parameter to
 * WT_CONNECTION::load_extension.  Complex paths may require quoting\, for
 * example\, <code>extensions=("/path/ext.so"="entry=my_entry")</code>., a list
 * of strings; default empty.}
 * @config{hazard_max, maximum number of simultaneous hazard pointers per
 * session handle., an integer greater than or equal to 15; default \c 1000.}
 * @config{logging, enable logging., a boolean flag; default \c false.}
 * @config{lsm_merge, merge LSM chunks where possible., a boolean flag; default
 * \c true.}
 * @config{mmap, Use memory mapping to access files when possible., a boolean
 * flag; default \c true.}
 * @config{multiprocess, permit sharing between processes (will automatically
 * start an RPC server for primary processes and use RPC for secondary
 * processes). <b>Not yet supported in WiredTiger</b>., a boolean flag; default
 * \c false.}
 * @config{session_max, maximum expected number of sessions (including server
 * threads)., an integer greater than or equal to 1; default \c 50.}
 * @config{shared_cache = (, shared cache configuration options.  A database
 * should configure either a cache_size or a shared_cache not both., a set of
 * related configuration options defined below.}
 * @config{&nbsp;&nbsp;&nbsp;&nbsp;chunk, the granularity that a shared cache is
 * redistributed., an integer between 1MB and 10TB; default \c 10MB.}
 * @config{&nbsp;&nbsp;&nbsp;&nbsp;reserve, amount of cache this database is
 * guaranteed to have available from the shared cache.  This setting is per
 * database.  Defaults to the chunk size., an integer; default \c 0.}
 * @config{&nbsp;&nbsp;&nbsp;&nbsp;name, name of a cache that is shared between
 * databases., a string; default \c pool.}
 * @config{&nbsp;&nbsp;&nbsp;&nbsp;size,
 * maximum memory to allocate for the shared cache.  Setting this will update
 * the value if one is already set., an integer between 1MB and 10TB; default \c
 * 500MB.}
 * @config{ ),,}
 * @config{statistics, Maintain database statistics that may impact
 * performance., a boolean flag; default \c false.}
 * @config{statistics_log = (, log database connection statistics into a file
 * when the \c statistics configuration value is set to true.  See @ref
 * statistics_log for more information., a set of related configuration options
 * defined below.}
 * @config{&nbsp;&nbsp;&nbsp;&nbsp;clear, reset statistics
 * counters after each set of log records are written., a boolean flag; default
 * \c true.}
 * @config{&nbsp;&nbsp;&nbsp;&nbsp;path, the pathname to a file into
 * which the log records are written\, may contain strftime conversion
 * specifications.  If the value is not an absolute path name\, the file is
 * created relative to the database home., a string; default \c
 * "WiredTigerStat.%H".}
 * @config{&nbsp;&nbsp;&nbsp;&nbsp;sources, if non-empty\,
 * include statistics for the list of data source URIs\, if they are open at the
 * time of the statistics logging.  The list may include URIs matching a single
 * data source ("table:mytable")\, or a URI matching all data sources of a
 * particular type ("table:"). No statistics that require the traversal of a
 * tree are reported\, as if the \c statistics_fast configuration string were
 * set., a list of strings; default empty.}
 * @config{&nbsp;&nbsp;&nbsp;&nbsp;timestamp, a timestamp prepended to each log
 * record\, may contain strftime conversion specifications., a string; default
 * \c "%b %d %H:%M:%S".}
 * @config{&nbsp;&nbsp;&nbsp;&nbsp;wait, seconds to wait
 * between each write of the log records; setting this value configures \c
 * statistics and statistics logging., an integer between 1 and 100000; default
 * \c 0.}
 * @config{ ),,}
 * @config{sync, flush files to stable storage when closing or writing
 * checkpoints., a boolean flag; default \c true.}
 * @config{transactional, support transactional semantics., a boolean flag;
 * default \c true.}
 * @config{use_environment_priv, use the \c WIREDTIGER_CONFIG and \c
 * WIREDTIGER_HOME environment variables regardless of whether or not the
 * process is running with special privileges.  See @ref home for more
 * information., a boolean flag; default \c false.}
 * @config{verbose, enable messages for various events.  Options are given as a
 * list\, such as <code>"verbose=[evictserver\,read]"</code>., a list\, with
 * values chosen from the following options: \c "block"\, \c "shared_cache"\, \c
 * "ckpt"\, \c "evict"\, \c "evictserver"\, \c "fileops"\, \c "hazard"\, \c
 * "lsm"\, \c "mutex"\, \c "read"\, \c "readserver"\, \c "reconcile"\, \c
 * "salvage"\, \c "verify"\, \c "write"; default empty.}
 * @configend
 * Additionally, if a file named \c WiredTiger.config appears in the WiredTiger
 * home directory, it is read for configuration values (see @ref config_file
 * for details).  Configuration values specified in the \c config argument to
 * the ::wiredtiger_open function override configuration values specified in
 * the \c WiredTiger.config file.
 * @param[out] connectionp A pointer to the newly opened connection handle
 * @errors
 */
int wiredtiger_open(const char *home,
    WT_EVENT_HANDLER *errhandler, const char *config,
    WT_CONNECTION **connectionp);

/*!
 * Return information about an error as a string; wiredtiger_strerror is a
 * superset of the ISO C99/POSIX 1003.1-2001 function strerror.
 *
 * @snippet ex_all.c Display an error
 *
 * @param err a return value from a WiredTiger, C library or POSIX function
 * @returns a string representation of the error
 */
const char *wiredtiger_strerror(int err);

/*!
 * The interface implemented by applications to handle error, informational and
 * progress messages.  Entries set to NULL are ignored and the default handlers
 * will continue to be used.
 */
struct __wt_event_handler {
	/*!
	 * Callback to handle error messages; by default, error messages are
	 * written to the stderr stream.
	 *
	 * Error handler returns are not ignored: if the handler returns
	 * non-zero, the error may cause the WiredTiger function posting the
	 * event to fail, and may even cause operation or library failure.
	 *
	 * @param error a WiredTiger, C99 or POSIX error code, which can
	 * be converted to a string using ::wiredtiger_strerror
	 * @param message an error string
	 */
	int (*handle_error)(WT_EVENT_HANDLER *handler,
	    int error, const char *message);

	/*!
	 * Callback to handle informational messages; by default, informational
	 * messages are written to the stdout stream.
	 *
	 * Message handler returns are not ignored: if the handler returns
	 * non-zero, the error may cause the WiredTiger function posting the
	 * event to fail, and may even cause operation or library failure.
	 *
	 * @param message an informational string
	 */
	int (*handle_message)(WT_EVENT_HANDLER *handler, const char *message);

	/*!
	 * Callback to handle progress messages; by default, no progress
	 * messages are written.
	 *
	 * Progress handler returns are not ignored: if the handler returns
	 * non-zero, the error may cause the WiredTiger function posting the
	 * event to fail, and may even cause operation or library failure.
	 *
	 * @param operation a string representation of the operation
	 * @param progress a counter
	 */
	int (*handle_progress)(WT_EVENT_HANDLER *handler,
	    const char *operation, uint64_t progress);
};

/*!
 * @name Data packing and unpacking
 * @{
 */

/*!
 * Pack a structure into a buffer.
 *
 * See @ref packing for a description of the permitted format strings.
 *
 * @section pack_examples Packing Examples
 *
 * For example, the string <code>"iSh"</code> will pack a 32-bit integer
 * followed by a NUL-terminated string, followed by a 16-bit integer.  The
 * default, big-endian encoding will be used, with no alignment.  This could be
 * used in C as follows:
 *
 * @snippet ex_all.c Pack fields into a buffer
 *
 * Then later, the values can be unpacked as follows:
 *
 * @snippet ex_all.c Unpack fields from a buffer
 *
 * @param session the session handle
 * @param buffer a pointer to a packed byte array
 * @param size the number of valid bytes in the buffer
 * @param format the data format, see @ref packing
 * @errors
 */
int wiredtiger_struct_pack(WT_SESSION *session,
    void *buffer, size_t size, const char *format, ...);

/*!
 * Calculate the size required to pack a structure.
 *
 * Note that for variable-sized fields including variable-sized strings and
 * integers, the calculated sized merely reflects the expected sizes specified
 * in the format string itself.
 *
 * @snippet ex_all.c Get the packed size
 *
 * @param session the session handle
 * @param sizep a location where the number of bytes needed for the
 * matching call to ::wiredtiger_struct_pack is returned
 * @param format the data format, see @ref packing
 * @errors
 */
int wiredtiger_struct_size(WT_SESSION *session,
    size_t *sizep, const char *format, ...);

/*!
 * Unpack a structure from a buffer.
 *
 * Reverse of ::wiredtiger_struct_pack: gets values out of a
 * packed byte string.
 *
 * @snippet ex_all.c Unpack fields from a buffer
 *
 * @param session the session handle
 * @param buffer a pointer to a packed byte array
 * @param size the number of valid bytes in the buffer
 * @param format the data format, see @ref packing
 * @errors
 */
int wiredtiger_struct_unpack(WT_SESSION *session,
    const void *buffer, size_t size, const char *format, ...);

#if !defined(SWIG)

/*!
 * Streaming interface to packing.
 *
 * This allows applications to pack or unpack records one field at a time.
 * This is an opaque handle returned by ::wiredtiger_pack_start or
 * ::wiredtiger_unpack_start.  It must be closed with ::wiredtiger_pack_close.
 */
typedef struct __wt_pack_stream WT_PACK_STREAM;

/*!
 * Start a packing operation into a buffer with the given format string.  This
 * should be followed by a series of calls to ::wiredtiger_pack_item,
 * ::wiredtiger_pack_int, ::wiredtiger_pack_str or ::wiredtiger_pack_uint
 * to fill in the values.
 *
 * @param session the session handle
 * @param format the data format, see @ref packing
 * @param buffer a pointer to memory to hold the packed data
 * @param size the size of the buffer
 * @param[out] psp the new packing stream handle
 * @errors
 */
int wiredtiger_pack_start(WT_SESSION *session,
    const char *format, void *buffer, size_t size, WT_PACK_STREAM **psp);

/*!
 * Start an unpacking operation from a buffer with the given format string.
 * This should be followed by a series of calls to ::wiredtiger_unpack_item,
 * ::wiredtiger_unpack_int, ::wiredtiger_unpack_str or ::wiredtiger_unpack_uint
 * to retrieve the packed values.
 *
 * @param session the session handle
 * @param format the data format, see @ref packing
 * @param buffer a pointer to memory holding the packed data
 * @param size the size of the buffer
 * @param[out] psp the new packing stream handle
 * @errors
 */
int wiredtiger_unpack_start(WT_SESSION *session,
    const char *format, const void *buffer, size_t size, WT_PACK_STREAM **psp);

/*!
 * Close a packing stream.
 *
 * @param ps the packing stream handle
 * @param[out] usedp the number of bytes in the buffer used by the stream
 * @errors
 */
int wiredtiger_pack_close(WT_PACK_STREAM *ps, size_t *usedp);

/*!
 * Pack an item into a packing stream.
 *
 * @param ps the packing stream handle
 * @param item an item to pack
 * @errors
 */
int wiredtiger_pack_item(WT_PACK_STREAM *ps, WT_ITEM *item);

/*!
 * Pack a signed integer into a packing stream.
 *
 * @param ps the packing stream handle
 * @param i a signed integer to pack
 * @errors
 */
int wiredtiger_pack_int(WT_PACK_STREAM *ps, int64_t i);

/*!
 * Pack a string into a packing stream.
 *
 * @param ps the packing stream handle
 * @param s a string to pack
 * @errors
 */
int wiredtiger_pack_str(WT_PACK_STREAM *ps, const char *s);

/*!
 * Pack an unsigned integer into a packing stream.
 *
 * @param ps the packing stream handle
 * @param u an unsigned integer to pack
 * @errors
 */
int wiredtiger_pack_uint(WT_PACK_STREAM *ps, uint64_t u);

/*!
 * Unpack an item from a packing stream.
 *
 * @param ps the packing stream handle
 * @param item an item to unpack
 * @errors
 */
int wiredtiger_unpack_item(WT_PACK_STREAM *ps, WT_ITEM *item);

/*!
 * Unpack a signed integer from a packing stream.
 *
 * @param ps the packing stream handle
 * @param[out] ip the unpacked signed integer
 * @errors
 */
int wiredtiger_unpack_int(WT_PACK_STREAM *ps, int64_t *ip);

/*!
 * Unpack a string from a packing stream.
 *
 * @param ps the packing stream handle
 * @param[out] sp the unpacked string
 * @errors
 */
int wiredtiger_unpack_str(WT_PACK_STREAM *ps, const char **sp);

/*!
 * Unpack an unsigned integer from a packing stream.
 *
 * @param ps the packing stream handle
 * @param[out] up the unpacked unsigned integer
 * @errors
 */
int wiredtiger_unpack_uint(WT_PACK_STREAM *ps, uint64_t *up);

#endif /* !defined(SWIG) */
/*!
 * @}
 */

/*!
 * Get version information.
 *
 * @snippet ex_all.c Get the WiredTiger library version #1
 * @snippet ex_all.c Get the WiredTiger library version #2
 *
 * @param majorp a location where the major version number is returned
 * @param minorp a location where the minor version number is returned
 * @param patchp a location where the patch version number is returned
 * @returns a string representation of the version
 */
const char *wiredtiger_version(int *majorp, int *minorp, int *patchp);

/*******************************************
 * Error returns
 *******************************************/
/*!
 * @anchor error_returns
 * @name Error returns
 * Most functions and methods in WiredTiger return an integer code indicating
 * whether the operation succeeded or failed.  A return of zero indicates
 * success, all non-zero return values indicate some kind of failure.
 *
 * WiredTiger reserves all values from -31,800 to -31,999 as possible error
 * return values.  WiredTiger may also return C99/POSIX error codes such as
 * \c ENOMEM, \c EINVAL and \c ENOTSUP, with the usual meanings.
 *
 * The following are all of the WiredTiger-specific error returns:
 * @{
 */
/*
 * DO NOT EDIT: automatically built by dist/api_err.py.
 * Error return section: BEGIN
 */
/*!
 * Conflict between concurrent operations.
 * This error is generated when an operation cannot be completed due to a
 * conflict with concurrent operations.  The operation may be retried; if a
 * transaction is in progress, it should be rolled back and the operation
 * retried in a new transaction.
 */
#define	WT_DEADLOCK	-31800
/*!
 * Attempt to insert an existing key.
 * This error is generated when the application attempts to insert a record with
 * the same key as an existing record without the 'overwrite' configuration to
 * WT_SESSION::open_cursor.
 */
#define	WT_DUPLICATE_KEY	-31801
/*!
 * Non-specific WiredTiger error.
 * This error is returned when an error is not covered by a specific error
 * return.
 */
#define	WT_ERROR	-31802
/*!
 * Item not found.
 * This error indicates an operation did not find a value to return.  This
 * includes cursor search and other operations where no record matched the
 * cursor's search key such as WT_CURSOR::update or WT_CURSOR::remove.
 */
#define	WT_NOTFOUND	-31803
/*!
 * WiredTiger library panic.
 * This error indicates an underlying problem that requires the application exit
 * and restart.
 */
#define	WT_PANIC	-31804
/*! @cond internal */
/*! Restart the operation (internal). */
#define	WT_RESTART	-31805
/*! @endcond */
/*
 * Error return section: END
 * DO NOT EDIT: automatically built by dist/api_err.py.
 */
/*! @} */

/*! @} */

/*!
 * @defgroup wt_ext WiredTiger Extension API
 * The functions and interfaces applications use to customize and extend the
 * behavior of WiredTiger.
 * @{
 */

/*******************************************
 * Forward structure declarations for the extension API
 *******************************************/
struct __wt_config_arg;	    typedef struct __wt_config_arg WT_CONFIG_ARG;
struct __wt_config_item;    typedef struct __wt_config_item WT_CONFIG_ITEM;
struct __wt_config_scan;    typedef struct __wt_config_scan WT_CONFIG_SCAN;

/*!
 * The interface implemented by applications to provide custom ordering of
 * records.
 *
 * Applications register their implementation with WiredTiger by calling
 * WT_CONNECTION::add_collator.
 *
 * @snippet ex_extending.c add collator nocase
 *
 * @snippet ex_extending.c add collator prefix10
 */
struct __wt_collator {
	/*!
	 * Callback to compare keys.
	 *
	 * @param[out] cmp set to -1 if <code>key1 < key2</code>,
	 * 	0 if <code>key1 == key2</code>,
	 * 	1 if <code>key1 > key2</code>.
	 * @returns zero for success, non-zero to indicate an error.
	 *
	 * @snippet ex_all.c Implement WT_COLLATOR
	 *
	 * @snippet ex_extending.c case insensitive comparator
	 *
	 * @snippet ex_extending.c n character comparator
	 */
	int (*compare)(WT_COLLATOR *collator, WT_SESSION *session,
	    const WT_ITEM *key1, const WT_ITEM *key2, int *cmp);
};

/*!
 * The interface implemented by applications to provide custom compression.
 *
 * Compressors must implement the WT_COMPRESSOR interface: the
 * WT_COMPRESSOR::compress and WT_COMPRESSOR::decompress callbacks must be
 * specified, and WT_COMPRESSOR::pre_size is optional.  To build your own
 * compressor, use one of the compressors in \c ext/compressors as a template:
 * \c ext/nop_compress is a simple compressor that passes through data
 * unchanged, and is a reasonable starting point.
 *
 * Applications register their implementation with WiredTiger by calling
 * WT_CONNECTION::add_compressor.
 *
 * @snippet ex_all.c WT_COMPRESSOR register
 */
struct __wt_compressor {
	/*!
	 * Callback to compress a chunk of data.
	 *
	 * WT_COMPRESSOR::compress takes a source buffer and a destination
	 * buffer, by default of the same size.  If the callback can compress
	 * the buffer to a smaller size in the destination, it does so, sets
	 * the \c compression_failed return to 0 and returns 0.  If compression
	 * does not produce a smaller result, the callback sets the
	 * \c compression_failed return to 1 and returns 0. If another
	 * error occurs, it returns an errno or WiredTiger error code.
	 *
	 * On entry, \c src will point to memory, with the length of the memory
	 * in \c src_len.  After successful completion, the callback should
	 * return \c 0 and set \c result_lenp to the number of bytes required
	 * for the compressed representation.
	 *
	 * If compression would not shrink the data or the \c dst buffer is not
	 * large enough to hold the compressed data, the callback should set
	 * \c compression_failed to a non-zero value and return 0.
	 *
	 * @param[in] src the data to compress
	 * @param[in] src_len the length of the data to compress
	 * @param[in] dst the destination buffer
	 * @param[in] dst_len the length of the destination buffer
	 * @param[out] result_lenp the length of the compressed data
	 * @param[out] compression_failed non-zero if compression did not
	 * decrease the length of the data (compression may not have completed)
	 * @returns zero for success, non-zero to indicate an error.
	 *
	 * @snippet ex_all.c WT_COMPRESSOR compress
	 */
	int (*compress)(WT_COMPRESSOR *compressor, WT_SESSION *session,
	    uint8_t *src, size_t src_len,
	    uint8_t *dst, size_t dst_len,
	    size_t *result_lenp, int *compression_failed);

	/*!
	 * Callback to compress a list of byte strings.
	 *
	 * WT_COMPRESSOR::compress_raw gives applications fine-grained control
	 * over disk block size when writing row-store or variable-length
	 * column-store pages.  Where this level of control is not required by
	 * the underlying storage device, set the WT_COMPRESSOR::compress_raw
	 * callback to \c NULL and WiredTiger will internally split each page
	 * into blocks, each block then compressed by WT_COMPRESSOR::compress.
	 *
	 * WT_COMPRESSOR::compress_raw takes a source buffer and an array of
	 * 0-based offsets of byte strings in that buffer.  The callback then
	 * encodes none, some or all of the byte strings and copies the encoded
	 * representation into a destination buffer.  The callback returns the
	 * number of byte strings encoded and the bytes needed for the encoded
	 * representation.   The encoded representation has header information
	 * prepended and is written as a block to the underlying file object.
	 *
	 * On entry, \c page_max is the configured maximum size for objects of
	 * this type.  (This value is provided for convenience, and will be
	 * either the \c internal_page_max or \c leaf_page_max value specified
	 * to WT_SESSION::create when the object was created.)
	 *
	 * On entry, \c split_pct is the configured Btree page split size for
	 * this object.  (This value is provided for convenience, and will be
	 * the \c split_pct value specified to WT_SESSION::create when the
	 * object was created.)
	 *
	 * On entry, \c extra is a count of additional bytes that will be added
	 * to the encoded representation before it is written.  In other words,
	 * if the target write size is 8KB, the returned encoded representation
	 * should be less than or equal to (8KB - \c extra).  The method does
	 * not need to skip bytes in the destination buffer based on \c extra,
	 * the method should only use \c extra to decide how many bytes to store
	 * into the destination buffer for its ideal block size.
	 *
	 * On entry, \c src points to the source buffer; \c offsets is an array
	 * of \c slots 0-based offsets into \c src, where each offset is the
	 * start of a byte string, except for the last offset, which is the
	 * offset of the first byte past the end of the last byte string.  (In
	 * other words, <code>offsets[0]</code> will be 0, the offset of the
	 * first byte of the first byte string in \c src, and
	 * <code>offsets[slots]</code> is the total length of all of the byte
	 * strings in the \c src buffer.)
	 *
	 * On entry, \c dst points to the destination buffer with a length
	 * of \c dst_len.  If the WT_COMPRESSOR::pre_size method is specified,
	 * the destination buffer will be at least the size returned by that
	 * method; otherwise, the destination buffer will be at least the
	 * maximum size for the page being written (that is, when writing a
	 * row-store leaf page, the destination buffer will be at least as
	 * large as the \c leaf_page_max configuration value).
	 *
	 * After successful completion, the callback should return \c 0, and
	 * set \c result_slotsp to the number of byte strings encoded and
	 * \c result_lenp to the bytes needed for the encoded representation.
	 *
	 * WiredTiger repeatedly calls the callback function until all rows on
	 * the page have been encoded.  There is no requirement the callback
	 * encode any or all of the byte strings passed by WiredTiger.  If the
	 * callback does not encode any of the byte strings, the callback must
	 * set \c result_slotsp to 0.  In this case, WiredTiger will accumulate
	 * more rows and repeat the call; if there are no more rows to
	 * accumulate, WiredTiger writes the remaining rows without further
	 * calls to the callback.
	 *
	 * On entry, \c final is zero if there are more rows to be written as
	 * part of this page (if there will be additional data provided to the
	 * callback), and non-zero if there are no more rows to be written as
	 * part of this page.  If \c final is set and the callback fails to
	 * encode any rows, WiredTiger writes the remaining rows without further
	 * calls to the callback.  If \c final is set and the callback encodes
	 * any number of rows, WiredTiger continues to call the callback until
	 * all of the rows are encoded or the callback fails to encode any rows.
	 *
	 * The WT_COMPRESSOR::compress_raw callback is intended for applications
	 * wanting to create disk blocks in specific sizes.
	 * WT_COMPRESSOR::compress_raw is not a replacement for
	 * WT_COMPRESSOR::compress: objects which WT_COMPRESSOR::compress_raw
	 * cannot handle (for example, overflow key or value items), or which
	 * WT_COMPRESSOR::compress_raw chooses not to compress for any reason
	 * (for example, if WT_COMPRESSOR::compress_raw callback chooses not to
	 * compress a small number of rows, but the page being written has no
	 * more rows to accumulate), will be passed to WT_COMPRESSOR::compress.
	 *
	 * The WT_COMPRESSOR::compress_raw callback is only called for objects
	 * where it is applicable, that is, for row-store and variable-length
	 * column-store objects, where both row-store key prefix compression
	 * and row-store and variable-length column-store dictionary compression
	 * are \b not configured.  When WT_COMPRESSOR::compress_raw is not
	 * applicable, the WT_COMPRESSOR::compress callback is used instead.
	 *
	 * @param[in] page_max the configured maximum page size for this object
	 * @param[in] split_pct the configured page split size for this object
	 * @param[in] extra the count of the additional bytes
	 * @param[in] src the data to compress
	 * @param[in] offsets the byte offsets of the byte strings in src
	 * @param[in] slots the number of entries in offsets
	 * @param[in] dst the destination buffer
	 * @param[in] dst_len the length of the destination buffer
	 * @param[in] final non-zero if there are no more rows to accumulate
	 * @param[out] result_lenp the length of the compressed data
	 * @param[out] result_slotsp the number of byte offsets taken
	 * @returns zero for success, non-zero to indicate an error.
	 */
	int (*compress_raw)(WT_COMPRESSOR *compressor, WT_SESSION *session,
	    size_t page_max, u_int split_pct, size_t extra,
	    uint8_t *src, uint32_t *offsets, uint32_t slots,
	    uint8_t *dst, size_t dst_len,
	    int final,
	    size_t *result_lenp, uint32_t *result_slotsp);

	/*!
	 * Callback to decompress a chunk of data.
	 *
	 * WT_COMPRESSOR::decompress takes a source buffer and a destination
	 * buffer.  The contents are switched from \c compress: the
	 * source buffer is the compressed value, and the destination buffer is
	 * sized to be the original size.  If the callback successfully
	 * decompresses the source buffer to the destination buffer, it returns
	 * 0.  If an error occurs, it returns an errno or WiredTiger error code.
	 * The source buffer that WT_COMPRESSOR::decompress takes may have a
	 * size that is rounded up from the size originally produced by
	 * WT_COMPRESSOR::compress, with the remainder of the buffer set to
	 * zeroes. Most compressors do not care about this difference if the
	 * size to be decompressed can be implicitly discovered from the
	 * compressed data.  If your compressor cares, you may need to allocate
	 * space for, and store, the actual size in the compressed buffer.  See
	 * the source code for the included snappy compressor for an example.
	 *
	 * On entry, \c src will point to memory, with the length of the memory
	 * in \c src_len.  After successful completion, the callback should
	 * return \c 0 and set \c result_lenp to the number of bytes required
	 * for the decompressed representation.
	 *
	 * If the \c dst buffer is not big enough to hold the decompressed
	 * data, the callback should return an error.
	 *
	 * @param[in] src the data to decompress
	 * @param[in] src_len the length of the data to decompress
	 * @param[in] dst the destination buffer
	 * @param[in] dst_len the length of the destination buffer
	 * @param[out] result_lenp the length of the decompressed data
	 * @returns zero for success, non-zero to indicate an error.
	 *
	 * @snippet ex_all.c WT_COMPRESSOR decompress
	 */
	int (*decompress)(WT_COMPRESSOR *compressor, WT_SESSION *session,
	    uint8_t *src, size_t src_len,
	    uint8_t *dst, size_t dst_len,
	    size_t *result_lenp);

	/*!
	 * Callback to size a destination buffer for compression
	 *
	 * WT_COMPRESSOR::pre_size is an optional callback that, given the
	 * source buffer and size, produces the size of the destination buffer
	 * to be given to WT_COMPRESSOR::compress.  This is useful for
	 * compressors that assume that the output buffer is sized for the
	 * worst case and thus no overrun checks are made.  If your compressor
	 * works like this, WT_COMPRESSOR::pre_size will need to be defined.
	 * See the source code for the snappy compressor for an example.
	 * However, if your compressor detects and avoids overruns against its
	 * target buffer, you will not need to define WT_COMPRESSOR::pre_size.
	 * When WT_COMPRESSOR::pre_size is set to NULL, the destination buffer
	 * is sized the same as the source buffer.  This is always sufficient,
	 * since a compression result that is larger than the source buffer is
	 * discarded by WiredTiger.
	 *
	 * If not NULL, this callback is called before each call to
	 * WT_COMPRESS::compress to determine the size of the destination
	 * buffer to provide.  If the callback is NULL, the destination
	 * buffer will be the same size as the source buffer.
	 *
	 * The callback should set \c result_lenp to a suitable buffer size
	 * for compression, typically the maximum length required by
	 * WT_COMPRESSOR::compress.
	 *
	 * This callback function is for compressors that require an output
	 * buffer larger than the source buffer (for example, that do not
	 * check for buffer overflow during compression).
	 *
	 * @param[in] src the data to compress
	 * @param[in] src_len the length of the data to compress
	 * @param[out] result_lenp the required destination buffer size
	 * @returns zero for success, non-zero to indicate an error.
	 *
	 * @snippet ex_all.c WT_COMPRESSOR presize
	 */
	int (*pre_size)(WT_COMPRESSOR *compressor, WT_SESSION *session,
	    uint8_t *src, size_t src_len, size_t *result_lenp);
};

/*!
 * Applications can extend WiredTiger by providing new implementations of the
 * WT_DATA_SOURCE class.  Each data source supports a different URI scheme for
 * data sources to WT_SESSION::create, WT_SESSION::open_cursor and related
 * methods.  See @ref custom_data_sources for more information.
 *
 * <b>Thread safety:</b> WiredTiger may invoke methods on the WT_DATA_SOURCE
 * interface from multiple threads concurrently.  It is the responsibility of
 * the implementation to protect any shared data.
 *
 * Applications register their implementation with WiredTiger by calling
 * WT_CONNECTION::add_data_source.
 *
 * @snippet ex_data_source.c WT_DATA_SOURCE register
 */
struct __wt_data_source {
	/*!
	 * Callback to create a new object.
	 *
	 * @snippet ex_data_source.c WT_DATA_SOURCE create
	 */
	int (*create)(WT_DATA_SOURCE *dsrc, WT_SESSION *session,
	    const char *uri, WT_CONFIG_ARG *config);

	/*!
	 * Callback to compact an object.
	 *
	 * @snippet ex_data_source.c WT_DATA_SOURCE compact
	 */
	int (*compact)(WT_DATA_SOURCE *dsrc, WT_SESSION *session,
	    const char *uri, WT_CONFIG_ARG *config);

	/*!
	 * Callback to drop an object.
	 *
	 * @snippet ex_data_source.c WT_DATA_SOURCE drop
	 */
	int (*drop)(WT_DATA_SOURCE *dsrc, WT_SESSION *session,
	    const char *uri, WT_CONFIG_ARG *config);

	/*!
	 * Callback to initialize a cursor.
	 *
	 * @snippet ex_data_source.c WT_DATA_SOURCE open_cursor
	 */
	int (*open_cursor)(WT_DATA_SOURCE *dsrc, WT_SESSION *session,
	    const char *uri, WT_CONFIG_ARG *config, WT_CURSOR **new_cursor);

	/*!
	 * Callback to rename an object.
	 *
	 * @snippet ex_data_source.c WT_DATA_SOURCE rename
	 */
	int (*rename)(WT_DATA_SOURCE *dsrc, WT_SESSION *session,
	    const char *uri, const char *newuri, WT_CONFIG_ARG *config);

	/*!
	 * Callback to salvage an object.
	 *
	 * @snippet ex_data_source.c WT_DATA_SOURCE salvage
	 */
	int (*salvage)(WT_DATA_SOURCE *dsrc, WT_SESSION *session,
	    const char *uri, WT_CONFIG_ARG *config);

	/*!
	 * Callback to truncate an object.
	 *
	 * @snippet ex_data_source.c WT_DATA_SOURCE truncate
	 */
	int (*truncate)(WT_DATA_SOURCE *dsrc, WT_SESSION *session,
	    const char *uri, WT_CONFIG_ARG *config);

	/*!
	 * Callback to verify an object.
	 *
	 * @snippet ex_data_source.c WT_DATA_SOURCE verify
	 */
	int (*verify)(WT_DATA_SOURCE *dsrc, WT_SESSION *session,
	    const char *uri, WT_CONFIG_ARG *config);
};

/*!
 * The interface implemented by applications to provide custom extraction of
 * index keys or column group values.
 *
 * Applications register implementations with WiredTiger by calling
 * WT_CONNECTION::add_extractor.
 *
 * @snippet ex_all.c WT_EXTRACTOR register
 */
struct __wt_extractor {
	/*!
	 * Callback to extract a value for an index or column group.
	 *
	 * @errors
	 *
	 * @snippet ex_all.c WT_EXTRACTOR
	 */
	int (*extract)(WT_EXTRACTOR *extractor, WT_SESSION *session,
	    const WT_ITEM *key, const WT_ITEM *value,
	    WT_ITEM *result);
};

/*!
 * Entry point to an extension, called when the extension is loaded.
 *
 * @param connection the connection handle
 * @param config the config information passed to WT_CONNECTION::load_extension
 * @errors
 */
extern int wiredtiger_extension_init(
    WT_CONNECTION *connection, WT_CONFIG_ARG *config);

/*!
 * Optional cleanup function for an extension, called during
 * WT_CONNECTION::close.
 *
 * @param connection the connection handle
 * @errors
 */
extern int wiredtiger_extension_terminate(WT_CONNECTION *connection);

/*! @} */

/*******************************************
 * Statistic reference.
 *******************************************/
/*!
 * @addtogroup wt
 * @{
 */
/*
 * DO NOT EDIT: automatically built by dist/api_stat.py.
 * Statistics section: BEGIN
 */

/*!
 * @name Connection statistics
 * @anchor statistics_keys
 * @anchor statistics_conn
 * Statistics are accessed through cursors with \c "statistics:" URIs.
 * Individual statistics can be queried through the cursor using the following
 * keys.  See @ref data_statistics for more information.
 * @{
 */
/*! mapped bytes read by the block manager */
#define	WT_STAT_CONN_BLOCK_BYTE_MAP_READ		0
/*! bytes read by the block manager */
#define	WT_STAT_CONN_BLOCK_BYTE_READ			1
/*! bytes written by the block manager */
#define	WT_STAT_CONN_BLOCK_BYTE_WRITE			2
/*! mapped blocks read by the block manager */
#define	WT_STAT_CONN_BLOCK_MAP_READ			3
/*! blocks read by the block manager */
#define	WT_STAT_CONN_BLOCK_READ				4
/*! blocks written by the block manager */
#define	WT_STAT_CONN_BLOCK_WRITE			5
/*! cache: tracked dirty bytes in the cache */
#define	WT_STAT_CONN_CACHE_BYTES_DIRTY			6
/*! cache: bytes currently in the cache */
#define	WT_STAT_CONN_CACHE_BYTES_INUSE			7
/*! cache: maximum bytes configured */
#define	WT_STAT_CONN_CACHE_BYTES_MAX			8
/*! cache: bytes read into cache */
#define	WT_STAT_CONN_CACHE_BYTES_READ			9
/*! cache: bytes written from cache */
#define	WT_STAT_CONN_CACHE_BYTES_WRITE			10
/*! cache: checkpoint blocked page eviction */
#define	WT_STAT_CONN_CACHE_EVICTION_CHECKPOINT		11
/*! cache: unmodified pages evicted */
#define	WT_STAT_CONN_CACHE_EVICTION_CLEAN		12
/*! cache: modified pages evicted */
#define	WT_STAT_CONN_CACHE_EVICTION_DIRTY		13
/*! cache: pages selected for eviction unable to be evicted */
#define	WT_STAT_CONN_CACHE_EVICTION_FAIL		14
/*! cache: pages queued for forced eviction */
#define	WT_STAT_CONN_CACHE_EVICTION_FORCE		15
/*! cache: hazard pointer blocked page eviction */
#define	WT_STAT_CONN_CACHE_EVICTION_HAZARD		16
/*! cache: internal pages evicted */
#define	WT_STAT_CONN_CACHE_EVICTION_INTERNAL		17
/*! cache: internal page merge operations completed */
#define	WT_STAT_CONN_CACHE_EVICTION_MERGE		18
/*! cache: internal page merge attempts that could not complete */
#define	WT_STAT_CONN_CACHE_EVICTION_MERGE_FAIL		19
/*! cache: internal levels merged */
#define	WT_STAT_CONN_CACHE_EVICTION_MERGE_LEVELS	20
/*! cache: eviction server unable to reach eviction goal */
#define	WT_STAT_CONN_CACHE_EVICTION_SLOW		21
/*! cache: pages walked for eviction */
#define	WT_STAT_CONN_CACHE_EVICTION_WALK		22
/*! cache: tracked dirty pages in the cache */
#define	WT_STAT_CONN_CACHE_PAGES_DIRTY			23
/*! cache: pages currently held in the cache */
#define	WT_STAT_CONN_CACHE_PAGES_INUSE			24
/*! cache: pages read into cache */
#define	WT_STAT_CONN_CACHE_READ				25
/*! cache: pages written from cache */
#define	WT_STAT_CONN_CACHE_WRITE			26
/*! pthread mutex condition wait calls */
#define	WT_STAT_CONN_COND_WAIT				27
/*! cursor creation */
#define	WT_STAT_CONN_CURSOR_CREATE			28
/*! Btree cursor insert calls */
#define	WT_STAT_CONN_CURSOR_INSERT			29
/*! Btree cursor next calls */
#define	WT_STAT_CONN_CURSOR_NEXT			30
/*! Btree cursor prev calls */
#define	WT_STAT_CONN_CURSOR_PREV			31
/*! Btree cursor remove calls */
#define	WT_STAT_CONN_CURSOR_REMOVE			32
/*! Btree cursor reset calls */
#define	WT_STAT_CONN_CURSOR_RESET			33
/*! Btree cursor search calls */
#define	WT_STAT_CONN_CURSOR_SEARCH			34
/*! Btree cursor search near calls */
#define	WT_STAT_CONN_CURSOR_SEARCH_NEAR			35
/*! Btree cursor update calls */
#define	WT_STAT_CONN_CURSOR_UPDATE			36
/*! files currently open */
#define	WT_STAT_CONN_FILE_OPEN				37
/*! rows merged in an LSM tree */
#define	WT_STAT_CONN_LSM_ROWS_MERGED			38
/*! total heap memory allocations */
#define	WT_STAT_CONN_MEMORY_ALLOCATION			39
/*! total heap memory frees */
#define	WT_STAT_CONN_MEMORY_FREE			40
/*! total heap memory re-allocations */
#define	WT_STAT_CONN_MEMORY_GROW			41
/*! total read I/Os */
#define	WT_STAT_CONN_READ_IO				42
/*! page reconciliation calls */
#define	WT_STAT_CONN_REC_PAGES				43
/*! page reconciliation calls for eviction */
#define	WT_STAT_CONN_REC_PAGES_EVICTION			44
/*! reconciliation failed because an update could not be included */
#define	WT_STAT_CONN_REC_SKIPPED_UPDATE			45
/*! pthread mutex shared lock read-lock calls */
#define	WT_STAT_CONN_RWLOCK_READ			46
/*! pthread mutex shared lock write-lock calls */
#define	WT_STAT_CONN_RWLOCK_WRITE			47
/*! ancient transactions */
#define	WT_STAT_CONN_TXN_ANCIENT			48
/*! transactions */
#define	WT_STAT_CONN_TXN_BEGIN				49
/*! transaction checkpoints */
#define	WT_STAT_CONN_TXN_CHECKPOINT			50
/*! transactions committed */
#define	WT_STAT_CONN_TXN_COMMIT				51
/*! transaction failures due to cache overflow */
#define	WT_STAT_CONN_TXN_FAIL_CACHE			52
/*! transactions rolled-back */
#define	WT_STAT_CONN_TXN_ROLLBACK			53
/*! total write I/Os */
#define	WT_STAT_CONN_WRITE_IO				54

/*!
 * @}
 * @name Statistics for data sources
 * @anchor statistics_dsrc
 * @{
 */
/*! blocks allocated */
#define	WT_STAT_DSRC_BLOCK_ALLOC			0
/*! block manager file allocation unit size */
#define	WT_STAT_DSRC_BLOCK_ALLOCSIZE			1
/*! checkpoint size */
#define	WT_STAT_DSRC_BLOCK_CHECKPOINT_SIZE		2
/*! block allocations requiring file extension */
#define	WT_STAT_DSRC_BLOCK_EXTENSION			3
/*! blocks freed */
#define	WT_STAT_DSRC_BLOCK_FREE				4
/*! file magic number */
#define	WT_STAT_DSRC_BLOCK_MAGIC			5
/*! file major version number */
#define	WT_STAT_DSRC_BLOCK_MAJOR			6
/*! minor version number */
#define	WT_STAT_DSRC_BLOCK_MINOR			7
/*! block manager file size in bytes */
#define	WT_STAT_DSRC_BLOCK_SIZE				8
/*! bloom filters in the LSM tree */
#define	WT_STAT_DSRC_BLOOM_COUNT			9
/*! bloom filter false positives */
#define	WT_STAT_DSRC_BLOOM_FALSE_POSITIVE		10
/*! bloom filter hits */
#define	WT_STAT_DSRC_BLOOM_HIT				11
/*! bloom filter misses */
#define	WT_STAT_DSRC_BLOOM_MISS				12
/*! bloom filter pages evicted from cache */
#define	WT_STAT_DSRC_BLOOM_PAGE_EVICT			13
/*! bloom filter pages read into cache */
#define	WT_STAT_DSRC_BLOOM_PAGE_READ			14
/*! total size of bloom filters */
#define	WT_STAT_DSRC_BLOOM_SIZE				15
/*! column-store variable-size deleted values */
#define	WT_STAT_DSRC_BTREE_COLUMN_DELETED		16
/*! column-store fixed-size leaf pages */
#define	WT_STAT_DSRC_BTREE_COLUMN_FIX			17
/*! column-store internal pages */
#define	WT_STAT_DSRC_BTREE_COLUMN_INTERNAL		18
/*! column-store variable-size leaf pages */
#define	WT_STAT_DSRC_BTREE_COLUMN_VARIABLE		19
/*! pages rewritten by compaction */
#define	WT_STAT_DSRC_BTREE_COMPACT_REWRITE		20
/*! total LSM, table or file object key/value pairs */
#define	WT_STAT_DSRC_BTREE_ENTRIES			21
/*! fixed-record size */
#define	WT_STAT_DSRC_BTREE_FIXED_LEN			22
/*! maximum tree depth */
#define	WT_STAT_DSRC_BTREE_MAXIMUM_DEPTH		23
/*! maximum internal page item size */
#define	WT_STAT_DSRC_BTREE_MAXINTLITEM			24
/*! maximum internal page size */
#define	WT_STAT_DSRC_BTREE_MAXINTLPAGE			25
/*! maximum leaf page item size */
#define	WT_STAT_DSRC_BTREE_MAXLEAFITEM			26
/*! maximum leaf page size */
#define	WT_STAT_DSRC_BTREE_MAXLEAFPAGE			27
/*! overflow pages */
#define	WT_STAT_DSRC_BTREE_OVERFLOW			28
/*! row-store internal pages */
#define	WT_STAT_DSRC_BTREE_ROW_INTERNAL			29
/*! row-store leaf pages */
#define	WT_STAT_DSRC_BTREE_ROW_LEAF			30
/*! bytes read into cache */
#define	WT_STAT_DSRC_CACHE_BYTES_READ			31
/*! bytes written from cache */
#define	WT_STAT_DSRC_CACHE_BYTES_WRITE			32
/*! cache: checkpoint blocked page eviction */
#define	WT_STAT_DSRC_CACHE_EVICTION_CHECKPOINT		33
/*! unmodified pages evicted */
#define	WT_STAT_DSRC_CACHE_EVICTION_CLEAN		34
/*! modified pages evicted */
#define	WT_STAT_DSRC_CACHE_EVICTION_DIRTY		35
/*! data source pages selected for eviction unable to be evicted */
#define	WT_STAT_DSRC_CACHE_EVICTION_FAIL		36
/*! cache: pages queued for forced eviction */
#define	WT_STAT_DSRC_CACHE_EVICTION_FORCE		37
/*! cache: hazard pointer blocked page eviction */
#define	WT_STAT_DSRC_CACHE_EVICTION_HAZARD		38
/*! internal pages evicted */
#define	WT_STAT_DSRC_CACHE_EVICTION_INTERNAL		39
/*! cache: internal page merge operations completed */
#define	WT_STAT_DSRC_CACHE_EVICTION_MERGE		40
/*! cache: internal page merge attempts that could not complete */
#define	WT_STAT_DSRC_CACHE_EVICTION_MERGE_FAIL		41
/*! cache: internal levels merged */
#define	WT_STAT_DSRC_CACHE_EVICTION_MERGE_LEVELS	42
/*! overflow values cached in memory */
#define	WT_STAT_DSRC_CACHE_OVERFLOW_VALUE		43
/*! pages read into cache */
#define	WT_STAT_DSRC_CACHE_READ				44
/*! overflow pages read into cache */
#define	WT_STAT_DSRC_CACHE_READ_OVERFLOW		45
/*! pages written from cache */
#define	WT_STAT_DSRC_CACHE_WRITE			46
/*! raw compression call failed (no additional data available) */
#define	WT_STAT_DSRC_COMPRESS_RAW_FAIL			47
/*! raw compression call failed (additional data available) */
#define	WT_STAT_DSRC_COMPRESS_RAW_FAIL_TEMPORARY	48
/*! raw compression call succeeded */
#define	WT_STAT_DSRC_COMPRESS_RAW_OK			49
/*! compressed pages read */
#define	WT_STAT_DSRC_COMPRESS_READ			50
/*! compressed pages written */
#define	WT_STAT_DSRC_COMPRESS_WRITE			51
/*! page written failed to compress */
#define	WT_STAT_DSRC_COMPRESS_WRITE_FAIL		52
/*! page written was too small to compress */
#define	WT_STAT_DSRC_COMPRESS_WRITE_TOO_SMALL		53
/*! cursor creation */
#define	WT_STAT_DSRC_CURSOR_CREATE			54
/*! cursor insert calls */
#define	WT_STAT_DSRC_CURSOR_INSERT			55
/*! bulk-loaded cursor-insert calls */
#define	WT_STAT_DSRC_CURSOR_INSERT_BULK			56
/*! cursor-insert key and value bytes inserted */
#define	WT_STAT_DSRC_CURSOR_INSERT_BYTES		57
/*! cursor next calls */
#define	WT_STAT_DSRC_CURSOR_NEXT			58
/*! cursor prev calls */
#define	WT_STAT_DSRC_CURSOR_PREV			59
/*! cursor remove calls */
#define	WT_STAT_DSRC_CURSOR_REMOVE			60
/*! cursor-remove key bytes removed */
#define	WT_STAT_DSRC_CURSOR_REMOVE_BYTES		61
/*! cursor reset calls */
#define	WT_STAT_DSRC_CURSOR_RESET			62
/*! cursor search calls */
#define	WT_STAT_DSRC_CURSOR_SEARCH			63
/*! cursor search near calls */
#define	WT_STAT_DSRC_CURSOR_SEARCH_NEAR			64
/*! cursor update calls */
#define	WT_STAT_DSRC_CURSOR_UPDATE			65
/*! cursor-update value bytes updated */
#define	WT_STAT_DSRC_CURSOR_UPDATE_BYTES		66
/*! chunks in the LSM tree */
#define	WT_STAT_DSRC_LSM_CHUNK_COUNT			67
/*! highest merge generation in the LSM tree */
#define	WT_STAT_DSRC_LSM_GENERATION_MAX			68
/*! queries that could have benefited from a Bloom filter that did not
 * exist */
#define	WT_STAT_DSRC_LSM_LOOKUP_NO_BLOOM		69
/*! reconciliation dictionary matches */
#define	WT_STAT_DSRC_REC_DICTIONARY			70
/*! reconciliation overflow keys written */
#define	WT_STAT_DSRC_REC_OVFL_KEY			71
/*! reconciliation overflow values written */
#define	WT_STAT_DSRC_REC_OVFL_VALUE			72
/*! reconciliation pages deleted */
#define	WT_STAT_DSRC_REC_PAGE_DELETE			73
/*! reconciliation pages merged */
#define	WT_STAT_DSRC_REC_PAGE_MERGE			74
/*! page reconciliation calls */
#define	WT_STAT_DSRC_REC_PAGES				75
/*! page reconciliation calls for eviction */
#define	WT_STAT_DSRC_REC_PAGES_EVICTION			76
/*! reconciliation failed because an update could not be included */
#define	WT_STAT_DSRC_REC_SKIPPED_UPDATE			77
/*! reconciliation internal pages split */
#define	WT_STAT_DSRC_REC_SPLIT_INTL			78
/*! reconciliation leaf pages split */
#define	WT_STAT_DSRC_REC_SPLIT_LEAF			79
/*! reconciliation maximum number of splits created by for a page */
#define	WT_STAT_DSRC_REC_SPLIT_MAX			80
/*! object compaction */
#define	WT_STAT_DSRC_SESSION_COMPACT			81
/*! update conflicts */
#define	WT_STAT_DSRC_TXN_UPDATE_CONFLICT		82
/*! write generation conflicts */
#define	WT_STAT_DSRC_TXN_WRITE_CONFLICT			83
/*! @} */
/*
 * Statistics section: END
 * DO NOT EDIT: automatically built by dist/api_stat.py.
 */
/*! @} */
/*! @} */

#undef __F

#if defined(__cplusplus)
}
#endif
#endif /* __WIREDTIGER_H_ */
