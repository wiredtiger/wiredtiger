/*! @arch_page arch-concurrency WiredTiger concurrency management

WiredTiger is a multi-threaded application and needs to manage concurrent access to shared memory
locations. Many mechanisms are defined in WiredTiger to safely access shared memory locations. This
page describes what those mechanisms are and the intended usage of them in the code base.

@section volatile Volatile

WiredTiger utilizes volatile for one reason, managing compiler optimization. Leveraging the
definitions from "Is Parallel Programming Hard, And, If So, What Can You Do About It?", Paul E.
McKenney, WiredTiger utilizes volatile to prevent the following type of compiler optimizations: Load
fusing, store fusing, invented loads, invented stores and code reordering. WiredTiger defines the
following macros WT_READ_ONCE and WT_WRITE_ONCE, these macros, if used correctly, prevent the
described forms of compiler optimization. Additionally some variables in WiredTiger are defined with
the volatile keyword if it is known that they will be frequently accessed in a concurrent context.

@section locking Locking

There are three types of locks in WiredTiger:
 - Condition Variables
 - Spin Locks
 - Read Write (RW) Locks
Each mechanism guarantees that once a thread relinquishes its lock and another thread obtains the
same lock, all modifications made by the first thread will be visible to the thread now holding
the lock.

There are two implementations of condition variables in WiredTiger respectively for POSIX and MSVC
under the same interface. The specific implementation is determined at compile time based on the
platform.

There are three different implementations for spin locks in WiredTiger under the same interface:
 - An implementation using GCC's builtin atomic operations.
 - An implementation using a POSIX based mutex.
 - An implementation for MSVC.
Again specific implementation is determined at compile time based on the platform and compile-time
configurations. WiredTiger has its own read-write lock implementation. It is based on atomic
operations and condition variables.

@subsection lock-usage Lock usage
A correctly used lock takes the lock for each access to the shared memory it guards. WiredTiger
sometimes deviates from this model and reads variables outside the context of the relevant lock.
Such instances are only permitted if reading inconsistent data is sufficient for the use case.

@section generations Generations

Shared object, including the page index, WT_REFs, etc. have their lifecycles managed using
the WiredTiger generations system. In general when a reader thread accesses an object, that could be
concurrently freed, it enters a "generation". After entering that generation it accesses the object.
A generation is a monotonically increasing integer which denotes times at which a given object must
exist.

Writer threads are then able to replace that object but cannot free it until the reader thread has
left or released the generation. Instead the writer thread adds the object to a "stash" and it marks
the stashed object with the generation indicating the point at which it was added to the stash. Once
all reader in the system do not have a corresponding generation which is older than or equal to the
stashed object's generation it can be freed.

@section atomics Atomics

As previously mentioned WiredTiger already expects loads and stores to specific sizes of points
to be atomic and prevent tearing. WiredTiger also relies on atomic RMW operations, these include:
- Compare and Swap
- Fetch add / sub
- Add / sub fetch

Currently WiredTiger is undergoing a transition where all shared memory variable access will be
wrapped by an atomic function, this will enable TSan to run on the code base. To facilitate this
transition the atomic load and store macros have been added to WiredTiger, these macros placate
TSan. To prevent them from introducing a performance regression they utilize relaxed consistency.

@section memory-barriers Memory Barriers

WiredTiger utilizes memory barriers in a number of places to manage CPU instruction reordering.
Specifically CPUs are allowed to reorder load and store instructions. If this occurs when two
threads are reading or writing to the same shared memory locations it can result in those threads
seeing what would otherwise be impossible values.

WiredTiger defines barriers by describing which kind of reordering they prevent, for example a
LoadLoad barrier prevents load instructions before the barrier from being reordered with load
instructions after the barrier. Using this definition we can define 4 types of reorderings,
LoadLoad, StoreStore, LoadStore and StoreLoad. To simplify the barrier semantics further
WiredTiger defines acquire and release barriers, firstly we have the WT_ACQUIRE_READ_WITH_BARRIER
macro which prevents LoadLoad and LoadStore reorderings. Next we have the
WT_RELEASE_WRITE_WITH_BARRIER macro which prevents StoreStore and LoadStore reorderings, these
barriers should be used as pairs. If one location requires an acquire barrier then there must be
another location that requires a release barrier. Two more barrier constructs are defined in
WiredTiger. WT_FULL_BARRIER which prevents all 4 kinds of described reorderings and
WT_COMPILER_BARRIER which is a basic compiler barrier preventing compiler optimization from
occurring across it, the compiler barrier does not impact CPU reordering.

Previously WiredTiger defined a WT_PUBLISH macro which prevented StoreStore reordering, this
macro has since been removed however the term publish still exists in the code base. This is
used to refer to writing a value to a shared memory location. It doesn't define any memory
ordering semantics.

@section marked-access Marked Access
Barriers are a heavy hammer for situations that only need to prevent reordering of instructions
on one side of a load or store. To reduce the amount of reorderings prevented, and to access an
ARM specific optimization WiredTiger defines two marked access macros. These are loads and stores
that prevent reordering from one direction across that load or store. Firstly there is the
WT_ACQUIRE_READ, this prevents loads and stores following the load from being reordered across
it. Then we have the WT_RELEASE_WRITE macro which prevents loads and stores prior to the store
from being reordered across it. As with the acquire and release barriers these marked access
macros should be paired together to function correctly.

*/
