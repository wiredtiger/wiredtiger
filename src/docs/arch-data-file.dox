/*! @arch_page arch-data-file Data File Format

Database Files

WiredTiger stores databases in a durable format through writing data to the 
physical disk/s. As part of this process, WiredTiger creates a number of 
files in the database directory. These include data files representing tables 
in a MongoDB database, a history store file used to track previous versions of 
the database tables, as well as other metadata files for the entire system.

Data files are denoted by the .wt suffix. The history store file 
(WiredTigerHS.wt) and the metadata file (WiredTiger.wt) are special WiredTiger
files, but have the same underlying structure as normal data files.

Format & Layout of Data Files

In memory, a database table is represented by a data structure called a B-Tree, 
which is made up of nodes that are page structures. The root and internal pages 
will only store keys, whilst leaf pages store both keys and values. When these 
pages are written onto the disk, they are written out as chunks or units of data 
called blocks. On the disk, a WiredTiger data file is just a collection of 
blocks which logically represent the B-Tree.

The layout of a .wt file consists of a file description \c WT_BLOCK_DESC which 
always occupies the first block, followed by a set of on-disk pages. 
The file description contains important metadata about the file such as the 
WiredTiger major and minor version, a magic number, and a checksum of the block 
contents. This information is used to verify that the file is a legitimate 
WiredTiger data file with a compatible WiredTiger version, and that its 
contents are not corrupted.

Format & Layout of On-Disk Pages

Pages consist of a header (\c WT_PAGE_HEADER and \c WT_BLOCK_HEADER) followed 
by a variable number of cells, which encode keys, values or addresses (see 
\c cell.h). The page header \c WT_PAGE_HEADER consists of information such 
as the column-store record number, write generation (required for ordering 
pages in time), in-memory size, cell count (the number of cells on the page), 
data length (the overflow record length), and the page type. This is 
immediately followed by the block header \c WT_BLOCK_HEADER which contains 
block-manager specific information such as flags, version and unused.

After the page header, pages with variable-length keys or values will have 
a set of cells. There are four main types of cells - keys, data, deleted 
cells, and off-page references. Cells are also usually followed by some 
additional data depending on its type. For example, values may have a time 
validity window, and off-page references may have a validity window and an 
address cookie. Ordering is important, values are all 
associated with the key that precedes them. Multiple values may be present, 
which can represent multiple versions. Extremely large values may be 
represented as a reference to another page (see overflow pages).

The exact encoding of cells is rather complex, and beyond what can be 
described here. The encoding strikes a balance between data that can be 
compacted efficiently in time and space, extensibility, and compatibility 
with previous versions.

Page Types
Different types of pages are made up of different types of cells.

(1) Internal Pages - as the B-Tree grows in size and layer/s are added, 
there will be pages between the root page and leaf page. These internal 
pages contain keys that point to other pages.
- The row-store internal page \c WT_PAGE_ROW_INT is made up of a key cell 
(\c WT_CELL_KEY or \c WT_CELL_KEY_OVFL) followed by an offpage-reference 
(\c WT_CELL_ADDR_XXX).
- The column-store internal page simply contains an off-page reference.

(2) Leaf Pages - leaf pages consist of a page header, followed by keys, 
values or addresses (these reference overflow pages).
- The row-store leaf page \c WT_PAGE_ROW_LEAF is made up of a key cell 
(\c WT_CELL_KEY or \c WT_CELL_KEY_OVFL) followed by a value 
(\c WT_CELL_VALUE/VALUE_COPY/VALUE_OVFL).
- The column-store leaf page (for variable-length data) WT_PAGE_COL_VAR 
is made up of data cells (WT_CELL_VALUE/VALUE_COPY/VALUE_OVFL) or 
deleted cells (WT_CELL_DEL)

(3) Overflow Pages - overflow pages are needed when keys/values that are 
too large must be stored separately in the file, apart from where the item 
is logically placed. Page sizes and configuration values such as 
internal_key_max, leaf_key_max and leaf_value_max are used to determine 
overflow items.

Whilst the above gives a general overview of how different page types are 
structured, it is a simplified representation. Due to the large amount of 
data being stored, WiredTiger may compress data to preserve memory and disk 
space. Keys may not be stored in their entirety when prefix compression 
is used (the identical key prefix is stored only once per page to reduce 
size).
*/
