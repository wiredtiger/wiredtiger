/*! @arch_page arch-rts Rollback to Stable (RTS)

RTS is an operation that retains only the modifications that are considered \a stable. A
modification is considered \a unstable if it has a durable timestamp greater than the stable
timestamp or its transaction id is not committed according to the recovery checkpoint snapshot.
The recovery checkpoint snapshot corresponds to the checkpoint transaction snapshot details saved at
the end of every checkpoint.

RTS works for all storage types except for LSM trees.

@section rts-overview Overview of RTS

RTS scans tables in the database to remove any unstable modifications. A table is selected by RTS if
it meets one of the following conditions:

1. It is modified.
2. It has prepared updates.
3. It has updates from transactions greater than the recovery checkpoint snapshot (this is
applicable only during the restart phase)
4. One of the checkpoint durable timestamps (start/stop) is greater than the rollback timestamp.
5. There is no durable timestamp in any checkpoint.

On the other hand, a table is skipped by RTS if it does not meet any of the previous criteria and
one of the following:

1. It is empty
2. It has timestamped updates but there is no stable timestamp set.
3. The associated files are missing.
4. The associated files are corrupted.
5. It is dedicated to @ref arch-metadata "metadata"
6. It is a logged table. RTS is not necessary for those as their updates are stable when the
transaction gets committed.

For each selected table, its pages are read into the cache. The unstable in-memory updates and the
unstable historical versions from the history store are removed. The on-disk version is replaced by
the latest stable in-memory update if any, otherwise by the latest stable version from the history
store. If there is no stable in-memory updates and no stable version in the history store, the data
store entry is completely removed. In the situation where the table has no timestamped updates, all
the historical versions related to this table are removed from the history store as they are no
longer required and the on-disk value is preserved.

Finally, RTS is triggered on startup, shutdown or when the application is initiated. It is worth
noting that it cannot run if there is any transaction activity happening in WiredTiger.

@section rts-pages Internal and leaf pages

On internal pages, RTS can roll back unstable fast truncate operations.
On leaf pages, RTS can roll back unstable updates with the following steps:

1. Checks the smallest insert lists on the page
2. Traverses through all the on-disk keys
    a. Checks the update list.
    b. Checks the insert list.
    c. Checks the on-disk version if no stable update is found in the update list.
    d. Removes any unstable update from the history store.

@section rts-abort-update How RTS aborts in-memory updates

RTS traverses through all the updates defined in the update list and aborts every update until a
stable is found. To remove any unstable update, RTS adds globally a visible tombstone to the key
update list and this key gets removed later during reconciliation.

@section rts-abort-on-disk-update How RTS aborts on-disk update

If the start time pair is not stable, RTS searches the history store to find a stable update to
replace the on-disk version. If the history store does not contain any stable update, the on-disk
key is removed. If the stop time pair exists and it is not stable, the on-disk update is restored
into the update list.

@section rts-page-skip Skipping reading unnecessary pages into memory

RTS doesn't load pages that don't have unstable updates that need to be removed. This check is done
by comparing the time aggregated values with the stable timestamp or the recovery checkpoint
snapshot during the tree walk.

*/
