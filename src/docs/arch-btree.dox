/*! @arch_page arch-btree B-Trees

Database tables are commonly represented by a B-Tree data structure, which
is made up of nodes that are page structures. The root and internal pages will
only store keys and references to other pages, while leaf pages store keys,
values and sometimes references to overflow pages. The focus here will be on
the in-memory representation of the B-Tree which is defined in \c btmem.h. The
on-disk representation and organization of pages is discussed in the
@ref arch-data-file page.

@section btree_btree_data_source B-Tree Data Source (WT_BTREE)

As discussed in the @ref arch-dhandle page, dhandles are generic containers used
to access various types of data sources. Dhandles that represent B-Trees contain a
pointer to the \c WT_BTREE. The \c WT_BTREE (defined in \c btree.h) embodies both
the on-disk and in-memory representations of the B-Tree. At a high-level, it
contains a memory cache of key value pairs, along with functions to read and write
data as needed to and from the data file. More specifically, the structure contains
a reference to its corresponding generic data handle, checkpoint information, the
specific WT_BTREE type, key and value formats, collator, key and page size
configurations, split information, a reference to the root page on disk, write
generation information, sync information, eviction information, and a set of flags.

@section btree_btree_in_memory_representation B-Tree In-Memory Representation

Inside a \c WT_BTREE, the reference to the root page is a \c WT_REF, which is a
reference to a page that may or may not be loaded from storage. Once the page
is loaded, the \c WT_REF will have a valid \c WT_PAGE pointer which represents
the in-memory page. The \c WT_REF structure also contains a reference page (for
splits), a set of either internal- or leaf-page flags, an address, and
fast-truncate information; either a \c WT_PAGE_DELETED structure if the page is not
instantiated in memory or an update list otherwise. In-memory internal pages have
an array of pointers (\c WT_PAGE_INDEX) to child structures, maintained in collated
order, and a child page of an internal page may cause a split at any time.
In-memory internal pages also store a reference to their parent reference and the
generation of the last split.

An in-memory row-store leaf page contains key/value pairs represented by the
\c WT_ROW structure. These structures are created from on-page data. Each row may
have some old values, or deleted values. Entries on leaf pages can be updated,
either modified or deleted. On a given page, a WT_UPDATE array will be allocated
with enough slots for every existing element in the page. A slot points to a
\c WT_UPDATE structure, and \c WT_UPDATE structures can be formed into a linked
list when multiple updates are done for an entry. New key/value pairs can also be
inserted into row-store leaf pages (\c WT_INSERT).

@section btree_btree_truncate B-Tree Truncate

The truncate operation allows for faster and more efficient deletion of records in
a range. In WiredTiger, there are two notions of truncation; a fast-truncate which
marks whole pages as deleted without having to first instantiate the page in memory
or inspect records individually, and a slower truncate where keys are walked and
tombstones are put onto each one individually. It is preferable to use fast-truncate
wherever possible, but there are cases where the slower-truncate must be used instead.
For example, in the case of a partial deletion of a page (at the ends of a range),
the records must be traversed individually.

In a row-store object, the truncate operation will explicitly read the first and last
pages of the truncate range, then walks the tree with a flag so the tree walk code
skips reading eligible pages within the range and instead just marks them as deleted.
In addition to the pages which require only a partial deletion, other ineligible pages
include pages already in the cache, pages with overflow items or pages with prepared
updates. These pages will have their records deleted individually.

@section btree_truncate_code_flow Truncate Code Flow

Truncate begins in the \c __session_truncate function, which makes a call to the
\c __wt_session_range_truncate function. Truncation is also possible for log files
but the focus here will be on truncation for regular files (\c file: uri). To perform
a truncate on a file, a start and stop cursor are positioned corresponding to the
desired range. The desired start and stop keys do not actually need to exist since the
cursors are positioned by doing a search-near rather than a search. Once positioned,
we enter the \c __wt_schema_range_truncate function and then the
\c __wt_btcur_range_truncate function before selecting either the \c __cursor_truncate
(for row-store and variable-length column store) or __cursor_truncate_fix (for
fixed-length column store) function (see \c bt_cursor.c).

Inside the \c __cursor_truncate function, we do a page-by-page walk on the B-Tree,
setting the \c WT_READ_TRUNCATE flag of each page to be truncated. For each of these
pages, we call the \c __wt_delete_page, which tries to delete the page without
instantiating it into memory. If no errors are encountered, we allocate and initialize
the page-deleted structure \c WT_PAGE_DELETED, and set the timestamp, transaction id
and state information associated with the truncate. Finally, the page is published as
deleted using the \c WT_REF_DELETED flag.

@section btree_truncate_interaction_with_other_operations Interaction With Other Operations

Truncation differs to other operations in the sense that it does not have the same
transactional semantics. If a range truncate is in progress and another transaction
happens to insert a key into the same range, the behavior is not well-defined. A
conflict may be detected, or both transaction may be permitted to commit. In the scenario
that both commit, if the system crashes and recovery runs, the resulting state of the
database may be different to what was in the cache had the crash not happened.

@section btree_truncate_performing_reads_on_truncated_pages Performing Reads On Truncated Pages

In some scenarios, a reader may want to read from some pages that have been marked as
truncated. If the desired read timestamp is between the oldest timestamp and the
truncate timestamp, the pages must first be re-instantiated into memory. The
\c __wt_page_in_func (see \c bt_read.c) reads in a page from disk, and builds an
in-memory version. Then as part of the page read process, we create a \c WT_UPDATE
with a tombstone in the same transaction the truncate happened.

*/