/*! @arch_page arch-dhandle Data Handles and Btrees

@section dhandle_data_handles_and_btrees Data Handles and B-Trees

The data handle (dhandle) and B-Tree data structures exist in a WiredTiger system 
as different ways to reference the data in a B-Tree. The dhandle (\c WT_DATA_HANDLE) 
is a generic representation of any named data source, and is an abstraction of an 
operating system file handle. Dhandles are required to access any data source in 
the system. It contains a set of flags, the specific data handle type, some 
reference counts, and individual data source statistics. A B-Tree (\c WT_BTREE) 
is a type of dhandle and embodies both the on-disk and in-memory representations 
of the B-Tree. The B-Tree contains a memory cache of key value pairs, along with 
functions to read and write data as needed to and from the data file. A B-Tree is 
paired with a data handle to allow the transfer of data, and inside the code they 
have circular references to each other.

@section dhandle_data_handle_lifecycle Data Handle Lifecycle

Dhandles are owned by the connection and shared among sessions. WiredTiger 
maintains all dhandles in a global dhandle list accessed from the connection. 
Multiple sessions access this list, which is protected by a R/W lock. Each 
session also maintains a session dhandle cache which is a cache of dhandles 
a session has operated upon. The entries in the cache are references into 
the global dhandle list.

@section dhandle_data_handle_creation Data Handle Creation

Generally, dhandles are created when accessing tables that have not been 
accessed before. When a cursor in a session attempts to access a WiredTiger 
table, it first attempts to find the dhandle in the session dhandle cache. 
If the dhandle is not found in the session dhandle cache, it searches the 
global dhandle list while holding the read lock. In the case that it 
doesn't find the dhandle there, it creates a dhandle for this table and 
puts it in the global dhandle list while holding the write lock on the 
global dhandle list. Finally, the cursor operation puts a reference to 
the dhandle in the session's dhandle cache.

@section dhandle_data_handle_reference_counts Data Handle Reference Counts

There are two relevant reference counters in the dhandle structure, 
\c session_ref and \c session_inuse. \c session_ref counts the number of 
session dhandle cache lists that contain this dhandle. \c session_inuse 
is a count of the number of cursors opened and operating on this dhandle. 
Both these counters are incremented by the session as the cursor attempts 
to use this dhandle. \c session_inuse is decremented when the operation 
completes and the cursor is closed.

@section dhandle_sweep_server_dhandle_sweep Sweep-Server DHandle Sweep

WiredTiger maintains a sweep server in the background for the cleanup of 
the global dhandle list. As dictated by the \c close_scan_interval 
variable, the sweep server periodically revisits the dhandles in the 
global list and if a dhandle is no longer being used (signified by the 
\c session_inuse count going to 0), it assigns the current time as the 
time of death if not already done before.

Dhandles are not immediately closed when the time of death field is set. 
The sweep server will keep the dhandle there for a configured amount of 
idle time (\c close_idle_time), and will only close the associated data 
source if it remained idle for that amount of time since time of death. 
The closure of the dhandle often occurs on the next iteration of the 
sweep when the sweep server detects the dhandle has remained idle for 
long enough. The server marks the dhandle as dead so that the next time 
a session with a reference walks its own cache list, it will see the 
handle marked dead and remove it from the session's dhandle cache list.

The sweep server then checks for any sessions that are referencing this 
dhandle. If a dhandle stays referenced by at least one session 
(\c session_ref count > 0), the dhandle cannot be removed from the 
global list. If the dhandle is not referenced by any session, the sweep 
server removes the dhandle from the global dhandle list and frees any 
remaining resources associated with it. The removal of the dhandle from 
the global list completes the lifecycle, and any future access of the 
associated table will require the dhandle to be created again.

@section dhandle_dhandle_session_cache_sweep

A session's dhandle cache list is periodically cleaned out through a 
dhandle cache sweep, which removes references to the dhandles that 
have not been accessed by the session in a long time. Sessions have 
their own sweeps; since a session is single-threaded, a session's 
dhandle cache can only be altered by that session alone.

Each time a session accesses a dhandle, it checks if enough time has 
elapsed to do a session cache sweep for that session. As it walks the 
session dhandle cache list, it notices if any dhandle on its list has 
been marked dead (idle for too long). If it has, the session removes 
that dhandle from its list and decrements the session_ref count.

@section btree_btrees B-Trees

Database tables are commonly represented by a B-Tree data structure, which 
is made up of nodes that are page structures. The root and internal pages will 
only store keys and references to other pages, while leaf pages store keys, 
values and sometimes references to overflow pages. The focus here will be on 
the in-memory representation of the B-Tree which is defined in \c btmem.h. The 
on-disk representation and organization of pages is discussed in the 
@ref arch-data-file page.

@section btree_btree_data_handle B-Tree Data Handle (WT_BTREE)

The B-Tree data handle serves as a way to access the underlying B-Tree data 
structure. The \c WT_BTREE structure (defined in \c btree.h) contains a 
reference to its corresponding generic data handle, checkpoint information, the 
specific WT_BTREE type, key and value formats, collator, key and page size 
configurations, split information, a reference to the root page on disk, write 
generation information, sync information, eviction information, and a set of flags.

@section btree_btree_in_memory_representation B-Tree In-Memory Representation

Inside a \c WT_BTREE, the reference to the root page is a \c WT_REF, which 
represents a single in-memory page and its state information. The \c WT_REF 
structure contains a page structure (WT_PAGE) which further describes the in-memory 
page information, a reference page (for splits), a set of either internal- or 
leaf-page flags, an address, and fast-truncate information; either a 
\c WT_PAGE_DELETED structure if the page is not instantiated in memory or an update 
list otherwise. In-memory internal pages have an array of pointers (\c WT_PAGE_INDEX) 
to child structures, maintained in collated order, and a child page of an internal 
page may cause a split at any time. In-memory internal pages also store a reference 
to their parent reference and the generation of the last split.

An in-memory row-store leaf page contains key/value pairs represented by the 
\c WT_ROW structure. These structures are created from on-page data. Each row may 
have some old values, or deleted values. Entries on leaf pages can be updated, 
either modified or deleted. On a given page, a WT_UPDATE array will be allocated 
with enough slots for every existing element in the page. A slot points to a 
\c WT_UPDATE structure, and \c WT_UPDATE structures can be formed into a linked 
list when multiple updates are done for an entry. New key/value pairs can also be 
inserted into row-store leaf pages (\c WT_INSERT).

*/
