/*! @arch_page arch-row-column Row Store & Column Store

@section Definition

A row oriented storage is a database management system where all columns of a row are stored
together, the data is stored by row, while a column oriented system stores its data tables by
column, the data is stored by column. WriedTiger supports both and each management system is
represented by a certain type of B-Tree data structure.

Keys and values in row-stores can be anything of arbitrary length, thus, row-stores implement a
generalized version of a B-Tree. However, column-stores use a 64-bit unsigned integer record id as
keys, thus, column-stores implement a specialized version of a B-Tree where the key has a
predictable length.

There are two types of column-stores in WiredTiger:
- The fixed length column-store, as its name implies, the value has a fixed length, and furthermore
the value is restricted to 1 and 8 bits in length. The bit length is specified when the column store
 is created. The fixed length column store has specialized use cases like bitmaps
- The variable length is a more general case which allows for values to have any length, and may
have arbitrary types, including aggregates of various types.

@section Main differences

Column-store keys are derived from the value's location in the table while row-store keys are
physically stored in the table. This means there is no repetition of keys across multiple files for
column-stores while row-store keys are always replicated in multiple files. Therefore, column-stores
have a real benefit over row-stores when it comes to finding a record, since there is only one key
per page and keys take almost no storage, fast lookups can be performed and it is easy to move
between records. For row-stores, a slower approach is necessary (i.e binary search) to locate a
particular record.

When reading and writing column-stores, only the columns required for any particular query are
maintained in memory. For row-stores, the memory usage will depend on the definition of column
groups required by the query.

Generally, row-stores are faster for queries where all of the columns are required by every lookup
because there is only a single set of meta-data pages to read into the cache and search.
Column-stores are faster when most queries require only a subset of the columns because columns can
be separated into multiple files and only the columns being returned need to be present in the
cache. In both cases, for better efficiency, one should define column groups according to queries
that will be mostly performed. Finally, row-stores and column-stores can be mixed-and-matched at the
table level: for example, a row-store index can be created on a column-store table.

@section Internal usage

Internally, row-stores and column-stores use a common \c WT_BTREE structure. The fundamental
difference is that the \c WT_BTREE->type field is set \c BTREE_ROW for row-stores and \c BTREE_COL
for column-stores. Internal functions that navigate, access and manipulate B-Trees have code
sprinkled throughout that is conditional on \c WT_BTREE->type.

<table>
@hrow{, Row Store, Column Store - Variable Length, Column Store - Fixed Length}
@row{Characteristics,,,,}
@row{Internal representation, B-Tree (\c WT_BTREE), B-Tree (\c WT_BTREE), B-Tree (\c WT_BTREE)}
@row{B-Tree type, Generalized (\c BTREE_ROW), Specialized (\c BTREE_COL_VAR), Specialized (\c BTREE_COL_FIX)}
@row{Internal pages, Key count equal to half the number of physical entries (unless all empty values flag is set where key count is equal to the number of physical entries), Only the first key is stored, Only the first key is stored}
@row{Record key,Anything (byte-string), prefix compressed or overflow objects, Record id (64 bit unsigned integer), Record id (64 bit unsigned integer)}
@row{Record value, Variable byte string length, Variable byte string length, Fixed byte string length (up to 8 bits)}
@row{Features,,,,}
@row{Random cursor, Yes, No, No}
@row{Block compression, Yes, Yes, Yes}
@row{Dictionary compression, Yes, Yes, No}
@row{Fast truncate, Yes, No, No}
@row{Huffman encoding cursor, Yes, Yes, No}
@row{Prefix and suffix compression, Yes, No, No}
</table>

*/
