/*! @arch_page arch-row-column Row Store & Column Store

@section Definition

A row oriented storage is a database management system where all columns of a row are stored
together, the data is stored by row, while a column oriented system stores its data tables by
column. WiredTiger supports both and each management system is represented internally by a certain
type of B-Tree data structure.

Keys and values in row-stores can be anything of arbitrary length, thus, row-stores implement a
generalized version of a B-Tree. Furthermore, keys are explicitly stored. Column-stores use a 64-bit
unsigned integer record id as keys, thus, column-stores implement a specialized version of a B-Tree
where the key has a predictable length. In the case of column-stores, keys are implied given the
B-Tree position.

There are two types of column-stores in WiredTiger:
- The fixed length column-store, as its name implies, the value has a fixed length, and furthermore
the value is restricted to 1 and 8 bits in length. The bit length is specified when the column store
is created. The fixed length column store has specialized use cases like bitmaps.
- The variable length is a more general case which allows for values to have any length similarly to
row-stores.

@section In-memory and on-disk format

Row-stores and column-stores have a specific in-memory and on-disk data structure. Please refer to
the Data File Format section to learn more.

@section Row-stores

Row-stores are probably seen as the traditional database management system and they serve a general
purpose. In WiredTiger, row-store keys are explicitly stored and they are usually duplicated within
the same single file. In order to locate a specific record and pull together a complete row, a
search algorithm is required. When reading and writing row-stores, the memory usage will depend on
the definition of column groups required by the query.

@section Variable length column-stores

The main advantage of variable length column-stores is probably storage. Their keys are not stored
but derived from the B-Tree location in the memory. In fact, there is a starting key on each page
which is used to figure out the rest of the keys present on that same page. Column-stores values
also present an advantage to further save more disk space as they can be written in more compact
forms through encoding techniques. In WiredTiger, the run-length encoding is used to replace any
sequence of the same value with a count and value indicator. However, this makes the access to a
specific record more complicated, it is no longer possible to jump to a record in a leaf page.
Finally, when reading and writing column-stores, only the columns required for any particular query
are maintained in memory.

@section Fixed length column-stores

Fixed length column stores are very different internally and usually serve specific purposes as it
is a bitmap. It makes fixed length column-stores efficient to retrieve a value at a given offset,
the use of bloom filters is probably one of the best examples.

@section Performance

Generally, row-stores are faster for queries where all of the columns are required by every lookup
because there is only a single set of internal pages to read into the cache and search.
Column-stores are faster when most queries require only a subset of the columns because columns can
be separated into multiple files and only the columns being returned need to be present in the
cache. In both cases, for better efficiency, one should define column groups according to queries
that will be mostly performed. Finally, row-stores and column-stores can be mixed-and-matched at the
table level: for example, a row-store index can be created on a column-store table.

@section Internal usage

Internally, row-stores and column-stores use a common \c WT_BTREE structure. The fundamental
difference is that the \c WT_BTREE->type field is set \c BTREE_ROW for row-stores and \c BTREE_COL
for column-stores. Internal functions that navigate, access and manipulate B-Trees have code
sprinkled throughout that is conditional on \c WT_BTREE->type.

<table>
@hrow{, Row Store, Column Store - Variable Length, Column Store - Fixed Length}
@row{Characteristics,,,,}
@row{Internal representation, B-Tree (\c WT_BTREE), B-Tree (\c WT_BTREE), B-Tree (\c WT_BTREE)}
@row{B-Tree type, Generalized (\c BTREE_ROW), Specialized (\c BTREE_COL_VAR), Specialized (\c BTREE_COL_FIX)}
@row{Leaf pages, Key count equal to half the number of physical entries (unless all empty values flag is set where key count is equal to the number of physical entries), Only the first key is stored, Only the first key is stored}
@row{Record key,Anything (byte-string), prefix compressed or overflow objects, Record id (64 bit unsigned integer), Record id (64 bit unsigned integer)}
@row{Record value, Variable byte string length, Variable byte string length, Fixed bit string length (up to 8 bits)}
@row{Features,,,,}
@row{Random cursor, Yes, No, No}
@row{Block compression, Yes, Yes, Yes}
@row{Dictionary compression, Yes, Yes, No}
@row{Fast truncate, Yes, No, No}
@row{Huffman encoding, Yes, Yes, No}
@row{Prefix and suffix compression, Yes, No, No}
@row{RLE compression, No, Yes, No}
</table>

*/
