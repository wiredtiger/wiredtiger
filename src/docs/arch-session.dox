/*! @arch_page arch-session Session

@section arch_session_def Definition
After a @ref arch-connection "Connection" has been established between the application and
WiredTiger, the
application can start sending requests to WiredTiger using a session. A session is internally
represented by WT_SESSION and plays an important role since almost all operations are performed
under the context of a session.

A session can only be created through an existing connection with the API
WT_CONNECTION::open_session and it is possible to create multiple sessions through the same
connection. In fact, one connection can have multiple sessions but one session can only be
associated with one connection. The maximum number of sessions is set through the configuration item
\c session_max as part of the configuration string in ::wiredtiger_open.

Sessions created by the calling application are called "user sessions". WiredTiger also performs
some internal operations such as @ref arch-eviction "Eviction" through self-created sessions. These sessions
are called "internal sessions". The usage rules and guidelines for both internal sessions and user
sessions are the same and the only difference between them is their origin of creation.

@section arch_session_ops Operations
The different operations that can be performed on a WiredTiger session are related to cursors,
tables and transactions. You can read the complete description of each possible operation in the
documentation related to WT_SESSION.

@section arch_session_txn Transactions
It is possible to group several operations within a session, in other words, multiple operations can
be treated as a single atomic operation. This can be done using @ref arch-transaction
"Transactions". Furthermore,
a session can hold only one running transaction at any given time and this transaction only belongs
to that session.

@section arch_session_cur Cursors
A session can perform multiple data operations on one or several collections using multiple cursors
(see @ref arch-cursor "Cursor" for more details). All the cursors associated with a session share that
session transaction context. It is also possible to cache those cursors if required through the
configuration string given to WT_CONNECTION::open_session or ::wiredtiger_open. The configuration
item for this purpose is \c cache_cursors.

@section arch_session_dhandles Data Handles
During its lifetime, a session can accumulate a list of data handles (see @ref arch-dhandle "Data Handles").
Indeed, when a session accesses a table for the first time, the data handle of that table is
acquired and cached. Once a session no longer needs to operate on a table, it marks the associated
data handle as idle. This helps the sweep server release data handles that are inactive, see @ref
arch-dhandle for more details.

@section arch_session_closure Closure
A session can be closed using WT_SESSION::close. Closing the connection will also close all opened
sessions. When a session is closed, it releases all the resources associated with it including
rolling back any active transaction and closing the cursors that are still open.

@section arch_session_thread Multithreading
A session is always executed as a single thread, see @ref threads for more details.

@section arch_session_error Errors and Sub-level Errors
When WiredTiger operations encounter an error, a non-zero error code is returned
which indicates the general type of error. Along with this, there are also sub-level error codes which are more specific.
These sub-level error can accompany the error code, to better identify the source of error.
Every session API call (except WT_SESSION::get_last_error) will be completed with a refreshed
error_info struct containing an error code, a sub-level error code, and an error message. These are
extracted by using WT_SESSION::get_last_error. The error code indicates the general type of error,
while the sub-level error code and error message provide additional context.
See @ref error_handling for details. When a session API call is made, API_SESSION_INIT is called and err_info is reset to an error code
0, sub-level error code WT_NONE, and error message "the last API call was successful.
Only the earliest error is saved and will not be overwritten by an error
that occurs later. At the end of the API call, API_END is called, which does an additional check on
the return value. If it is non-zero and it is not the same as the error code in err_info. It will
attempt to save this error with a sub-level error code WT_NONE, and an error message as an empty string. The
overwrite rules still apply, and will not overwrite a previously saved error within the API call.

@subsection arch_session_error_ret Sub-level Errors - WT_RET_MSG and WT_RET_SUB
When errors occur within the system, errors can be saved with four macros: WT_RET_MSG, WT_ERR_MSG,
WT_RET_SUB, WT_ERR_SUB. WT_RET_MSG and WT_ERR_MSG save errors without a sub-level error code,
defaulting the sub-level error code to WT_NONE. WT_RET_SUB and WT_ERR_SUB save errors with a
sub-level error code. In all four macros, an error code must be included, and the error message is
optional. In terms of saving errors, WT_RET_MSG and WT_ERR_MSG have the same behavior, and
WT_RET_SUB and WT_ERR_MSG also behave the same.

@subsection arch_session_error_sessions Sub-level Errors - External & Internal Sessions
When saving an error, the session must have the WT_SESSION_SAVE_ERRORS flag set, or the error will
not be saved. External sessions have this flag set while internal sessions do not. This is because
internal sessions are not part of the session API and users do not have access to them. However, when an
external session opens an internal session, it will inherit the external sessions flags including
the WT_SESSION_SAVE_ERRORS flag. This allows any errors that occur to be saved within the internal
session and propagate back to the external session, when the internal session is closed.

@subsection arch_session_error_buffers Sub-level Errors - Static & Dynamic Buffers
When setting err_info, if the error message is an empty string or "the last API call was successful", then a
static buffer is used, otherwise a dynamic buffer is allocated. This saves the system from having to copy
memory unnecessarily. When err_info is refreshed after
each API call, if a dynamic buffer was allocated, it is freed.
*/
