/*! @arch_page arch-eviction Eviction

@section eviction_overall Eviction
Eviction in WiredTiger is a process to remove data that is currently not being accessed out of the
memory to free up enough space to read data back into memory that is requested by the user but currently
reside on the disk. If the data needs to be written, it is reconciled (converting the in-memory format
to on-disk format), and then written.

Eviction is managed using \c WT_EVICT_QUEUE structures,
each of which contains a list of \c WT_EVICT_ENTRY structures.

Eviction is composed of one eviction server, 0 or more eviction worker threads and three shared
eviction_queues (two ordinary queues and one urgent queue). It is possible to have just the eviction server
and no worker threads and in such a case, eviction server both walks the tree to find pages to evict and
evict these pages from the cache. Pages that are being marked for forced eviction go onto the urgent
queue, and these pages take a precedence over the pages from the ordinary eviction queues.

A user can pass a minimum and a maximum number of eviction worker threads to be created through the connection
configuration string. An internal mechanism dynamically adjusts the number of eviction worker threads active
at any given time to suit to the instantaneous eviction workload.

- Eviction server walks the pages in the btree to find the candidates to be evicted ,sorts the
  list of candidates and throws the 1/3 of the candidates to do an approximate LRU and pushes the
  remaining pages into the eviction_queues.
- Eviction worker threads goes over the eviction_queues to pop the pages and tries to evict.

Eviction has to get an exclusive access to the page as there may be other threads still reading
content on the page that is being evicted.

Eviction runs in the background continuously looking for pages when an application approaches the
maximum cache size.

@section clean_dirty_data Clean vs dirty data
- Clean refers to data in the cache that is identical to the version stored on disk.
- Dirty refers to data in the cache that has been modified and needs to be reconciled with the data stored in disk.

There are three types of eviction in WiredTiger:
- Clean eviction
- History store eviction
- Update restore eviction

@subsection clean_eviction_1 Clean eviction
In the case of clean eviction, there is no dirty content on the page and it is directly removed from the
memory. After that, the page remains solely on the disk unchanged.

@subsection hs_eviction_1 History store eviction
For history store eviction, the page is modified but the changes are all committed. Therefore, the page
should be clean and can be removed from memory after the dirty changes are written to the new disk
image, which is the data format WiredTiger stores on disk. The process that builds the disk image
is called reconciliation. In reconciliation, WiredTiger writes the newest committed value of each
key to the disk image. All the older values of the key are moved to the history store table. In the
end, reconciliation flushes the new disk image to the data file on the disk and later eviction
removes the old page from memory.
The history store table is the internal table for WiredTiger to store historical values for all the
user-created tables. Each entry in the history store represents a historical value of a key in the
user-created tables. The pages in the history store table need to be evicted and loaded back to memory
as well. Different from the user-created tables, all the content on the history store page is committed
as the historical values it stores must all be committed, and each entry only has one value and a
deletion marking the expiration of the entry on its update chain. Therefore, history store pages
should always be clean after reconciliation and can be evicted from memory. Besides, only having
one committed value for each key in the history store prevents eviction from moving content already
in the history store recursively to the history store when evicting a history store page because we
only move the values after the first committed value to the history store.

@subsection update_restore_eviction_1 Update restore eviction
Update restore eviction largely overlaps with history store eviction. The difference is that there
are uncommitted changes on the page and WiredTiger cannot write them to the disk image. Instead, besides
writing the disk image to the disk, eviction also keeps the disk image in memory and restores the
uncommitted changes to the new disk image.
Since usually there is only a subset of keys that have uncommitted changes, eviction only needs to
restore those keys that are dirty after reconciliation. Apart from that, eviction may split a page
into multiple pages and some of them may be clean after reconciliation even though the old page before
split has uncommitted changes. Therefore, WiredTiger tracks whether it needs to do update restore eviction
at the key level and the page level.
At the key level, the key needs to be restored if it has uncommitted updates. For each new page, restoration
is required if any of the keys on the new page needs to be restored. Once eviction decides to restore a
page, it will make a copy of the disk image in memory during reconciliation.
For the restored keys, eviction also frees all the values that have been written to the disk image or
moved to the history store as there is no need to duplicate them on the update chains. For the clean
keys that are not restored, their whole update chains are removed from memory along with the old disk image.

Eviction triggers

WiredTiger provides several configuration options for tuning how pages are evicted from the cache.

WiredTiger eviction tuning options can be configured when first opening
a database via ::wiredtiger_open, or changed after open with
WT_CONNECTION::reconfigure.

The \c eviction_target configuration value (default 80%) is the level at
which WiredTiger attempts to keep the overall cache usage.  Eviction worker
threads are active when the cache contains at least this much content,
expressed as a percentage of the total cache size.

The \c eviction_trigger configuration value (default 95%) is the level at
which application threads start to perform eviction.

The \c eviction_dirty_target (default 5%) and \c eviction_dirty_trigger
(default 20%) operate in a similar way to the overall targets, but only
apply to dirty data in cache.  In particular, application threads will be
throttled if the percentage of dirty data reaches the
\c eviction_dirty_trigger. Any page that has been modified since it was
read from disk is considered dirty.
The \c eviction_updates_target (default 0%) perform eviction in worker
threads when the cache contain at least this many bytes of updates
The \c eviction_updates_trigger trigger application threads to perform
eviction when the cache contains at least this many bytes of updates.

*/
