/*! @page transactions Transactions

@section transactions_acid ACID properties

Transactions provide a powerful abstraction for multiple threads to
operate on data concurrently because they have the following properties:

- Atomicity: all or none of a transaction is completed.
- Consistency: if each transaction maintains some property when considered
  separately, then the combined effect of executing the transactions
  concurrently will maintain the same property.
- Isolation: developers can reason about transactions as if they run
  single-threaded.
- Durability: once a transaction commits, its updates cannot be lost.

WiredTiger supports transactions with the following caveats to the ACID
properties:

- the maximum level of isolation supported is snapshot isolation.
  See @ref transaction_isolation for more details.
- only coarse-grained durability is supported: updates become durable
  when they are part of a checkpoint, not at commit time.  If there is
  a crash, commits since the last checkpoint will be lost.

@section transactions_api Transactional API

In WiredTiger, the transactional context is managed by the WT_SESSION
class.  Applications call WT_SESSION::begin_transaction to start a new
transaction, which is only permitted when no cursors are open.  Operations
performed with that WT_SESSION handle are then part of the transaction, and
their effects can be committed by calling WT_SESSION::commit_transaction or
WT_SESSION::rollback_transaction, both of which implicitly close any open
cursors.

@snippet ex_all.c simple transaction

When transactions are used, update operations that conflict with a
concurrent transaction will fail with the ::WT_DEADLOCK error.
Transactions should be rolled back with WT_SESSION::rollback_transaction
and retried if this error occurs.

@snippet ex_all.c simple rollback transaction

@section transactions_concurrency Concurrency control

WiredTiger uses optimistic concurrency control algorithms.  This avoids
the bottleneck of a centralized lock manager and ensures transactional
operations do not block: reads do not block writes, and vice versa.

Further, writes do not block writes, although concurrent transactions
updating the same value will fail with ::WT_DEADLOCK.  Some applications
may benefit from application-level synchronization to avoid repeated
attempts to rollback and update the same value.

@section transaction_isolation Isolation levels

WiredTiger supports <code>read-uncommitted</code>,
<code>read-committed</code> and  <code>snapshot</code> isolation levels;
the default isolation level is is <code>read-committed</code>.

- <code>read-uncommitted</code>:
Transactions can see changes made by other transactions before those
transactions are committed.  Dirty reads, non-repeatable reads and
phantoms are possible.

- <code>read-committed</code>:
Transactions cannot see changes made by other transactions before those
transactions are committed.  Dirty reads are not possible;
non-repeatable reads and phantoms are possible.

- <code>snapshot</code>:
Transactions read the versions of records committed before the transaction
started.  Dirty reads and non-repeatable reads are not possible; phantoms
are possible.<br><br>
Snapshot isolation is a strong guarantee, but not equivalent to a
single-threaded execution of the transactions, known as serializable
isolation.  Concurrent transactions T1 and T2 running under snapshot
isolation may both commit and produce a state that neither (T1 followed
by T2) or (T2 followed by T1) could have produced, if there is overlap
between T1's reads and T2's writes, and between T1's writes and T2's
reads.

The transaction isolation level can be configured on a per-transaction
basis:

@snippet ex_all.c simple transaction isolation

Additionally, the default transaction isolation can be configured and
re-configured on a per-session basis:

@snippet ex_all.c session isolation configuration

@snippet ex_all.c session isolation re-configuration

@section transaction_recovery Checkpoints and Recovery

Recovery is run automatically when a data source is opened.  Any changes
since the last checkpoint are discarded, and the application restarts
from a consistent point in the transaction history.

This demonstrates the importance of regular checkpoints: they limit the
volume of commits that may be lost in a crash.  See
WT_SESSION::checkpoint and @ref checkpoints for further information.

 */
