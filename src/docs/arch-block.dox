/*! @arch_page arch-block Block Manager

The WiredTiger block manager subsystem manages the reading and writing of data
from the disk. It is designed to facilitate high performance, economic use of
disk space and customizability.

@section block What is a block?

A block is a chunk of data that is stored on the disk and operated on as a
single unit. Each WiredTiger data file (any file in the home directory with the
\c .wt suffix) is made up of these blocks. Each block consists of a page header,
a block header and contains a single page from the btree which it was
generated. Blocks can only be written once and a new block is created upon
reconciliation of a dirty page. The size of a block is a multiple of the
allocation size which is set during creation of associated WiredTiger data file
see: WT_SESSION::create.

Once a block is written the address of the block is returned and is referred to
the \c addr. The address is made up of 4 components:
 - offset: The offset in the file. In order to avoid storing large offsets this
   value is divided by the allocation size.
 - file_id: While only relevant to the tiered storage type the file_id is
   maintained in the address.
 - size: The size of the block, also divided by the allocation size.
 - checksum: The checksum of the block for validation purposes.

The block header contains the following fields:
 - size: The size of the block on disk, used when salvaging data from a corrupt
   file.
 - checksum: The checksum of the block, again used for salvaging.
 - flags: Currently only flag exists.
 - padding

The page header is not described in this document but can be found in
\c btmem.h.

@section block_usage How WiredTiger uses the block manager

@subsection creation File creation and the block manager

When a new file is created in WiredTiger via WT_SESSION::create, the file is
created on disk and the associated \c allocation_size is written out to the
metadata file. However the block manager itself isn't created. Only when a btree
is opened does WiredTiger allocate a block manager. Each btree has it's own
block manager.

@subsection read Reading files and pages

When an existing btree is opened for the first time, the location of the root
block is contained in the metadata file \c WiredTiger.wt. The block manager will
read the block at the location specified and return the page image as a buffer
to the layer above. This will then be instantiated as a page in memory.

From there subsequent page addresses can be read from the root page and the
process repeated as required. If a cursor traverses to a page which hasn't been
read into memory the same process will take place.

@subsection Writing

Two cases exist for writing out data using the block manager, checkpoint and
eviction. Both are explained in the following two sections. When a page image
is written out the block manager the \c bm->write API is called. See \c bt_io.c
for more detail.

@subsubsection Checkpoint

Checkpoints are the process by which a file can be guaranteed to contain a
consistent snapshot of the data at a given point in time for more detail on that
see @ref arch-checkpoint.

At the block manager level a checkpoint corresponds with a set of blocks which
are stored in the file associated with the given URI. Typically each file will
contain a minimum of two checkpoints. When opening an existing file the latest
checkpoint is read.

When WiredTiger performs a checkpoint clean pages will not result in additional
blocks being created and as such existing blocks from older checkpoints may be
reused, this means that while there may be more than one checkpoint in a file
the block are not guaranteed to be mutually exclusive. Checkpoints are created
in depth first order, leaf blocks are created, then the parent blocks. This is
a requirement as the parent blocks contain the addresses of the leaf blocks.

The block manager doesn't guarantee that calling \c bm->write will result in
the data being flushed to disk. In the checkpoint scenario WiredTiger will also
call \c bm->sync which will call the file system dependent flush function.

As a checkpoint progresses it updates its three extent lists, these extent lists
are written out to disk as part of the checkpoint in blocks. When a checkpoint
is written the previous checkpoints will be cleaned up if possible, suppose we
have finished writing out checkpoint C and have checkpoints A and B on disk.
We only need to retain two checkpoints so we can cleanup checkpoint A.
Checkpoint A's extent lists get merged into checkpoint B's extent lists. If
a block, N, is in the alloc list of checkpoint A and the removed discard list
of checkpoint B the block is considered free. Until a block in an alloc list
is seen in a discard list the space cannot freed.

@subsubsection Eviction

Eviction also utilizes the block manager, when a page is evicted and contains
data that needs to be maintained, logically a block needs to be written.
Eviction also calls \c bm->write however it does not instruct the block manager
to sync the data.

@subsection Compaction

As WiredTiger maintains two checkpoints by default the file size will often be a
multiple of the data size modulo the compaction ratio. And given that new blocks
are written by default where they fit best it's common that removal of data will
not result in the file shrinking. As the file can only be shrunk when there are
available blocks at the end of the file.

To manage this WiredTiger provides a compaction API call WT_SESSION::compact,
this instructs the block manager to operate in first fit mode for all writes.
Thus the data will eventually move to the front of the file across checkpoints.

@section block_implementation Block manager implementation details

@subsection write_once Writing

The block manager decides where in the file a block will be written. It has two
forms of writing modes, first fit and best fit. The default behavior is best
fit. While operating in best fit mode a block will be placed in first block that
it finds that fits the block. This is done to avoid extending the file when
possible. When operating in first fit mode the block manager will place the
newly created block in the first available slot. When writing the root node
of a b-tree first fit mode is used.

Additionally the block manager is a no-overwrite system. As such once a block is
written it cannot be modified. This is for crash recovery reasons as if the
system was to crash during an overwrite the block state would be unknown.

@subsection desc_block Descriptor blocks

As discussed earlier, a file is divided up into blocks. The first block in a
file is special as it contains metadata about the file and is referred to as the
"descriptor block". It contains the WiredTiger major and minor version, a
checksum of the block contents as well as a "magic" number to check against.

The descriptor block serves as a safety check to ensure that the file being
loaded into the block manager is actually a WiredTiger data file, that it
belongs to a compatible version of WiredTiger and that the entire file has not
been corrupted. WiredTiger also offers block-level checksums to defend against
file corruption at a more granular level, which can be found in the
\ref checksum section.

@subsection block_lists Extent lists

Internally, WiredTiger uses a data structure called an extent list or a
\c WT_EXTLIST to track file usage. An extent list consists of a series of
extents (or \c WT_EXT elements). Each extent tracks a file offset and size to
track a portion of the file.

There are three extent lists that are maintained per checkpoint:

- \c alloc: The extents allocated for a given checkpoint.
- \c avail: The extents that are unused and available for allocation.
- \c discard: The extents freed in the current checkpoint. After the checkpoint
completes, these extents are shifted to the \c avail extent list.

The alloc and discard extent lists are maintained as a skiplist sorted by file
offset. The avail extent list also maintains an extra skiplist sorted by the
extent size to aid with allocating new blocks.

@section configuration Configuration options

There are a number of configuration options that affect the block manager's
behavior. This does not aim to be an exhaustive list, however, these are the
configuration options that are more commonly of interest to users.

All of the configuration options below are passed into the \c WT_SESSION::create
API at the time of file creation.

@subsection alloc_size Allocation size

The allocation_size configuration controls the file unit allocation_size.
Any blocks allocated by the block manager must be a multiple of this value.

For example, if we specify an allocation_size of \c 4KB, blocks of size
\c 8KB and \c 12KB would be permitted but NOT \c 10KB. Higher allocation_sizes
may yield better compression rates, yet may cause larger page sizes. The
allocation_size is set to \c 4KB by default which is a good choice unless your
OS or storage device has special requirements.

@subsection checksum Checksum

The \c checksum configuration controls whether blocks have a checksum stored
alongside them. With block checksums enabled, a block written to disk it is
accompanied by a checksum of the block contents. When that block is read off the
disk to reconstruct a page, we recompute the checksum and verify that is the
same to defend against the risk of file corruption.

*/
