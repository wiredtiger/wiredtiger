/*! @arch_page arch-checkpoint Checkpoint

# Overview #

A checkpoint is a known point in time from which WiredTiger can recover in the event of a
crash or unexpected shutdown. WiredTiger checkpoints are created either via the API
WT_SESSION::checkpoint, or internally. Internally checkpoints are created on startup, shutdown
and during compaction.

A checkpoint is performed within the context of snapshot isolation transaction as such the
checkpoint has a consistent view of the database from beginning to end. The checkpoint can be run
with or without a timestamp, generally a timestamp is used. This timestamp is not used as a
\c read_timestamp for the checkpoint transaction. The timestamp provided is set to the checkpoint
timestamp which is written out with the metadata information for the checkpoint.

# The checkpoint algorithm #

A checkpoint can be broken up into 5 main stages:

1. The prepare stage
Checkpoint prepare sets up the checkpoint, it begins the checkpoint transaction, updates the global
checkpoint state and gathers a list of handles to be checkpointed. Where each handle refers to a
specific b-tree. The set of b-trees gathered by the checkpoint varies based off configuration.
Additionally clean b-trees, i.e. b-trees without any modifications are excluded from the list.

2. The datafiles checkpoint
The main work of checkpoint is done here, the array of b-tree's collected in the prepare stage are
iterated over. For each b-tree, the tree is walked and all the dirty pages are reconciled. Skipping
clean pages to avoid unnecessary work.

3. The history store checkpoint
The history store is checkpointed after the datafiles intentionally as during the reconciliation
of the data files additional writes may be created in the history store and its important to include
them in the checkpoint.

4. Flushing the files to disk
All the b-trees checkpointed and the history are flushed to disk at this stage, WiredTiger will wait
until that process has completed to continue with the checkpoint.

5. The metadata checkpoint
A new entry into the metadata file is created for every datafile checkpointed, including the
history store. As such the metadata file is the last file to be checkpointed. As WiredTiger
maintains two checkpoints, the location of the most recent checkpoint is written to the turtle file.

# Skipping checkpoints #

It is possible that a checkpoint will be skipped. If no modifications to the database have been
made since the last checkpoint, and the last checkpoint timestamp is equal to the current stable
timestamp then a checkpoint will not be taken. This logic can be overridden by forcing a checkpoint
via configuration.

# Checkpoint generations #

The checkpoint generation indicates which iteration of checkpoint a file has undergone, at the start
of a checkpoint the generation is incremented. Then after processing any b-tree its
\c checkpoint_gen to the latest checkpoint generation. Checkpoint generations impact visibility
checks within WiredTiger, essentially if a b-tree is behind a checkpoint, i.e. its checkpoint
generation is less than the current checkpoint generation, then the checkpoint transaction id and
checkpoint timestamp are included in certain visibility checks. This prevents eviction from evicting
updates from a given b-tree ahead of the checkpoint.

*/
