/*! @page timestamp_prepare Using transaction prepare with timestamps

Applications configuring timestamps can use the WT_SESSION::prepare_transaction
call as the pre-commit step in the implementation of a two-phase commit protocol.
(WiredTiger currently only permits transactions to be prepared when timestamps
are in use.)

The WT_SESSION::prepare_transaction method assigns a prepare timestamp to the
transaction, which will be used for visibility checks until the transaction is
committed or aborted. Once a transaction has been prepared no further data
operations are permitted, and the transaction must next be resolved by calling
WT_SESSION::commit_transaction or WT_SESSION::rollback_transaction.
Calling WT_SESSION::prepare_transaction only
guarantees that transactional conflicts will not cause the transaction to
roll back and specifically does not guarantee the transaction's updates are
durable.

If a read operation encounters an update from a prepared transaction,
the error ::WT_PREPARE_CONFLICT will be returned indicating it is not possible to
choose a version of data to return until the prepared transaction is resolved.
Retrying such failed operations is reasonable, assuming prepared transactions
are expected to be resolved quickly.

Both a \c commit_timestamp and a \c durable_timestamp must be specified when
committing a prepared transaction. The job of the \c durable_timestamp is to
allow a prepared transaction to be predictably included or excluded from a
checkpoint. For non-prepared transactions, the commit timestamp controls both
transaction update visibility and durability. For prepared transactions, the
durable timestamp separately controls the durability, that is, checkpoint uses
the durable timestamp of the prepared transaction for persisting a transaction's
updates rather than the commit timestamp.

@snippet ex_all.c transaction prepare

Prepared transactions are limited to a single commit timestamp, which can only
be set after the transaction has successfully prepared. The prepare timestamp
can be set at any point in the transaction's lifecycle prior to preparing it;
doing so does not itself prepare the transaction
but does oblige the application to prepare it before committing.

The durable timestamp can only be set after the transaction has been prepared
and a commit timestamp set, or as part of transaction commit. The \c durable
timestamp provides input into the system's \c all_durable timestamp.

MongoDB specifies different commit and durable timestamps because prepared
transactions are higher-level MongoDB operations, requiring cluster-level
consensus on durability. Applications without similar requirements for prepared
transactions should set the durable and commit timestamps to the same time.

When a transaction has a durable timestamp later than its commit timestamp,
reading its writes in a second transaction and then committing such that the
second transaction becomes durable before the first can produce data
inconsistency. To help prevent this, reads between the commit and durable
timestamp will fail with ::WT_PREPARE_CONFLICT if the global stable timestamp has not
yet advanced to the durable timestamp. Retrying such transactions will
eventually succeed as long as either they are retried at a later timestamp or
the stable timestamp continues to move forward.

\warning It is also possible to create data inconsistency by reading such a
transaction's writes <i>after</i> its durable timestamp and committing without a
timestamp, if the global stable timestamp has not yet reached the durable
timestamp. (This can involve either reading with a read timestamp after the
durable timestamp, or reading with no read timestamp, as the latter reads the
latest committed values.) Applications using the delayed durable timestamp
feature should be cautious about committing with no write timestamp to ensure
that conflicts of this type cannot arise.

Prepared transactions have their own configuration keyword for rounding
timestamps; see @ref timestamp_roundup for more information.

*/
