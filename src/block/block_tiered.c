/*-
 * Copyright (c) 2014-present MongoDB, Inc.
 * Copyright (c) 2008-2014 WiredTiger, Inc.
 *	All rights reserved.
 *
 * See the file LICENSE for redistribution information.
 */

#include "wt_internal.h"

/*
 * __wt_block_tiered_fh --
 *     Open an object from the shared tier.
 */
int
__wt_block_tiered_fh(WT_SESSION_IMPL *session, WT_BLOCK *block, uint32_t object_id, WT_FH **fhp)
{
    WT_DECL_ITEM(tmp);
    WT_DECL_RET;

    /* TODO: tiered: fh readlock; we may want a reference count on each file handle given out. */

    if (object_id * sizeof(WT_FILE_HANDLE *) < block->lfh_alloc &&
      (*fhp = block->lfh[object_id]) != NULL)
        return (0);

    /* TODO: tiered: fh writelock */
    /* Ensure the array goes far enough. */
    WT_RET(__wt_realloc_def(session, &block->lfh_alloc, object_id + 1, &block->lfh));
    if (object_id >= block->max_logid)
        block->max_logid = object_id + 1;
    if ((*fhp = block->lfh[object_id]) != NULL)
        return (0);

    WT_RET(__wt_scr_alloc(session, 0, &tmp));
    WT_ERR(block->opener->open(block->opener, session, block->opener->cookie, object_id,
      WT_FS_OPEN_FILE_TYPE_DATA, WT_FS_OPEN_READONLY | block->file_flags, &block->lfh[object_id]));
    *fhp = block->lfh[object_id];
    WT_ASSERT(session, *fhp != NULL);

err:
    __wt_scr_free(session, &tmp);
    return (ret);
}

/*
 * __wt_block_tiered_flush --
 *     Flush this file, start another file.
 */
int
__wt_block_tiered_flush(
  WT_SESSION_IMPL *session, WT_BLOCK *block, uint8_t **flush_cookie, size_t *cookie_size)
{
    /* TODO: tiered: fill in the cookie. */
    (void)flush_cookie;
    (void)cookie_size;

    return (__wt_block_tiered_newfile(session, block));
}

/*
 * __wt_block_tiered_load --
 *     Set up log-structured processing when loading a new root page.
 */
int
__wt_block_tiered_load(WT_SESSION_IMPL *session, WT_BLOCK *block, WT_BLOCK_CKPT *ci)
{
    /*
     * TODO: tiered: this call currently advances the object id, that's probably not appropriate for
     * readonly opens. Perhaps it's also not appropriate for opening at an older checkpoint?
     */
    if (block->has_objects) {
        block->logid = ci->root_logid;

        /* Advance to the next file for future changes. */
        WT_RET(__wt_block_tiered_newfile(session, block));
    }
    return (0);
}

/*
 * __wt_block_tiered_newfile --
 *     Switch a log-structured block object to a new file.
 */
int
__wt_block_tiered_newfile(WT_SESSION_IMPL *session, WT_BLOCK *block)
{
    WT_DECL_ITEM(tmp);
    WT_DECL_RET;
    WT_STORAGE_SOURCE *storage_source;
    const char *filename;

    /* Get the old file name again. */
    WT_ERR(__wt_scr_alloc(session, 0, &tmp));

    /*
     * TODO: tiered: We will get rid of the log id, and this name generation will be replaced by the
     * name generated by __tiered_switch.
     */
    WT_ERR(__wt_buf_fmt(session, tmp, "%s.%08" PRIu32, block->name, block->logid));
    filename = tmp->data;
    WT_ERR(__wt_close(session, &block->fh));

    /*
     * TODO: tiered: Assert that session->bucket_storage is not NULL. We can't do that while we have
     * tests that use block_allocation=log without setting up bucket storage. This whole function is
     * going to look very different when flush_tier is fully integrated.
     */
    if (session->bucket_storage != NULL && block->logid != 0) {
        storage_source = session->bucket_storage->storage_source;
        WT_ASSERT(session, storage_source != NULL);
        WT_ERR(storage_source->ss_flush(storage_source, &session->iface,
          session->bucket_storage->file_system, filename, filename, NULL));
        WT_ERR(storage_source->ss_flush_finish(storage_source, &session->iface,
          session->bucket_storage->file_system, filename, filename, NULL));
    }
    /* Bump to a new file ID. */
    ++block->logid;
    WT_ERR(__wt_buf_fmt(session, tmp, "%s.%08" PRIu32, block->name, block->logid));
    filename = tmp->data;

    WT_WITH_BUCKET_STORAGE(session->bucket_storage, session, {
        ret = __wt_open(session, filename, WT_FS_OPEN_FILE_TYPE_DATA,
          WT_FS_OPEN_CREATE | block->file_flags, &block->fh);
    });
    WT_ERR(ret);
    WT_ERR(__wt_desc_write(session, block->fh, block->allocsize));

    block->size = block->allocsize;
    __wt_block_ckpt_destroy(session, &block->live);
    WT_ERR(__wt_block_ckpt_init(session, &block->live, "live"));

err:
    __wt_scr_free(session, &tmp);
    return (ret);
}
