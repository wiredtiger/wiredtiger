#include <ostream>
#include <string>
#include <vector>
#include <map>
#include <set>
#ifndef SWIG
extern "C" {
#include "workgen_func.h"
}
#endif

namespace workgen {

struct Context;
struct Thread;
struct Throttle;
struct Transaction;

struct TableStats {
    uint64_t inserts;
    uint64_t not_found;
    uint64_t reads;
    uint64_t removes;
    uint64_t updates;
    uint64_t truncates;
    TableStats() : inserts(0), not_found(0), reads(0), removes(0),
	updates(0), truncates(0) {}
    void add(const TableStats&);
    void subtract(const TableStats&);
    void clear();
    void describe(std::ostream &os) const;
    void report(std::ostream &os) const;
    void final_report(std::ostream &os, timespec &totalsecs) const;
};

#ifndef SWIG
// A 'tint' or ('table integer') is a unique small value integer
// assigned to each table URI in use.  Currently, we assign it once,
// and its value persists through the lifetime of the Context.
typedef uint32_t tint_t;

// There is one of these per Thread object.
// It is not exposed to Python.
struct ThreadEnvironment {
    int _errno;
    Thread *_thread;
    Context *_context;
    workgen_random_state *_rand_state;
    Throttle *_throttle;
    uint64_t _throttle_ops;
    uint64_t _throttle_limit;
    bool _in_transaction;
    uint32_t _number;
    TableStats _stats;

    enum Usage { USAGE_READ = 0x1, USAGE_WRITE = 0x2, USAGE_MIXED = 0x4 };
    std::map<tint_t, uint32_t> _table_usage;       // value is Usage
    WT_CURSOR **_cursors;                          // indexed by tint_t

    ThreadEnvironment();
    ~ThreadEnvironment();

    int create(WT_SESSION *session);
    int open(WT_SESSION *session);
    int close();
    void free_all();
    static int cross_check(std::vector<ThreadEnvironment> &envs);

#ifdef _DEBUG
    std::stringstream _debug_messages;
    std::string get_debug();
#define	DEBUG_CAPTURE(env, expr)	env._debug_messages << expr
#else
#define	DEBUG_CAPTURE(env, expr)
#endif
};

struct Throttle {
    ThreadEnvironment &_env;
    double _throttle;
    double _burst;
    timespec _next_div;
    int64_t _ops_delta;
    uint64_t _ops_prev;         // previously returned value
    uint64_t _ops_per_div;      // statically calculated.
    uint64_t _ms_per_div;       // statically calculated.
    bool _started;

    Throttle(ThreadEnvironment &env, double throttle, double burst);
    ~Throttle();

    // Called with the number of operations since the last throttle.
    // Sleeps for any needed amount and returns the number operations the
    // caller should perform before the next call to throttle.
    int throttle(uint64_t op_count, uint64_t *op_limit);
};

// A exception generated by the workgen classes.  Methods generally return an
// int errno, so this is useful primarily for notifying the caller about
// failures in constructors.
struct WorkgenException {
    std::string _str;
    WorkgenException() : _str() {}
    WorkgenException(int err, const char *msg = NULL) : _str() {
	if (err != 0)
	    _str += wiredtiger_strerror(err);
	if (msg != NULL) {
	    if (!_str.empty())
		_str += ": ";
	    _str += msg;
	}
    }
    WorkgenException(const WorkgenException &other) : _str(other._str) {}
    ~WorkgenException() {}
};
#endif

// A Context tracks the current record number for each uri, used
// for key generation.
//
struct Context {
    bool _verbose;
#ifndef SWIG
    std::map<std::string, tint_t> _tint;           // maps uri -> tint_t
    std::map<tint_t, std::string> _table_names;    // reverse mapping
    uint64_t *_recno;                              // # entries per tint_t
    uint32_t _recno_alloced;                       // length of allocated _recno
    tint_t _tint_last;                             // last tint allocated
    // unique id per context, to work with multiple contexts, starts at 1.
    uint32_t _context_count;
#endif
    Context();
    ~Context();
    void describe(std::ostream &os) const {
	os << "Context: verbose " << (_verbose ? "true" : "false");
    }
    int create_all();
};

struct Table {
    std::string _uri;
#ifndef SWIG
    tint_t _tint;
    uint32_t _context_count;
#endif

    /* XXX select table from range */

    Table();
    Table(const char *tablename);
    Table(const Table &other);
    ~Table();

    void describe(std::ostream &os) const;
};

struct Key {
    typedef enum { KEYGEN_APPEND, KEYGEN_PARETO, KEYGEN_UNIFORM } KeyType;
    KeyType _keytype;
    int _size;
#ifndef SWIG
    uint64_t _max;
#endif

    /* XXX specify more about key distribution */
    Key() : _keytype(KEYGEN_APPEND), _size(0), _max(0) {}
    Key(KeyType keytype, int size) : _keytype(keytype), _size(size), _max(0) {
	compute_max();
    }
    Key(const Key &other) : _keytype(other._keytype), _size(other._size),
	_max(other._max) {}
    ~Key() {}

    void describe(std::ostream &os) const { os << "Key: type " << _keytype << ", size " << _size; }
    void compute_max();

#ifndef SWIG
    void gen(uint64_t, char *) const;
    void size_buffer(size_t &keysize) const;
#endif
};

struct Value {
    int _size;
#ifndef SWIG
    uint64_t _max;
#endif

    /* XXX specify how value is calculated */
    Value() : _size(0), _max(0) {}
    Value(int size) : _size(size), _max(0) {
	compute_max();
    }
    Value(const Value &other) : _size(other._size), _max(other._max) {}
    ~Value() {}

    void describe(std::ostream &os) const { os << "Value: size " << _size; }
    void compute_max();

#ifndef SWIG
    void gen(uint64_t, char *) const;
    void size_buffer(size_t &keysize) const;
#endif
};

struct Operation {
    enum OpType {
	OP_NONE, OP_INSERT, OP_REMOVE, OP_SEARCH, OP_UPDATE };
    OpType _optype;

    Table _table;
    Key _key;
    Value _value;
    Transaction *_transaction;
    std::vector<Operation> *_group;
    int _repeatgroup;

    Operation();
    Operation(OpType optype, Table table, Key key, Value value);
    Operation(OpType optype, Table table, Key key);
    Operation(const Operation &other);
    ~Operation();

    void describe(std::ostream &os) const;

#ifndef SWIG
    int open_all(WT_SESSION *session, ThreadEnvironment &env);
    int run(ThreadEnvironment &env);
    void create_all(ThreadEnvironment &env, size_t &keysize,
	size_t &valuesize);
    void get_static_counts(TableStats &);
#endif
};

struct ThreadOptions {
    std::string name;
    double throttle;
    double throttle_burst;  // 0.0 = steady, 1.0 = moderate bursts, etc.

    ThreadOptions();
    ThreadOptions(const ThreadOptions &other);
    ~ThreadOptions();

    void describe(std::ostream &os) const {
	os << "throttle " << throttle;
    }
};

struct Thread {
    ThreadOptions options;
    std::vector<Operation> _ops;
    bool _stop;
    int _count;
#ifndef SWIG
    WT_SESSION *_session;
    char *_keybuf;
    char *_valuebuf;
    bool _repeat;
#endif

    Thread();
    Thread(const std::vector<Operation> &ops, int count = 1);
    Thread(const Thread &other);
    ~Thread();

    void describe(std::ostream &os) const;

#ifndef SWIG
    int close_all(ThreadEnvironment &env);
    int create_all(WT_CONNECTION *conn, ThreadEnvironment &env);
    void free_all();
    void get_static_counts(TableStats &);
    int open_all(ThreadEnvironment &env);
    int run(ThreadEnvironment &env);
#endif
};

struct Transaction {
    bool _rollback;
    std::string _begin_config;
    std::string _commit_config;

    Transaction(const char *_config = NULL) : _rollback(false),
       _begin_config(_config == NULL ? "" : _config), _commit_config() {}

    void describe(std::ostream &os) const {
	os << "Transaction: ";
	if (_rollback)
	    os << "(rollback) ";
	os << "begin_config: " << _begin_config;
	if (!_commit_config.empty())
	    os << ", commit_config: " << _commit_config;
    }
};

struct WorkloadOptions {
    int run_time;
    int report_interval;

    WorkloadOptions();
    WorkloadOptions(const WorkloadOptions &other);
    ~WorkloadOptions();

    void describe(std::ostream &os) const {
	os << "run_time " << run_time;
	os << ", report_interval " << report_interval;
    }
};

struct Workload {
    WorkloadOptions options;
    Context *_context;
    std::vector<Thread> _threads;

    Workload(Context *context, const std::vector<Thread> &threads);
    Workload(const Workload &other);
    ~Workload();

    void describe(std::ostream &os) const {
	os << "Workload: ";
	_context->describe(os);
	os << ", ";
	options.describe(os);
	os << ", [" << std::endl;
	for (std::vector<Thread>::const_iterator i = _threads.begin(); i != _threads.end(); i++) {
	    os << "  "; i->describe(os); os << std::endl;
	}
	os << "]";
    }
    int run(WT_CONNECTION *conn);

private:
    int close_all(std::vector<ThreadEnvironment> &envs);
    int create_all(WT_CONNECTION *conn, Context *context,
	std::vector<ThreadEnvironment> &envs);
    void final_report(std::vector<ThreadEnvironment>&, timespec &);
    void get_stats(std::vector<ThreadEnvironment>&, TableStats &stats);
    int open_all(std::vector<ThreadEnvironment> &envs);
    void report(std::vector<ThreadEnvironment>&, time_t, time_t, TableStats &);
    int run_all(std::vector<ThreadEnvironment> &envs);
};

};
