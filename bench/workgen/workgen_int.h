#include <ostream>
#include <string>
#include <vector>
#include <map>
#include <set>
#ifndef SWIG
extern "C" {
#include "workgen_func.h"
}
#endif

namespace workgen {

// A 'tint' or ('table integer') is a unique small value integer
// assigned to each table URI in use.  Currently, we assign it once,
// and its value persists through the lifetime of the Context.
typedef uint32_t tint_t;

struct ThreadRunner;

// A exception generated by the workgen classes.  Methods generally return an
// int errno, so this is useful primarily for notifying the caller about
// failures in constructors.
struct WorkgenException {
    std::string _str;
    WorkgenException() : _str() {}
    WorkgenException(int err, const char *msg = NULL) : _str() {
	if (err != 0)
	    _str += wiredtiger_strerror(err);
	if (msg != NULL) {
	    if (!_str.empty())
		_str += ": ";
	    _str += msg;
	}
    }
    WorkgenException(const WorkgenException &other) : _str(other._str) {}
    ~WorkgenException() {}
};

struct Throttle {
    ThreadRunner &_runner;
    double _throttle;
    double _burst;
    timespec _next_div;
    int64_t _ops_delta;
    uint64_t _ops_prev;         // previously returned value
    uint64_t _ops_per_div;      // statically calculated.
    uint64_t _ms_per_div;       // statically calculated.
    bool _started;

    Throttle(ThreadRunner &runner, double throttle, double burst);
    ~Throttle();

    // Called with the number of operations since the last throttle.
    // Sleeps for any needed amount and returns the number operations the
    // caller should perform before the next call to throttle.
    int throttle(uint64_t op_count, uint64_t *op_limit);
};

// There is one of these per Thread object.
// It is not exposed to Python.
struct ThreadRunner {
    int _errno;
    WorkgenException _exception;
    Thread *_thread;
    Context *_context;
    ContextInternal *_icontext;
    Workload *_workload;
    WorkloadInternal *_iworkload;
    workgen_random_state *_rand_state;
    Throttle *_throttle;
    uint64_t _throttle_ops;
    uint64_t _throttle_limit;
    bool _in_transaction;
    uint32_t _number;
    Stats _stats;

    typedef enum {
	USAGE_READ = 0x1, USAGE_WRITE = 0x2, USAGE_MIXED = 0x4 } Usage;
    std::map<tint_t, uint32_t> _table_usage;       // value is Usage
    WT_CURSOR **_cursors;                          // indexed by tint_t
    bool _stop;
    WT_SESSION *_session;
    char *_keybuf;
    char *_valuebuf;
    bool _repeat;

    ThreadRunner();
    ~ThreadRunner();

    int create(WT_SESSION *session);
    int open(WT_SESSION *session);
    int close();
    void free_all();
    static int cross_check(std::vector<ThreadRunner> &runners);

    int close_all();
    int create_all(WT_CONNECTION *conn);
    void get_static_counts(Stats &);
    int open_all();
    int run();

    void op_create_all(Operation *, size_t &keysize, size_t &valuesize);
    uint64_t op_get_key_recno(Operation *, tint_t tint);
    void op_get_static_counts(Operation *, Stats &, int);
    int op_run(Operation *);

#ifdef _DEBUG
    std::stringstream _debug_messages;
    std::string get_debug();
#define	DEBUG_CAPTURE(runner, expr)	runner._debug_messages << expr
#else
#define	DEBUG_CAPTURE(runner, expr)
#endif
};

struct ContextInternal {
    std::map<std::string, tint_t> _tint;           // maps uri -> tint_t
    std::map<tint_t, std::string> _table_names;    // reverse mapping
    uint64_t *_recno;                              // # entries per tint_t
    uint32_t _recno_alloced;                       // length of allocated _recno
    tint_t _tint_last;                             // last tint allocated
    // unique id per context, to work with multiple contexts, starts at 1.
    uint32_t _context_count;

    ContextInternal();
    ~ContextInternal();
    int create_all();
};

struct TableInternal {
    tint_t _tint;
    uint32_t _context_count;

    TableInternal();
    TableInternal(const TableInternal &other);
    ~TableInternal();
};

struct WorkloadInternal {
    Workload *_workload;
    WorkloadInternal();
    WorkloadInternal(const WorkloadInternal &other);
    ~WorkloadInternal();
    int run(WT_CONNECTION *conn);

private:
    int close_all(std::vector<ThreadRunner> &runners);
    int create_all(WT_CONNECTION *conn, Context *context,
	std::vector<ThreadRunner> &runners);
    void final_report(std::vector<ThreadRunner>&, timespec &);
    void get_stats(std::vector<ThreadRunner>&, Stats *stats);
    int open_all(std::vector<ThreadRunner> &runners);
    void report(std::vector<ThreadRunner>&, time_t, time_t, Stats *stats);
    int run_all(std::vector<ThreadRunner> &runners);
};

};
